Launchpad Build Infrastructure
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Points of concern currently...

SourcePackageRelease records may not be associated with any specific
DistroSeries. If that happens to be the case; what DistroArchSeries
do we build them for?


Database changes
^^^^^^^^^^^^^^^^

CREATE TABLE BuildQueue (
  id SERIAL PRIMARY KEY,
  build INTEGER FOREIGN KEY REFERENCES build(id) NOT NULL,
  builder INTEGER FOREIGN KEY REFERENCES builder(id),
  created TIMESTAMP WITH TIMEZONE NOT NULL,
  buildstart TIMESTAMP WITH TIMEZONE,
  logtail TEXT,

);

-- If speedindex is NULL, we don't know, else it is the number of seconds
-- needed to build a reference package or something.
ALTER TABLE Builder ADD COLUMN speedindex INTEGER;

Basic case decision on what to build
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For each DistroSeries which is currently marked for
autobuilding... Find all SourcePackageReleases published into that
DistroSeries for which the set of Build records does not contain
entirely the set of DistroArchSeries being built for that
DistroSeries.

For each of those; create a build record in "Needs Building" state

Next gather every Build record in the "Needs Building" state for which
no BuildQueue entry exists and create the BuildQueue entry.

For each entry in the BuildQueue for whom the Build record states a
builder, query the builder for that build's state.

 * complete successful builds are extracted; recorded; the BuildQueue
   entry removed. The time to build is recorded for future estimates.
 * failed builds are logged as such, the Build record is marked as 
   "Failed to build" and the BuildQueue entry is removed.
 * failed builds (failing due to dependencies) have their logs recorded
   and the BuildQueue.builder is cleared; the Build is placed into
   "Manual Dep Wait" state
 * failed builds (failing due to chroot issues) have the same
   done for them and are placed into "Chroot Wait" state. Also a
   chroot-damage mail is sent out.
 * failed builds (failing due to disk issues) are simply returned to
   the "Needs Building" state, the builder is marked as failed and
   a builder-failure mail is sent out. If that was the last builder
   for a given architecture then lots of panicy emails are sent.
 * incomplete builds have their logtails updated.

For each entry in the BuildQueue for whom the Build record states
"Needs Building" (rather than ex. "Manual Dep Wait")

 * Calculate for each entry the chroot id needed.
 * Any entry for which the chroot is unavailable is placed into
   "Chroot Wait" state and is pared from the list
 * Any entry for which the chroot is known bad is placed into the
   "Chroot Wait" state
 * Any entry for which there is currently no available builder is
   pared from the list.
 * For each remaining entry; the build-dependencies are analysed out
   and a decision is made about whether or not the build is likely
   to dep-wait or not. Any for which a dep-wait is inevitable is pared
   out and left as "Needs Building"
 * For each remaining entry a score is calculated. This is based upon
   the score generated by the Distro{,Release}'s policy engine for
   deciding what order things get built. Also taken into account are
   things like whether or not the sourcepackage has been built on that
   DistroSeries before.
   Also an estimation of the time to build the package is calculated.
   This is measured as a fraction/multiple of the time it takes to
   build a "standard" package. This combined with the speed measure
   of each builder available for the architecture provides us with
   an estimate of how long the package will take to build on any given
   builder.
 * For each architecture in turn, order the pending builds by their
   score. For each builder except the last; choose the next highest
   scoring package and queue the start of the build on the builder.
   For the last builder; reorder by estimated time to build (in an
   exponential growth grouping) and by score. Queue the highest scoring
   package in the shortest-time-to-build group.
 * For each queued action; download the required chroot to the builder
   if it doesn't already have it; download the sources to it and then
   initiate the build. Record the fact that it is building.

The scoring mechanism for pending builds
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

 * Estimated timeto run (smaller == more points)
 * Time spent in the build queue (longer == more points)
 * Position in build dependency chains (depended on == more points)
 * Distribution specific policy (E.g. toolchains first)
 * Priority of package (Base before Desktop before Supported)
 * Urgency of upload
 * Overarching policy (E.g. security builds first)

Time groupings for packages
^^^^^^^^^^^^^^^^^^^^^^^^^^^

 * Five minutes or less
 * Five to fifteen minutes
 * Fifteen to thirty minutes
 * Thirty to sixty minutes
 * Greater than sixty minutes


The build-master <-> build slave protocol
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Operated entirely over XML-RPC... Always initiated by the master to
the slave; the only outgoing sockets the slave is permitted are direct
to the public archive machine.

Buildd slaves have HTTP read-only access to librarian.

Buildd master is called Fiera
Buildd slaves are called Bob

Calls that the master can make to the slave
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

 INFO (none) ->
    Slave Protocol Version
    [ Commands Understood ]    

 STATUS (none) ->
    IDLE / BUILDING / WAITING / ABORTED
    if BUILDING
       BUILD-ID in progress
       LOGTAIL (last 1kB or so of the log)
    if WAITING
       OK / DEPFAIL / PACKAGEFAIL / CHROOTFAIL / BUILDERFAIL
       BUILD-ID waiting
       List of filename <-> SHA1sum waiting for upload
                if OK / PACKAGEFAIL
    if ABORTED
       BUILD-ID Aborted

 FETCHLOGTAIL (amount) ->
    tail of log file (all of log file if amount <= 0) else (up-to) amount bytes
    Returns an empty string if no build is in progress

 DOYOUHAVE (SHA1sum) ->
    YES / NO  
    (May fetch from the librarian and return YES if it lacks the file)

 STOREFILE (CONTENT) ->
    Stores the CONTENT and returns SHA1sum

 FETCHFILE (SHA1sum) ->
    CONTENT for that SHA1summed file

 STARTBUILD (BUILD-ID, SHA1sum <-> filename list, CHROOT SHA1sum,
	     BUILDCOMMAND) ->
    UNKNOWN-SUM 
      SHA1sum
    UNKNOWN-BUILDER
    INITIATED

 ABORT (none) ->
    Any build in progress is aborted and the builder is placed in
    ABORTED, returns ABORTED

 CLEAN (none) ->
    The file-cache gets cleaned up, state is reverted to IDLE
    returns IDLE

An example interaction
^^^^^^^^^^^^^^^^^^^^^^

STATUS() -> IDLE
DOYOUHAVE(chrootsum) -> YES
DOYOUHAVE(dscsum) -> NO
STOREFILE(foo.dsc) -> dscsum
DOYOUHAVE(origsum) -> YES
DOYOUHAVE(diffsum) -> NO
STOREFILE(foo.diff.gz) -> diffsum
STARTBUILD(10023, { foo.dsc: dscsum,
                    foo.orig.tar: origsum, 
                    foo.diff.gz: diffsum },
           chrootsum, DEBIAN-SOURCE) -> INITIATED
STATUS() -> BUILDING, 10023, "...logtail"

...time passes...

STATUS() -> BUILDING, 10023, "...logtail"

...time passes...

STATUS() -> WAITING, OK, 10023, foo.deb=debsum, foo.changes=changessum,
            BUILDLOG=logsum
FETCHFILE(debsum) -> foo.deb
FETCHFILE(changessum) -> foo.changes
FETCHFILE(logsum) -> BUILDLOG
CLEAN() -> OK
STATUS() -> IDLE
