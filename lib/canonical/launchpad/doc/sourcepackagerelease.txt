= Source Package Release =

The SourcePackageRelease table represents a particular release of a
SourcePackageName, but isn't tied to any particular DistroSeries
as the same release can appear in many.

In a very basic explanation, this table caches the attributes of an
uploaded DSC (Debian Source Control) file.

This model allow us to have more granular control of the fields,
enabling faster searches, faster readings and model constraints.

== Basic attributes ==

Let's get one from the database:

   >>> from canonical.launchpad.database import SourcePackageRelease
   >>> spr = SourcePackageRelease.get(14)
   >>> spr.name
   u'mozilla-firefox'
   >>> spr.version
   u'0.9'
   >>> spr.dateuploaded
   datetime.datetime(...)

'age' is a special property that performs on-the-fly:
{{{
NOW - dateuploaded
}}}
It returns a timedelta object:

   >>> spr.age
   datetime.timedelta(...)

Check if the result match the locally calculated one:

   >>> import datetime
   >>> import pytz
   >>> local_now = datetime.datetime.now(pytz.timezone('UTC'))

   >>> expected_age = local_now - spr.dateuploaded
   >>> spr.age.days == expected_age.days
   True

Modify dateuploaded to a certain number of days in the past and check
if the 'age' result looks sane:

   >>> spr.dateuploaded = (local_now - datetime.timedelta(days=10))
   >>> spr.age.days == 10
   True

Mozilla-firefox 0.9 has got some builds. including a PPA build.  The 'builds'
property only returns the non-PPA builds.

   >>> from canonical.launchpad.interfaces import IPersonSet
   >>> from canonical.launchpad.database.build import Build
   >>> cprov_ppa = getUtility(IPersonSet).getByName('cprov').archive
   >>> ff_ppa_build = Build.selectBy(
   ...     archive=cprov_ppa, sourcepackagerelease=spr)
   >>> ff_ppa_build.count()
   1
   >>> ff_ppa_build[0].archive.purpose.name
   'PPA'
   >>> spr.builds.count()
   4

All the builds returned are for non-PPA archives:

   >>> set(build.archive.purpose.name for build in spr.builds)
   set(['PRIMARY'])

We can use the magic productrelease property to map this to a ProductRelease:

   >>> pr = spr.productrelease
   >>> print pr.product.name
   firefox
   >>> print pr.productseries.name
   trunk
   >>> print pr.version
   0.9

We can use the sourcepackage and distrosourcepackage properties to
grab magical objects representing that package in the distribution to
which it was uploaded:

   >>> print spr.sourcepackage.displayname
   Hoary mozilla-firefox
   >>> print spr.distrosourcepackage.displayname
   mozilla-firefox in ubuntu

It should also work when the version has a dash and packaging revision
after it:

   >>> spr = SourcePackageRelease.get(16)
   >>> print spr.name
   netapplet
   >>> print spr.version
   1.0-1
   >>> pr = spr.productrelease
   >>> print pr.product.name
   netapplet
   >>> print pr.productseries.name
   trunk
   >>> print pr.version
   1.0

If there isn't one, that should return None.

   >>> print SourcePackageRelease.get(20).productrelease
   None

Check that the uploaded changesfile works:

   >>> commercial = SourcePackageRelease.get(36)
   >>> commercial.upload_changesfile.http_url
   'http://.../commercialpackage_1.0-1_source.changes'

Check ISourcePackageRelease.override() behaviour:

   >>> spr.component.name, spr.section.name
   (u'main', u'editors')

   >>> from canonical.launchpad.interfaces import (
   ...     IComponentSet, ISectionSet)
   >>> new_comp = getUtility(IComponentSet)['universe']
   >>> new_sec = getUtility(ISectionSet)['mail']

Override the current sourcepackagerelease with new component/section
pair:

   >>> spr.override(component=new_comp, section=new_sec)

   >>> spr.component.name, spr.section.name
   (u'universe', u'mail')

Abort transaction to avoid error propagation of the new attributes:

   >>> import transaction
   >>> transaction.abort()


Verify the creation of a new ISourcePackageRelease based on the
IDistroSeries API:

  >>> from canonical.launchpad.interfaces import (
  ...     IDistributionSet, ISourcePackageNameSet, IGPGKeySet)
  >>> from canonical.database.constants import UTC_NOW
  >>> from canonical.launchpad.interfaces import SourcePackageUrgency

  >>> hoary = getUtility(IDistributionSet)['ubuntu']['hoary']

All the arguments to create an ISourcePackageRelease are obtained when
processing a source upload, see more details in nascentupload.txt.
Some of the 20 required arguments are foreign keys or DB contants:

  >>> arg_name = getUtility(ISourcePackageNameSet)['pmount']
  >>> arg_comp = getUtility(IComponentSet)['universe']
  >>> arg_sect = getUtility(ISectionSet)['web']
  >>> arg_key = getUtility(IGPGKeySet).get(1)
  >>> arg_maintainer = hoary.owner
  >>> arg_creator = hoary.owner
  >>> arg_urgency = SourcePackageUrgency.LOW

The other argurments are strings:

  >>> version = '0.0.99'
  >>> dsc = 'smashed dsc...'
  >>> copyright = 'smashed debian/copyright ...'
  >>> changelog = 'contigous text....'
  >>> archhintlist = 'any'
  >>> builddepends = 'cdbs, debhelper (>= 4.1.0), libsysfs-dev, libhal-dev'
  >>> builddependsindep = ''
  >>> dsc_maintainer_rfc822 = 'Foo Bar <foo@bar.com>'
  >>> dsc_standards_version = '2.6.1'
  >>> dsc_format = '1.0'
  >>> dsc_binaries = 'pmount'
  >>> archive = hoary.main_archive

Having proper arguments in hand we can create a new
ISourcePackageRelease, it will automatically set the
'uploaddistroseries' to the API entry point, in this case Hoary.

  >>> new_spr = hoary.createUploadedSourcePackageRelease(
  ...     arg_name, version, arg_maintainer,
  ...     builddepends, builddependsindep, archhintlist, arg_comp, arg_creator,
  ...     arg_urgency, changelog, dsc, arg_key, arg_sect,
  ...     dsc_maintainer_rfc822, dsc_standards_version, dsc_format,
  ...     dsc_binaries, archive, copyright=copyright)

  >>> new_spr.uploaddistroseries.name
  u'hoary'
  >>> new_spr.version
  u'0.0.99'
  >>> new_spr.upload_archive.id == hoary.main_archive.id
  True
  >>> new_spr.copyright
  u'smashed debian/copyright ...'

Throw away the DB changes:

  >>> transaction.abort()

Let's get a sample SourcePackageRelease:

   >>> spr_test = SourcePackageRelease.get(20)
   >>> spr_test.name
   u'pmount'


== Creating & Looking for Build records ==

ISourcePackageRelease has the ability to create Build records,
however it needs fully support to treat architecturehintlist and P-a-s
information, see further information in buildd-queuebuilder.txt.

ISourcePackageRelease also provides a 'getBuildByArch' method which
allow the applications to lookup for Build records in a given
DistroArchSeries and Archive.

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> hoary = ubuntu['hoary']
    >>> hoary_i386 = hoary['i386']
    >>> hoary_hppa = hoary['hppa']

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName('cprov')

    >>> from canonical.launchpad.interfaces import PackagePublishingPocket
    >>> pocket_release = PackagePublishingPocket.RELEASE

The base method createBuild() is able to create build to a given
distroarchseries, pocket and archive.

Build.buildstate, by default is set to NEEDSBUILD.

    >>> hoary_evo_sp = hoary.getSourcePackage('evolution')
    >>> evo_spr = hoary_evo_sp['1.0'].sourcepackagerelease

    >>> evo_build_i386 = evo_spr.createBuild(
    ...     hoary_i386, pocket_release, ubuntu.main_archive)

    >>> evo_build_i386.buildstate.name
    'NEEDSBUILD'

    >>> evo_build_i386.distroarchseries.architecturetag
    u'i386'

    >>> print evo_build_i386.archive.title
    Primary Archive for Ubuntu Linux

Optionally you can pass also another status:

    >>> from canonical.launchpad.interfaces import BuildStatus
    >>> evo_build_i386_ppa = evo_spr.createBuild(
    ...     hoary_i386, pocket_release, cprov.archive,
    ...     status=BuildStatus.SUPERSEDED)

    >>> evo_build_i386_ppa.buildstate.name
    'SUPERSEDED'

Successfully Build lookups on the just created Build records:

    >>> test_build_i386 = evo_spr.getBuildByArch(
    ...     hoary_i386, ubuntu.main_archive)
    >>> test_build_i386 == evo_build_i386
    True

    >>> test_build_i386_ppa = evo_spr.getBuildByArch(
    ...     hoary_i386, cprov.archive)
    >>> test_build_i386_ppa == evo_build_i386_ppa
    True

Failed Build lookups for evolution on hoary/hppa in both archives:

    >>> test_build_hppa = evo_spr.getBuildByArch(
    ...     hoary_hppa, ubuntu.main_archive)
    >>> test_build_hppa is None
    True

    >>> test_build_hppa_ppa = evo_spr.getBuildByArch(
    ...     hoary_hppa, cprov.archive)
    >>> test_build_hppa_ppa is None
    True

Even if the source package builds a architecture-independent package,
no Build record will be returned by getBuildByArch() if arch-specific
binary packages were not built (see bug #65712 for further
information).

Let's create and publish and architecture-independent binary for
evolution_1.0:

    >>> from canonical.launchpad.interfaces import (
    ...     BinaryPackageFormat, IBinaryPackageNameSet, IComponentSet,
    ...     ISectionSet, PackagePublishingPriority, PackagePublishingStatus)
    >>> from canonical.launchpad.database import (
    ...    SecureBinaryPackagePublishingHistory)

    >>> main_component = getUtility(IComponentSet)['main']
    >>> mail_section = getUtility(ISectionSet)['mail']
    >>> binarypackageformat = BinaryPackageFormat.DEB
    >>> extra_priority = PackagePublishingPriority.EXTRA
    >>> evo_bin_name = getUtility(IBinaryPackageNameSet).ensure('evolution')

    >>> evo_bin = evo_build_i386.createBinaryPackageRelease(
    ...      evo_bin_name, '1.0', 'no sum', 'no desc',
    ...      binarypackageformat, main_component, mail_section, extra_priority,
    ...      '', '', '', '', '', '', '', False, 1, False)

Publish 'evo_bin' in all supported architectures (as expected for
arch-indep binaries).

    >>> pubs = []
    >>> for arch in [hoary_i386, hoary_hppa]:
    ...     pub = SecureBinaryPackagePublishingHistory(
    ...         binarypackagerelease=evo_bin,
    ...         distroarchseries=arch,
    ...         component=main_component,
    ...         section=mail_section,
    ...         priority=extra_priority,
    ...         status=PackagePublishingStatus.PUBLISHED,
    ...         pocket=pocket_release,
    ...         archive=ubuntu.main_archive)
    ...     pubs.append(pub)

Now, verifying that the bug mentioned is fixed, we can observe that a
lookup for the HPPA build correctly returns 'None'.

    >>> test_build_hppa = evo_spr.getBuildByArch(
    ...     hoary_hppa, ubuntu.main_archive)
    >>> print test_build_hppa
    None

And the original build record is still reachable.

    >>> test_build_i386 = evo_spr.getBuildByArch(
    ...     hoary_i386, ubuntu.main_archive)
    >>> print test_build_i386.title
    i386 build of evolution 1.0 in ubuntu hoary RELEASE

We will copy the evolution source to ubuntu/breezy-autotest as if it
was inherited in the initialization.

    >>> breezy_autotest = ubuntu['breezy-autotest']
    >>> breezy_autotest_i386 = breezy_autotest['i386']

    >>> print breezy_autotest.parentseries.title
    The Hoary Hedgehog Release

    >>> hoary_evo_dsspr = hoary_evo_sp['1.0']
    >>> copied_pub = hoary_evo_dsspr.current_published.copyTo(
    ...     breezy_autotest, pocket_release)

    >>> breezy_autotest_evo_sp = breezy_autotest.getSourcePackage('evolution')
    >>> breezy_autotest_evo_dsspr = breezy_autotest_evo_sp['1.0']
    >>> evo_spr == breezy_autotest_evo_dsspr.sourcepackagerelease
    True

Since evolution source was already built on ubuntu/hoary/i386, the
parent series, it should be found by a build lookup happening on
ubuntu/breezy-autotest/i386.

In practical terms it means that another build is not necessary in
this context.

    >>> breezy_autotest_build = evo_spr.getBuildByArch(
    ...     breezy_autotest_i386, ubuntu.main_archive)
    >>> print breezy_autotest_build.title
    i386 build of evolution 1.0 in ubuntu hoary RELEASE


== Counting bugs ==

The SourcePackageRelease offers a convenient way of checking how many
bugs are open against this package in the distribution to which it was
uploaded. Because of bug privacy, this method needs a user supplied.

   >>> spr = SourcePackageRelease.get(14)
   >>> print spr.name
   mozilla-firefox
   >>> login('no-priv@canonical.com')
   >>> no_priv = getUtility(ILaunchBag).user
   >>> print spr.countOpenBugsInUploadedDistro(no_priv)
   1


== Uploading translations ==

It's time to check the translation upload function.

   >>> import canonical.launchpad
   >>> import os.path
   >>> import transaction
   >>> from canonical.launchpad.interfaces import ITranslationImportQueue
   >>> from canonical.librarian.interfaces import ILibrarianClient
   >>> translation_import_queue = getUtility(ITranslationImportQueue)
   >>> client = getUtility(ILibrarianClient)

We need a test tarball uploaded into librarian to run this test.

   >>> test_file_name = os.path.join(
   ...     os.path.dirname(canonical.launchpad.__file__),
   ...     'doc/sourcepackagerelease-translations.tar.gz')
   >>> file = open(test_file_name)
   >>> size = len(file.read())
   >>> file.seek(0)
   >>> alias = client.addFile(
   ...     name='test.tar.gz',
   ...     size=size,
   ...     file=file,
   ...     contentType='application/x-gtar')

We need the commit to see the upload.

   >>> transaction.commit()

Now we do the upload. It's necessary to retrive an ILibraryFileAlias
correspondent to the alias (long) we already have.

   >>> from canonical.launchpad.interfaces import ILibraryFileAliasSet
   >>> file_alias = getUtility(ILibraryFileAliasSet)[alias]

   >>> spr_test = SourcePackageRelease.get(20)
   >>> spr_test.name
   u'pmount'

Before the final upload, the queue should be empty.

   >>> translation_import_queue.getAllEntries(
   ...     target=spr_test.sourcepackage).count()
   0

   >>> spr_test.attachTranslationFiles(file_alias, True)

The commit is needed to see the new entries

   >>> transaction.commit()

And the queue should have a new entry.

   >>> translation_import_queue.getAllEntries(
   ...     target=spr_test.sourcepackage).count()
   1

Now, we need to do the final import. It's done as a two steps procedure.

The first one, approves the import.

    >>> import subprocess, sys
    >>> process = subprocess.Popen([
    ...     sys.executable, 'cronscripts/rosetta-approve-imports.py'
    ...     ], stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.STDOUT
    ...     )
    >>> (output, empty) = process.communicate()
    >>> print output
    INFO    creating lockfile
    INFO    The automatic approval system approved some entries.
    INFO    Removed 2 entries from the queue.
    <BLANKLINE>

The second one, executes the import.

    >>> import subprocess, sys
    >>> process = subprocess.Popen([
    ...     sys.executable, 'cronscripts/rosetta-poimport.py'
    ...     ], stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.STDOUT
    ...     )
    >>> (output, empty) = process.communicate()
    >>> print output
    INFO    creating lockfile
    INFO    Importing: Spanish (es) translation of pmount in Ubuntu Hoary package "pmount"
    ...
