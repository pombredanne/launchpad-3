= Builder View Classes and Pages =

    >>> from zope.component import getMultiAdapter, getUtility
    >>> from canonical.launchpad.interfaces import IBuilderSet
    >>> from canonical.launchpad.webapp.interfaces import IBatchNavigator
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

    >>> builder = getUtility(IBuilderSet).get(1)

Get a "mock" request:

    >>> mock_form = {}
    >>> request = LaunchpadTestRequest(form=mock_form)

Let's instantiate the view for +index:

    >>> builder_view = getMultiAdapter((builder, request), name="+index")
    >>> builder_view.now()
    '...'

== Builder history ==

Let's instantiate a view for +history:

    >>> builder_view = getMultiAdapter((builder, request), name="+history")

    setupBuildList, build a batched list of build records and store it
    in view.batch, also store the batch navigator in view.batchnav. it
    simply returns None:

    >>> builder_view.setupBuildList()

As expected we have a 'batched' list with the size requested in
mock_form:

    >>> len(builder_view.batchnav.currentBatch())
    5


== Builder cancel ==

Let's instantiate the view for +cancel:

    >>> request = LaunchpadTestRequest(form={'BUILDERID': 1})

    >>> builder_view = getMultiAdapter((builder, request), name="+cancel")

    >>> builder_view.cancelBuildJob()
    '<p>Cancel (1). Not implemented yet.</p>'


== Builder mode ==

Let's instantiate the view for +mode:

This page requires launchpad.Edit permission and the builder is owned
by mark. we nee to log in as mark or any other member of admin team

    >>> from canonical.launchpad.ftests import login
    >>> login("foo.bar@canonical.com")

Build an special request containing the fields we want to change:

    >>> request = LaunchpadTestRequest(form={
    ...     'field.manual': 'on',
    ...     'UPDATE_SUBMIT': 'Change'})

Instantiate the correspondent view:

    >>> builder_view = getMultiAdapter((builder, request), name="+mode")

Ensure the previous mode was AUTOMATIC

    >>> builder.manual
    False

Call the update() method of the zope.app.form.EditView class

    >>> builder_view.update()
    u'Updated on ${date_time}'

We've changed the builder mode to MANUAL

    >>> builder.manual
    True

== Builder edit ==

Let's instantiate the view for +edit:

Build an special request containing the fields we want to change:

    >>> request = LaunchpadTestRequest(form={
    ...     'field.processor': builder.processor.name,
    ...     'field.url': builder.url,
    ...     'field.name': u'biscoito',
    ...     'field.title': builder.title,
    ...     'field.description': builder.description,
    ...     'UPDATE_SUBMIT': 'Change'})

Instantiate the correspondent view:

    >>> builder_view = getMultiAdapter((builder, request), name="+edit")

Ensure the previous name

    >>> builder.id, builder.name
    (1, u'bob')

Call the update() method of the zope.app.form.EditView class

    >>> builder_view.update()
    u'Updated on ${date_time}'

We've modified the buildername

    >>> builder.id, builder.name
    (1, u'biscoito')


== Builders building private jobs ==

In order to restrict access to private PPA details in general, we also
need to be able to hide the fact that a builder is building a private
PPA job.

This feature is evaluated on the view layer, since it varies according
to the user who is trying to access a given content.

Before checking if it works as expected we will setup a environment
where builder 'Frog' is building a job from Celso's private PPA.

    >>> from canonical.launchpad.database.buildqueue import BuildQueue
    >>> from canonical.launchpad.interfaces import (
    ...    IBuildSet, IBuilderSet, IPersonSet)

    >>> cprov = getUtility(IPersonSet).getByName("cprov")
    >>> cprov.archive.private = True
    >>> cprov.archive.buildd_secret = "secret"

    >>> frog = getUtility(IBuilderSet)['frog']
    >>> frog.builderok = True

    >>> random_build = 2
    >>> cprov_builds = getUtility(
    ...     IBuildSet).getBuildsForArchive(cprov.archive)
    >>> private_job = BuildQueue(
    ...     build=cprov_builds[random_build], builder=frog)

Finally, we will remove any publications of the source behind our
build of interest that are not in cprov's archive, so that we know
we're dealing with a single private source publication.

    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> random_spr = cprov_builds[random_build].sourcepackagerelease
    >>> non_cprov_publications = [
    ...     pub for pub in random_spr.publishings 
    ...     if pub.archive != cprov.archive]
    >>> for pub in non_cprov_publications:
    ...     discard = pub.supersede()

flush_database_caches seems to be required because random_spr.publishings
is an SQLObject MultipleJoin.

    >>> from canonical.database.sqlbase import flush_database_caches
    >>> flush_database_caches()


At the content class level, all the information about the current job
is widely available:

 * Frog is OK;
 * Frog 'currentjob' exists;
 * Frog has no 'failnotes';
 * Frog status exposes its 'currentjob'.

    >>> print frog.builderok
    True

    >>> print frog.currentjob.build.title
    i386 build of iceweasel 1.0 in ubuntu warty RELEASE

    >>> print frog.failnotes
    None

    >>> print frog.status
    BUILDING i386 build of iceweasel 1.0 in ubuntu warty RELEASE [cprov] (AUTO)

Accessing the view for $builder/+index as a Foo Bar, which has
launchpad.View permission on the target archive of the 'currentjob',
all the 'private' information is exposed.

    >>> login("foo.bar@canonical.com")

    >>> empty_request = LaunchpadTestRequest(form={})
    >>> admin_view = getMultiAdapter((frog, empty_request), name="+index")

    >>> print admin_view.context
    <security proxied canonical.launchpad.database.builder.Builder ...>

    >>> print admin_view.context.builderok
    True

    >>> print admin_view.context.currentjob.build.title
    i386 build of iceweasel 1.0 in ubuntu warty RELEASE

    >>> print admin_view.context.failnotes
    None

    >>> print admin_view.context.status
    BUILDING i386 build of iceweasel 1.0 in ubuntu warty RELEASE [cprov] (AUTO)

When accessing the same view as a unprivileged user, No-Priv, the
sensitive information is hidden (the context class is 'cloaked', see
browser/builder.py for futher information on this) and the builder
shows up as 'NOT OK'.

    >>> login('no-priv@canonical.com')

    >>> nopriv_view = getMultiAdapter((frog, empty_request), name="+index")

    >>> print nopriv_view.context
    <canonical.launchpad.browser.builder.HiddenBuilder ...>

    >>> print nopriv_view.context.builderok
    False

    >>> print nopriv_view.context.currentjob
    None

    >>> print nopriv_view.context.failnotes
    None

    >>> print nopriv_view.context.status
    NOT OK: (AUTO)

XXX cprov 20080214: this is clearly a counterintuitive way to identify
builders building private jobs. We will certainly have to fine-tune it
before public release.

Once the private job is gone, Frog 'real' details are exposed publicly
again.

    >>> login("foo.bar@canonical.com")
    >>> private_job.destroySelf()

    >>> login('no-priv@canonical.com')
    >>> nopriv_view = getMultiAdapter((frog, empty_request), name="+index")

    >>> print nopriv_view.context.status
    IDLE (AUTO)

    >>> login(ANONYMOUS)


== BuilderSet view ==

BuilderSetView offer a way to treat the currently registered builders
in categories. They are:

 * 'Building other packages': a group of builders capable of building
   'trusted' sources, ubuntu official packages. The 'non-vitualized'
   build-farm.

 * 'Building PPP packages': a group of builders capable of building
   'untrusted' sources, PPA packages. The 'virtualized' build-farm.

    >>> from canonical.launchpad.interfaces import IBuilderSet
    >>> builderset = getUtility(IBuilderSet)

    >>> builderset_view = getMultiAdapter(
    ...     (builderset, empty_request), name="+index")

In order to have a proper dataset for the tests we will populate the
builder table with several builders for different categories and
architectures.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName('cprov')

    >>> from canonical.launchpad.database.processor import Processor
    >>> i386 = Processor.selectOneBy(name='386')
    >>> amd64 = Processor.selectOneBy(name='amd64')
    >>> hppa = Processor.selectOneBy(name='hppa')

    >>> a_builder = builderset.new(
    ...     i386, url='http://hamburger', name="hamburger",
    ...     title="The Hamburger Builder", description="Uhmmm", owner=cprov,
    ...     virtualized=True)

    >>> a_builder = builderset.new(
    ...     hppa, url='http://cheese', name="cheese",
    ...     title="The Cheese Builder", description="Uhmmm", owner=cprov,
    ...     virtualized=True)

    >>> a_builder = builderset.new(
    ...     amd64, url='http://bacon', name="bacon",
    ...     title="The Bacon Builder", description="Uhmmm", owner=cprov,
    ...     virtualized=True)

    >>> a_builder = builderset.new(
    ...     i386, url='http://egg', name="egg",
    ...     title="The Egg Builder", description="Uhmmm", owner=cprov,
    ...     virtualized=False)

    >>> a_builder = builderset.new(
    ...     hppa, url='http://ham', name="ham",
    ...     title="The Ham Builder", description="Uhmmm", owner=cprov,
    ...     virtualized=False)

    >>> a_builder = builderset.new(
    ...     amd64, url='http://prosciuto', name="prosciuto",
    ...     title="The Prosciuto Builder", description="Uhmmm", owner=cprov,
    ...     virtualized=False)

The 'Other' builder category is a `BuilderCategory` class, which
contains the following attributes:

 * title: the title that will be presented for this category in the UI;

 * virtualized: wheter the category represents the virtualized or
   non-virtualized build-farm;

 * groups: a property that return all `BuilderGroup` instanced
   available in this category ordered by processor name.

    >>> builder_category = builderset_view.other_builders

    >>> print builder_category
    <...BuilderCategory ...>

    >>> print builder_category.title
    Building other packages

    >>> print builder_category.virtualized
    False

    >>> print builder_category.groups[0]
    <...BuilderGroup ...>

Similarly to what is done in the UI, we have a helper that prints the
grouped builders within a category in a easy manner.

    >>> def print_category(category):
    ...     for group in category.groups:
    ...         print group.processor_name, group.queue_size
    ...         for builder in group.builders:
    ...             print builder.title

    >>> print_category(builder_category)
    386 1
    Bob The Builder
    The Egg Builder
    amd64 0
    The Prosciuto Builder
    hppa 0
    The Ham Builder

Each `BuilderGroup` contains the following attributes:

 * processor_name: the `Processor` name of all builders in this group;

 * queue_size: the number of jobs wainting to be processed for one of
   the builders in this group

 * builders: a list of `Builder`s in this group.

    >>> [i386_group, amd64_group, hppa_group] = builder_category.groups

    >>> print i386_group.processor_name
    386

    >>> print i386_group.queue_size
    1

    >>> for builder in i386_group.builders:
    ...     print builder.title
    Bob The Builder
    The Egg Builder

The 'PPA' builder category is also available in BuilderSetView as a
`BuilderCategory`.

    >>> builder_category = builderset_view.ppa_builders

    >>> print builder_category.title
    Building PPA packages

    >>> print builder_category.virtualized
    True

    >>> print_category(builder_category)
    386 0
    The Hamburger Builder
    The frog builder
    amd64 0
    The Bacon Builder
    hppa 0
    The Cheese Builder

We change the sampledata to create a pending build in for the 386
processor queue in the PPA category.

    >>> from canonical.launchpad.interfaces import BuildStatus
    >>> any_failed_build = cprov.archive.getBuildRecords(
    ...     build_state=BuildStatus.FAILEDTOBUILD)[0]

    >>> login('foo.bar@canonical.com')
    >>> any_failed_build.retry()
    >>> login(ANONYMOUS)

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()

Now the pending build is included in the right category and group.

    >>> builder_category = builderset_view.ppa_builders
    >>> print_category(builder_category)
    386 1
    The Hamburger Builder
    The frog builder
    amd64 0
    The Bacon Builder
    hppa 0
    The Cheese Builder
