= Buildd Dispatching =

  >>> import transaction
  >>> import logging
  >>> logger = logging.getLogger()
  >>> logger.setLevel(logging.DEBUG)

The buildd dispatching basically consists of finding a available
Buildd-slave in IDLE state, push required files to it, then request
the it to start a build procedure.

Those tasks are implemented by the BuilddMaster and BuilderGroup
classes.

  >>> from canonical.buildmaster.master import BuilddMaster
  >>> bm = BuilddMaster(logger, transaction)

Setup the test builder:

  >>> from canonical.buildd.ftests import BuilddSlaveTestSetup
  >>> BuilddSlaveTestSetup().setUp()

Setup a suitable chroot for Hoary i386:

  >>> from canonical.librarian.interfaces import ILibrarianClient
  >>> from StringIO import StringIO
  >>> librarian_client = getUtility(ILibrarianClient)

  >>> content = 'anything'
  >>> alias_id = librarian_client.addFile(
  ...    'foo.tar.gz', len(content), StringIO(content), 'text/plain')

  >>> from canonical.launchpad.interfaces import (
  ...     IDistributionSet, ILibraryFileAliasSet)
  >>> from canonical.launchpad.interfaces import PackagePublishingPocket

  >>> hoary = getUtility(IDistributionSet)['ubuntu']['hoary']
  >>> hoary_i386 = hoary['i386']

  >>> chroot = getUtility(ILibraryFileAliasSet)[alias_id]
  >>> pc = hoary_i386.addOrUpdateChroot(chroot=chroot)

Activate builders present in sampledata, we need to be logged in as a
member of launchpad-buildd-admin:

  >>> from canonical.launchpad.ftests import login
  >>> login('celso.providelo@canonical.com')

Set IBuilder.builderok of all present builders:

  >>> from canonical.launchpad.interfaces import IBuilderSet
  >>> builder_set = getUtility(IBuilderSet)

  >>> builder_set.count()
  2

  >>> from canonical.launchpad.ftests import syncUpdate
  >>> for b in builder_set:
  ...     b.builderok = True
  ...     syncUpdate(b)

Clean up previous BuildQueue results from sampledata:

  >>> from canonical.launchpad.interfaces import IBuildQueueSet
  >>> lost_job = getUtility(IBuildQueueSet).get(1)
  >>> lost_job.builder.name
  u'bob'
  >>> lost_job.destroySelf()

Setup BuilddMaster class:

  >>> bm.addDistroArchSeries(hoary_i386)
  >>> bm.setupBuilders(hoary_i386)
  WARNING:root.builders.x86:frog (http://localhost:9221/) marked as failed due to: (111, 'Connection refused')
  Traceback (most recent call last):
  ...
  error: (111, 'Connection refused')

Check if there are builders available:

  >>> bob_builder = builder_set['bob']
  >>> bob_builder.name
  u'bob'
  >>> bob_builder.trusted
  True
  >>> bob_builder.is_available
  True

Verify how the nonexistent builder was excluded, marked as failed:

  >>> frog_builder = builder_set['frog']
  >>> frog_builder.builderok
  False
  >>> print frog_builder.failnotes
  (111, 'Connection refused')
  >>> frog_builder.is_available
  False


== Builder dispatching API ==

Now let's check the build candidates which will be considered for the
builder 'bob':

  >>> job = bob_builder.findBuildCandidate()

The single BuildQueue found is a trusted pending build:

  >>> job.id
  2
  >>> job.build.buildstate.name
  'NEEDSBUILD'
  >>> job.builder is None
  True
  >>> job.buildstart is None
  True
  >>> job.is_trusted
  True

Update the SourcePackageReleaseFile corresponding to this job:

  >>> content = 'anything'
  >>> alias_id = librarian_client.addFile(
  ...    'foo.dsc', len(content), StringIO(content), 'application/dsc')

  >>> sprf = job.build.sourcepackagerelease.files[0]
  >>> from zope.security.proxy import removeSecurityProxy
  >>> naked_sprf = removeSecurityProxy(sprf)
  >>> naked_sprf.libraryfile = getUtility(ILibraryFileAliasSet)[alias_id]
  >>> flush_database_updates()

Check the dispatching method itself:

  >>> bob_builder.dispatchBuildCandidate(job)
  >>> flush_database_updates()

Verify if the job (BuildQueue) was updated appropriately:

  >>> job.builder.id == bob_builder.id
  True
  >>> job.build.buildstate.name
  'BUILDING'
  >>> job.buildstart
  CURRENT_TIMESTAMP AT TIME ZONE 'UTC'

Shutdown builder, mark the build record as failed and remove the
buildqueue record, so the build was eliminated:

  >>> BuilddSlaveTestSetup().tearDown()

  >>> from canonical.launchpad.interfaces import BuildStatus
  >>> job.build.buildstate = BuildStatus.FAILEDTOBUILD
  >>> job.destroySelf()
  >>> flush_database_updates()


== PPA build dispatching ==

Create new Build record of the same source targeted for a PPA archive:

  >>> from canonical.launchpad.interfaces import IPersonSet
  >>> cprov = getUtility(IPersonSet).getByName('cprov')

  >>> ppa_build = sprf.sourcepackagerelease.createBuild(
  ...     hoary_i386, PackagePublishingPocket.RELEASE, cprov.archive)

Create BuildQueue record and inspect some parameters:

  >>> ppa_job = ppa_build.createBuildQueueEntry()
  >>> ppa_job.id
  3L
  >>> ppa_job.builder == None
  True
  >>> ppa_job.buildstart == None
  True
  >>> ppa_job.is_trusted
  False

In order to enable 'bob' to find and build the PPA job, we have to
change it to 'untrusted' mode.

  >>> bob_builder.trusted = False
  >>> flush_database_updates()

  >>> job = bob_builder.findBuildCandidate()
  >>> ppa_job.id == job.id
  True

Start buildd-slave to be able to dispatch jobs.

  >>> BuilddSlaveTestSetup().setUp()

Before dispatching we can check if the builder is protected against
mistakes in code that results in a attempt to build a untrusted job in
a trusted build.

  >>> bob_builder.trusted = True
  >>> flush_database_updates()
  >>> bob_builder.dispatchBuildCandidate(ppa_job)
  Traceback (most recent call last):
  ...
  AssertionError: Attempt to build untrusted item on a trusted-only builder.

Mark the builder as untrusted again, so we can dispatch the ppa job
successfully.

  >>> bob_builder.trusted = False
  >>> flush_database_updates()

  >>> bob_builder.dispatchBuildCandidate(ppa_job)
  >>> flush_database_updates()

PPA job is building.

  >>> ppa_job.builder.name
  u'bob'
  >>> ppa_job.build.buildstate.name
  'BUILDING'
  >>> ppa_job.buildstart
  CURRENT_TIMESTAMP AT TIME ZONE 'UTC'

Shutdown builder slave, mark the ppa build record as failed, remove the
buildqueue record and make 'bob' builder trusted again,  so the
environment is back to the initial state.

  >>> BuilddSlaveTestSetup().tearDown()

  >>> ppa_job.build.buildstate = BuildStatus.FAILEDTOBUILD
  >>> ppa_job.destroySelf()
  >>> bob_builder.trusted = True
  >>> flush_database_updates()


== Security build dispatching ==

Create a new Build record for test source targeted to SECURITY pocket:

  >>> sec_build = sprf.sourcepackagerelease.createBuild(
  ...     hoary_i386, PackagePublishingPocket.SECURITY, hoary.main_archive)

Create BuildQueue record and inspect some parameters:

  >>> sec_job = sec_build.createBuildQueueEntry()
  >>> sec_job.id
  4L
  >>> sec_job.builder == None
  True
  >>> sec_job.buildstart == None
  True
  >>> sec_job.is_trusted
  True

In normal conditions the next available candidate would be the job
targeted to SECURITY pocket. However, the builders are forbidden to
accept such jobs until we have finished the EMBARGOED archive
implementation.

  >>> BuilddSlaveTestSetup().setUp()
  >>> bob_builder.dispatchBuildCandidate(sec_job)
  Traceback (most recent call last):
  ...
  AssertionError: Soyuz is not yet capable of building SECURITY uploads.
  >>> BuilddSlaveTestSetup().tearDown()

To solve this problem, temporarily, until we start building security
uploads, we will mark build targeted to SECURITY pocket as SUPERSEDED
during the findBuildCandidate look-up.

  >>> bob_builder.findBuildCandidate() is None
  True
  >>> flush_database_updates()

As expected, the security job was marked as SUPERSEDED and the
corresponding BuildQueue record was removed.

  >>> sec_build.buildstate.name
  'SUPERSEDED'
  >>> sec_build.buildqueue_record is None
  True

This way the security builds, created due to missing binary uploads
from dak, will be silently consumed until we can build them
appropriately.
