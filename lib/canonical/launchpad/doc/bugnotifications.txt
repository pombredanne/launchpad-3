
= Bug notifications =


== What is a bug notification? ==

A bug notification gets added when something interesting happens to the
bug. It's stored in a a table, and later on a cronscript constructs an
email and sends the notification to the bug's subscribers.


== When do bug notifications get added? ==

Not *every* change on a bug causes a notification to be added. This
section will give a rundown of the things that do cause notifications to
be sent. To start with, let's login:

    >>> login("test@canonical.com")

Here are the things that cause bug notifications to be add, and what
those notifications look like.


=== Reporting a new bug ===

    >>> from zope.event import notify
    >>> from zope.publisher.browser import TestRequest
    >>> from canonical.launchpad.event.sqlobjectevent import (
    ...     SQLObjectModifiedEvent, SQLObjectCreatedEvent)
    >>> from canonical.launchpad.interfaces import (
    ...     IProductSet, IPersonSet, IDistributionSet, IDistroSeriesSet,
    ...     ISourcePackageNameSet, IBugSet, CreateBugParams)

    >>> bug_submitter = getUtility(IPersonSet).get(12)
    >>> firefox = getUtility(IProductSet).get(4)

    >>> params = CreateBugParams(
    ...     title="firefox crashes all the time",
    ...     comment="this is a comment", owner=bug_submitter)
    >>> firefox_crashes = firefox.createBug(params)
    >>> notify(SQLObjectCreatedEvent(firefox_crashes))

    >>> from canonical.launchpad.database import BugNotification
    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    True
    >>> print latest_notification.message.text_contents
    this is a comment


=== Editing a bug report ===

    >>> from zope.interface import implements
    >>> from canonical.launchpad.interfaces import IBug

    >>> class MockObject(object):
    ...     implements(IBug)

    >>> bug_before_modification = MockObject()
    >>> for name in IBug.names(all=True):
    ...     setattr(bug_before_modification, name,
    ...             getattr(firefox_crashes, name))
    >>> firefox_crashes.description = "a new description"
    >>> firefox_crashes_modified = SQLObjectModifiedEvent(
    ...     firefox_crashes, bug_before_modification,
    ...     ["description"])
    >>> notify(firefox_crashes_modified)

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Description changed:
    ...


=== Filing a new task on an existing bug ===

There are three kinds of tasks that can be added to an existing
bug. Let's take a look at each type.


    ==== Distro Task ====

    A task that says this bug must be fixed in a certain distro. Because no
    specific series is specified, the developer will assume that the fix
    belongs in the current development series. For backporting a fix to a
    specific distro series, see 3.2.

    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> debian = getUtility(IDistributionSet).get(3)
    >>> firefox_source = getUtility(ISourcePackageNameSet).get(1)
    >>> firefox_crashes_in_debian = getUtility(IBugTaskSet).createTask(
    ...     bug=firefox_crashes, distribution=debian,
    ...     sourcepackagename=firefox_source,
    ...     owner=bug_submitter)
    >>> notify(SQLObjectCreatedEvent(firefox_crashes_in_debian))

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Also affects: mozilla-firefox (Debian)
    ...


    ==== Distro Series Task ====

    Similar to a distro task, except that a task filed on a specific
    distro series is meant to be used for backport fixes (critical data
    loss or security bugs), or tasks targeted to current and future
    series. Tasks filed on specific distro seriess are not listed in
    the more generic, distro-wide bug task listings.

    >>> sid = getUtility(IDistroSeriesSet).get(8)
    >>> firefox_crashes_in_sid = getUtility(IBugTaskSet).createTask(
    ...     bug=firefox_crashes, distroseries=sid,
    ...     sourcepackagename=firefox_source, owner=bug_submitter)
    >>> notify(SQLObjectCreatedEvent(firefox_crashes_in_sid))

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Also affects: mozilla-firefox (Debian Sid)
    ...


    ==== Upstream Task ====

    An upstream tasks notes that a bug needs to be fixed upstream. "Upstream"
    is a somewhat ambiguous term -- it can have different meanings in the eyes
    of an Ubuntu maintainer vs. a maintainer of a package from an Ubuntu
    derivative. At the moment, "upstream" means "the distro-agnostic place from
    which we procured a source tarball to create a source package for a distro."
    The common case will be that bugs filed in distros bubble up to upstream,
    and are fixed there then bubble back down (via patches) to the various
    distros via patches.

    >>> evolution = getUtility(IProductSet).get(5)
    >>> evolution_crashes_too = getUtility(IBugTaskSet).createTask(
    ...     bug=firefox_crashes, product=evolution, owner=bug_submitter)
    >>> notify(SQLObjectCreatedEvent(evolution_crashes_too))

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Also affects: evolution
    ...


    ==== ProductSeries Task ====

    Similar to an upstream task, except that a task filed on a specific
    product series is meant to target a bug to a specific series.

    >>> trunk = evolution.getSeries('trunk')
    >>> firefox_crashes_in_trunk = getUtility(IBugTaskSet).createTask(
    ...     bug=firefox_crashes, productseries=trunk, owner=bug_submitter)
    >>> notify(SQLObjectCreatedEvent(firefox_crashes_in_trunk))

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Also affects: evolution/trunk
    ...


=== Commenting on a bug report ===

    >>> from canonical.launchpad.interfaces import IBugMessageSet

    >>> bugmessageset = getUtility(IBugMessageSet)
    >>> current_user = getUtility(ILaunchBag).user
    >>> comment_on_firefox_crashes_in_debian = bugmessageset.createMessage(
    ...     subject="some title", content="just a test comment",
    ...     bug=firefox_crashes, owner=current_user)
    >>> notify(SQLObjectCreatedEvent(comment_on_firefox_crashes_in_debian))

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    True
    >>> print latest_notification.message.text_contents
    just a test comment


=== Editing a task ===

Let's demonstrate a notification email where Sample Person marks a
task Fixed, and assigns himself to it.

    >>> from canonical.launchpad.interfaces import (
    ...     BugTaskStatus, IDistroBugTask)
    >>> from canonical.launchpad.webapp.snapshot import Snapshot

    >>> bugtask_before_modification = Snapshot(
    ...     firefox_crashes_in_debian, providing=IDistroBugTask)
    >>> firefox_crashes_in_debian.transitionToStatus(
    ...     BugTaskStatus.FIXRELEASED, getUtility(ILaunchBag).user)
    >>> firefox_crashes_in_debian.transitionToAssignee(bug_submitter)
    >>> debian_task_modified = SQLObjectModifiedEvent(
    ...     firefox_crashes_in_debian, bugtask_before_modification,
    ...     ["status", "assignee"])
    >>> notify(debian_task_modified)

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Changed in: mozilla-firefox (Debian)
    ...

    >>> from canonical.launchpad.interfaces import IProductSeriesBugTask
    >>> bugtask_before_modification = Snapshot(
    ...     firefox_crashes_in_trunk, providing=IProductSeriesBugTask)
    >>> firefox_crashes_in_trunk.transitionToStatus(
    ...     BugTaskStatus.FIXRELEASED, getUtility(ILaunchBag).user)
    >>> firefox_crashes_in_trunk.transitionToAssignee(bug_submitter)
    >>> firefox_task_modified = SQLObjectModifiedEvent(
    ...     firefox_crashes_in_trunk, bugtask_before_modification,
    ...     ["status", "assignee"])
    >>> notify(firefox_task_modified)

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Changed in: evolution/trunk
    ...


=== Adding and editing a bug watch ===

A bug watch can be added to a bug to watch the status of this bug in a
remote bug tracker. A notification is sent out to the bug notification
recipients when a bug watch is added to a bug. Let's demonstrate by
pretending we've just added a watch to a bug.

    >>> from canonical.launchpad.interfaces import IBugWatchSet
    >>> bugwatch = getUtility(IBugWatchSet).get(2)
    >>> bugwatch_added = SQLObjectCreatedEvent(bugwatch)
    >>> notify(bugwatch_added)

    >>> add_notification = BugNotification.select(orderBy='id')[-1]
    >>> print add_notification.message.owner.displayname
    Sample Person
    >>> add_notification.is_comment
    False
    >>> print add_notification.message.text_contents
    ** Bug watch added: The Mozilla.org Bug Tracker #2000
    https://bugzilla.mozilla.org/show_bug.cgi?id=2000

If the bug watch is modified, a notification is sent out describing
the changes made:

    >>> bugwatch_before_modification = MockObject()
    >>> bugwatch_before_modification.bugtracker = bugwatch.bugtracker
    >>> bugwatch_before_modification.remotebug = bugwatch.remotebug
    >>> bugwatch_before_modification.url = bugwatch.url
    >>> bugwatch.remotebug = "2001"
    >>> bugwatch_modified = SQLObjectModifiedEvent(
    ...     object = bugwatch,
    ...     object_before_modification = bugwatch_before_modification,
    ...     edited_fields = ["remotebug"])

    >>> notify(bugwatch_modified)

    >>> latest_notifications = BugNotification.select(orderBy='id')
    >>> add_notification = latest_notifications[-1]
    >>> remove_notification = latest_notifications[-2]
    >>> print add_notification.message.owner.displayname
    Sample Person
    >>> print remove_notification.message.owner.displayname
    Sample Person

    >>> add_notification.is_comment
    False
    >>> remove_notification.is_comment
    False
    >>> print add_notification.message.text_contents
    ** Bug watch added: The Mozilla.org Bug Tracker #2001
    https://bugzilla.mozilla.org/show_bug.cgi?id=2001
    >>> print remove_notification.message.text_contents
    ** Bug watch removed: The Mozilla.org Bug Tracker #2000
    https://bugzilla.mozilla.org/show_bug.cgi?id=2000


=== Adding and editing a CVE reference ===

Adding a CVE reference to a bug also causes a notification email to go
out to the bug notification recipient list. Let's create a CVE ref and
attach it to the firefox_crashes bug that we've been using throughout
this document:

    >>> from canonical.launchpad.interfaces import CveStatus, ICveSet
    >>> cve = getUtility(ICveSet).new(sequence="2004-0276",
    ...     description="a brief CVE description", status=CveStatus.ENTRY)
    >>> from canonical.launchpad.database import Bug
    >>> bug = Bug.get(1)
    >>> bugcve = cve.linkBug(bug) # note this creates the event and notifies

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** CVE added: http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2004-0276


=== Marking a bug as a duplicate ===

When a bug is marked as a duplicate, its subscribers are notified.

    >>> from canonical.launchpad.webapp.snapshot import Snapshot
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bug_two = getUtility(IBugSet).get(2)
    >>> bug_two_unmodified = Snapshot(bug_two, providing=IBug)
    >>> bug_two.duplicateof = bug_one
    >>> marked_duplicate = SQLObjectModifiedEvent(
    ...     bug_two, bug_two_unmodified, edited_fields=['duplicateof'])
    >>> notify(marked_duplicate)

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> latest_notification.bug.id
    2
    >>> print latest_notification.message.text_contents
    ** This bug has been marked a duplicate of bug 1
       Firefox does not support SVG

Let's change the target of a bug that's already marked as a dupe to show
that the correct notification message is sent.

    >>> bug_six = getUtility(IBugSet).get(6)
    >>> bug_three = getUtility(IBugSet).get(3)
    >>> bug_six_unmodified = Snapshot(bug_six, providing=IBug)
    >>> bug_six.duplicateof = bug_three
    >>> marked_duplicate = SQLObjectModifiedEvent(
    ...     bug_six, bug_six_unmodified, edited_fields=['duplicateof'])
    >>> notify(marked_duplicate)

    >>> latest_notifications = BugNotification.select(orderBy='id')
    >>> dupe_notification = latest_notifications[-1]
    >>> no_dupe_notification = latest_notifications[-2]
    >>> print no_dupe_notification.message.owner.displayname
    Sample Person
    >>> print dupe_notification.message.owner.displayname
    Sample Person

    >>> no_dupe_notification.is_comment
    False
    >>> dupe_notification.is_comment
    False
    >>> no_dupe_notification.bug.id
    6
    >>> dupe_notification.bug.id
    6
    >>> print no_dupe_notification.message.text_contents
    ** This bug is no longer a duplicate of bug 5
       Firefox install instructions should be complete

    >>> print dupe_notification.message.text_contents
    ** This bug has been marked a duplicate of bug 3
       Bug Title Test

Let's unduplicate the above bug and check if the correct notification
message is sent.

    >>> bug_six = getUtility(IBugSet).get(6)
    >>> bug_six_unmodified = Snapshot(bug_six, providing=IBug)
    >>> bug_six.duplicateof = None
    >>> marked_duplicate = SQLObjectModifiedEvent(
    ...     bug_six, bug_six_unmodified, edited_fields=['duplicateof'])
    >>> notify(marked_duplicate)

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> latest_notification.bug.id
    6
    >>> print latest_notification.message.text_contents
    ** This bug is no longer a duplicate of bug 3
       Bug Title Test


=== Expiring notifications ===

During bulk imports or changes of bugs, we often want to suppress
email notifications.  Due to the previous operation, there are pending
bug notifications for bug six:

    >>> notifications = BugNotification.selectBy(bugID=6, date_emailed=None)
    >>> notifications.count()
    3

These notifications can be expired using the expireNotifications()
method:

    >>> bug_six.expireNotifications()
    >>> notifications = BugNotification.selectBy(bugID=6, date_emailed=None)
    >>> notifications.count()
    0
