= Batch Navigation =

Batch navigation provides a way to navigate batch results in a web
page by providing URL links to the next, previous and numbered pages
of results.

It uses two arguments to control the batching:

  - start: The first item we should show in current batch.
  - batch: Controls the amount of items we are showing per batch. It will only
           appear if it's different from the default value set when the batch
           is created.

Imports:

  >>> from canonical.launchpad.webapp.batching import BatchNavigator
  >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

  >>> def build_request(arg=None):
  ...   if arg is None:
  ...       arg = {}
  ...   else:
  ...       query = "&".join(["%s=%s" % (k,v) for k,v in arg.items()])
  ...       arg["QUERY_STRING"] = query
  ...   request = LaunchpadTestRequest(SERVER_URL='http://www.example.com/foo',
  ...                                  environ=arg)
  ...   return request

A dummy request object:

Some sample data.

  >>> reindeer = ['Dasher', 'Dancer', 'Prancer', 'Vixen', 'Comet',
  ...     'Cupid', 'Donner', 'Blitzen', 'Rudolph']

You can create a batch and a batch navigator like so:

  >>> reindeer_batch_navigator = BatchNavigator(
  ...     reindeer, build_request(), size=3)

You can ask the navigator for the chunk of results currently being shown (e.g.
to iterate over them for rendering in ZPT):

  >>> list(reindeer_batch_navigator.currentBatch())
  ['Dasher', 'Dancer', 'Prancer']

You can ask for the first, previous, next and last results' links:

  >>> reindeer_batch_navigator.firstBatchURL()
  ''
  >>> reindeer_batch_navigator.prevBatchURL()
  ''
  >>> reindeer_batch_navigator.nextBatchURL()
  'http://www.example.com/foo?start=3'
  >>> reindeer_batch_navigator.lastBatchURL()
  'http://www.example.com/foo?start=6'

The next link will be empty when there are no further results:

  >>> request = build_request({"start": "3", "batch": "20"})
  >>> last_reindeer_batch_navigator = BatchNavigator(reindeer, request=request)
  >>> last_reindeer_batch_navigator.nextBatchURL()
  ''

The first and previous link should appear even when we start at a point between 0
and the batch size:

  >>> request = build_request({"start": "2", "batch": "3"})
  >>> last_reindeer_batch_navigator = BatchNavigator(reindeer, request=request)

Here, we can see too that the batch argument appears as part of the URL.
That's because the request asked for a different size than the default
one when we create the Batch object, by default, it's 5.

  >>> last_reindeer_batch_navigator.firstBatchURL()
  'http://www.example.com/foo?start=0&batch=3'

  >>> last_reindeer_batch_navigator.prevBatchURL()
  'http://www.example.com/foo?start=0&batch=3'

This all works with query strings in the URLs, too:

  >>> request = build_request({'fnorb': 'bar',
  ...                          'start': '3',
  ...                          'batch': '3'})
  >>> reindeer_batch_navigator_with_qs = BatchNavigator(
  ...     reindeer, request, size=3)

In this case, we created the BatchNavigator with a default size of '3' and
the request is asking exactly that number of items per batch, and thus, we
don't need to show 'batch' as part of the URL.

  >>> reindeer_batch_navigator_with_qs.firstBatchURL()
  'http://www.example.com/foo?fnorb=bar&start=0'
  >>> reindeer_batch_navigator_with_qs.prevBatchURL()
  'http://www.example.com/foo?fnorb=bar&start=0'
  >>> reindeer_batch_navigator_with_qs.nextBatchURL()
  'http://www.example.com/foo?fnorb=bar&start=6'
  >>> reindeer_batch_navigator_with_qs.lastBatchURL()
  'http://www.example.com/foo?fnorb=bar&start=6'

You can ask for the links for each of the result pages:

  >>> links = reindeer_batch_navigator.batchPageURLs()
  >>> for link in links:
  ...     label, url = link.items()[0]
  ...     print label, url
  [1] http://www.example.com/foo?start=0
  2 http://www.example.com/foo?start=3
  3 http://www.example.com/foo?start=6
  _last_ http://www.example.com/foo?start=6

We ensure that multiple size and batch arguments supplied in the URL
(which get turned into lists by Zope) don't blow up the application:

  >>> request = build_request({'batch': [u"1", u"3"], 'start': [u'2', u'3']})
  >>> navigator = BatchNavigator(reindeer, request=request)
  >>> navigator.nextBatchURL()
  'http://www.example.com/foo?start=5&batch=5'

== Empty Batches ==

You can also create an empty batch that will not have any items:

  >>> null_batch_navigator = BatchNavigator(
  ...     None, build_request(), size=3)
  >>> null_batch_navigator.firstBatchURL()
  ''
  >>> null_batch_navigator.nextBatchURL()
  ''
  >>> null_batch_navigator.prevBatchURL()
  ''
  >>> null_batch_navigator.lastBatchURL()
  ''

  >>> null_batch_navigator = BatchNavigator(
  ...     [], build_request(), size=3)
  >>> null_batch_navigator.firstBatchURL()
  ''
  >>> null_batch_navigator.nextBatchURL()
  ''
  >>> null_batch_navigator.prevBatchURL()
  ''
  >>> null_batch_navigator.lastBatchURL()
  ''

TODO:

  - blowing up when start is beyond end
  - orphans
  - overlap


== Performance with SQLObject ==

This section demonstrates that batching generates sensible SQL queries when used
with SQLObject, i.e. that it puts appropriate LIMIT clauses on queries.

Imports:

  >>> from canonical.launchpad.database import EmailAddress
  >>> from canonical.ftests.pgsql import CursorWrapper
  >>> CursorWrapper.record_sql = True

Prepare a query, and create a batch of the results:

  >>> select_results = EmailAddress.select(orderBy='id')
  >>> batch_nav = BatchNavigator(select_results, build_request(),
  ...                            size=10)
  >>> email_batch = batch_nav.currentBatch()
  >>> batch_items = list(email_batch)

Because we're only looking at the first batch, the database is only asked for
the number of rows, and the first 10 rows:

  >>> len(CursorWrapper.last_executed_sql)
  2
  >>> print CursorWrapper.last_executed_sql[1]
  SELECT ... FROM EmailAddress ... LIMIT 10...
  >>> print CursorWrapper.last_executed_sql[0]
  SELECT COUNT(*) FROM EmailAddress

Get the next 10.  The database is only asked for the next 10 rows -- no further
COUNTs are issued:

  >>> CursorWrapper.last_executed_sql = []
  >>> email_batch2 = email_batch.nextBatch()
  >>> batch_items = list(email_batch2)
  >>> len(CursorWrapper.last_executed_sql)
  1
  >>> CursorWrapper.last_executed_sql[0].endswith('LIMIT 10 OFFSET 10')
  True


== Adding callback functions ==

Sometimes it is useful to have a function called with the batched
values once they have been determined.  This is the case when there
are subsequent queries that are needed to be executed for each batch,
and it is undesirable or overly expensive to execute the query for
every value in the entire result set.

The callback function must define two parameters.  The first is the 
batch navigator object itself, and the second it the current batch.
The callback function is called once and only once when the
BatchNavigator is constructed, and the current batch is determined.

  >>> def print_callback(context, batch):
  ...     for item in batch:
  ...         print item

  >>> reindeer_batch_navigator = BatchNavigator(
  ...     reindeer, build_request(), size=3, callback=print_callback)
  Dasher
  Dancer
  Prancer

  >>> request = build_request({"start": "3", "batch": "20"})
  >>> last_reindeer_batch_navigator = BatchNavigator(
  ...     reindeer, request=request, callback=print_callback)
  Vixen
  Comet
  Cupid
  Donner
  Blitzen
  Rudolph

Most likely, the callback function will be bound to a view class.
By providing the batch navigator itself as the context for the
callback allows the addition of extra member variables.  This is
useful as the BatchNavigator becomes the context in page templates
that are batched.

  >>> class ReindeerView:
  ...     def constructReindeerFromAtoms(self, context, batch):
  ...         # some significantly slow process
  ...         view.built_reindeer = list(batch)
  ...     def batchedReindeer(self):
  ...         return BatchNavigator(
  ...            reindeer, build_request(), size=3,
  ...            callback=self.constructReindeerFromAtoms)

  >>> view = ReindeerView()
  >>> batch_navigator = view.batchedReindeer()
  >>> print view.built_reindeer
  ['Dasher', 'Dancer', 'Prancer']
  >>> print list(batch_navigator.currentBatch())
  ['Dasher', 'Dancer', 'Prancer']


== Maximum batch size ==

Since the batch size is exposed in the URL, it's possible for users to
tweak the batch parameter to retrieve more results. Since that may
potentially exhaust server resources, an upper limit is put on the batch
size. If the requested batch parameter is higher than this, an
InvalidBatchSizeError is raised.

    >>> from canonical.config import config
    >>> from textwrap import dedent
    >>> config.push('max-batch-size', dedent("""\
    ...     [launchpad]
    ...     max_batch_size: 5
    ...     """))
    >>> request = build_request({"start": "0", "batch": "20"})
    >>> BatchNavigator(reindeer, request=request )
    Traceback (most recent call last):
      ...
    InvalidBatchSizeError: Maximum for "batch" parameter is 5.

    >>> ignored = config.pop('max-batch-size')

