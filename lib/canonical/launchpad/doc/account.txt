= Account and AccountSet =

An Account is used by someone to Authenticate with the Launchpad login
service.

Many operations on Account and related tables are available only to
the SSO Server.

    >>> from canonical.launchpad.webapp.interfaces import IStoreSelector
    >>> from canonical.launchpad.webapp.dbpolicy import SSODatabasePolicy
    >>> getUtility(IStoreSelector).push(SSODatabasePolicy())


= AccountSet =

The AccountSet object provides methods to retrieve `IAccount`s. It
implements the IAccountSet.

    >>> from zope.interface.verify import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     IAccount, IAccountSet, IPerson)

    >>> account_set = getUtility(IAccountSet)
    >>> verifyObject(IAccountSet, account_set)
    True


== Looking up accounts by email address ==

Accounts are generally looked up by email address.

    >>> login('no-priv@canonical.com')
    >>> account = account_set.getByEmail('no-priv@canonical.com')
    >>> IAccount.providedBy(account)
    True

    >>> print account_set.getByEmail('invalid@whatever')
    None

Only admins or the person attached to an account can see or edit Account
details. This is obviously wrong, as the account should have access
rather than the (optional) attached person. In particular, it means
Accounts without Person records cannot be managed by the Account owner.
Fixing this involves more surgery to Launchpad's security systems.

    >>> stub_account = account_set.getByEmail('stuart.bishop@canonical.com')
    >>> stub_account.date_created
    Traceback (most recent call last):
    ...
    Unauthorized...

    >>> del stub_account


== Looking up accounts by OpenID identifier ==

Each Launchpad user is assigned an permanent OpenID identity URL. The
last component of this URL is specific to the user, and can be used to
look up the user.

    >>> account = account_set.getByOpenIDIdentifier('no-priv_oid')
    >>> IAccount.providedBy(account)
    True
    >>> print account.displayname
    No Privileges Person

The getByOpenIDIdentifier() method supports the human readable
openid identifiers.

    >>> account.new_openid_identifier
    u'123/no-priv'
    >>> account_2 = account_set.getByOpenIDIdentifier('123/no-priv')
    >>> account_2 == account
    True

None is returned if the identifier is not used by any account.

    >>> print account_set.getByOpenIDIdentifier('no-such-identifier')
    None


= The Account object =

The account implements the IAccount interface.

    >>> verifyObject(IAccount, account)
    True

An account has a displayname, and a preferred email address.

    >>> print account.displayname
    No Privileges Person
    >>> print account.preferredemail.email
    no-priv@canonical.com

It also has an encrypted password.

    >>> account.password
    u'K7Qmeansl6RbuPfulfcmyDQOzp70OxVh5Fcf'

Ensure the password changes are sticky, as this is a property hiding the
AccountPassword table.

    >>> account.password = None
    >>> print account.password
    None

    >>> account.password = u'K7Qmeansl6RbuPfulfcmyDQOzp70OxVh5Fcf'
    >>> account.password
    u'K7Qmeansl6RbuPfulfcmyDQOzp70OxVh5Fcf'

And other account metadata.

    >>> account.date_created
    datetime.datetime(...)

    >>> print account.creation_rationale.name
    OWNER_CREATED_LAUNCHPAD

    >>> print account.status.name
    ACTIVE

    >>> account.date_status_set >= account.date_created
    True

    >>> print account.status_comment
    None

    >>> account.displayname
    u'No Privileges Person'

When the status is changed, the date_status_set is updated in the
database.

    >>> from canonical.launchpad.interfaces.account import AccountStatus

    >>> original_date_status_set = account.date_status_set
    >>> account.status = AccountStatus.SUSPENDED

    # Shouldn't be necessary with Storm!
    >>> from zope.security.proxy import removeSecurityProxy
    >>> removeSecurityProxy(account).sync()
    >>> account.date_status_set > original_date_status_set
    True

    >>> account.status = AccountStatus.ACTIVE

The Account's displayname is synced to the Person's displayname if there
is one. If the Person.displayname is changed, the Account.displayname is
changed too.

    >>> from canonical.launchpad.interfaces import IPersonSet

    >>> personset = getUtility(IPersonSet)
    >>> person = personset.getByEmail('no-priv@canonical.com')
    >>> person.displayname = 'Something New'
    >>> account.displayname
    u'Something New'

However, the reverse is not true. If we change the Account.displayname,
the linked Person.displayname (if there is one) is not updated
immediately.  Instead, a cron job will sync this information later. This
allows displayname changes to happen even when the Person table is
unavailable.

    >>> account.displayname = 'No Privileges Account'
    >>> person.displayname
    u'Something New'

    >>> person.displayname = 'No Privileges Person'
    >>> account.displayname
    u'No Privileges Person'

An Account has an OpenID identifier used to generate the OpenID identity
URL.

    >>> account.openid_identifier
    u'no-priv_oid'


= Creating new accounts =

New Accounts are created using the AccountSet.new() method. The account
rationale and displayname are required.

    >>> from canonical.launchpad.ftests import syncUpdate
    >>> from canonical.launchpad.interfaces.account import (
    ...     AccountCreationRationale)

    # Login as a user that may see the accounts of other users.
    >>> login('foo.bar@canonical.com')
    >>> passwordless_account = account_set.new(
    ...     AccountCreationRationale.USER_CREATED, 'Passwordless')
    >>> syncUpdate(passwordless_account)
    >>> passwordless_account.creation_rationale.name
    'USER_CREATED'
    >>> passwordless_account.displayname
    u'Passwordless'
    >>> print passwordless_account.password
    None
    >>> print passwordless_account.preferredemail
    None

The new() method accepts the optional parameters of password and
password_is_encrypted. If password_is_encrypted is False, the default,
then the method encrypts it for us.

    >>> passworded_account = account_set.new(
    ...     AccountCreationRationale.OWNER_CREATED_LAUNCHPAD , 'Passworded',
    ...     password=u'clear_password')
    >>> syncUpdate(passworded_account)
    >>> passworded_account.password == u'clear_password'
    False

The method does not encrypt the password if told that it is already
encrypted, by setting password_is_encrypted to True.

    >>> clear_account = account_set.new(
    ...     AccountCreationRationale.OWNER_CREATED_LAUNCHPAD , 'Clear',
    ...     password=u'clear_password', password_is_encrypted=True)
    >>> syncUpdate(clear_account)
    >>> clear_account.password
    u'clear_password'


== Valid Accounts ==

Like person objects, an account is considered valid if it is in the
active state and has a preferred email address.  So a newly created
account with no email address is not valid:

    >>> account = account_set.new(
    ...     AccountCreationRationale.USER_CREATED,
    ...     "Valid Account Test")
    >>> syncUpdate(account)
    >>> account.status = AccountStatus.ACTIVE
    >>> account.is_valid
    False

Lets add a new email address to the account:

    >>> from canonical.launchpad.interfaces import IEmailAddressSet
    >>> email = getUtility(IEmailAddressSet).new(
    ...     "valid-account-test@example.com", account=account)
    >>> account.is_valid
    False

The account is still not valid because it has no preferred email.
Setting the email to preferred fixes this:

    >>> from canonical.launchpad.interfaces import EmailAddressStatus
    >>> email.status = EmailAddressStatus.PREFERRED
    >>> account.is_valid
    True

If the account is deactivated, it won't be considered valid any more:

    >>> account.status = AccountStatus.DEACTIVATED
    >>> account.is_valid
    False


== Creating an IPerson for an Account ==

From a newly created account which has no person associated with, it is
possible to create a new person that will be associated with it.

We need to change database policy here again, as the SSO Server cannot
modify tables in the lpmain replication set.

    >>> from canonical.launchpad.webapp.dbpolicy import MasterDatabasePolicy
    >>> getUtility(IStoreSelector).push(MasterDatabasePolicy())

    >>> from lp.registry.interfaces.person import (
    ...     PersonCreationRationale)
    >>> fresh_account, email = account_set.createAccountAndEmail(
    ...     'foo@example.com',
    ...     AccountCreationRationale.OWNER_CREATED_UBUNTU_SHOP,
    ...     'Display name', 'password')
    >>> IPerson(fresh_account)
    Traceback (most recent call last):
      ...
    TypeError: ('Could not adapt', ...

    >>> person = fresh_account.createPerson(
    ...     PersonCreationRationale.OWNER_CREATED_LAUNCHPAD)
    >>> import transaction
    >>> transaction.commit()
    >>> person.account == fresh_account
    True
    >>> IPerson(fresh_account) == person
    True
    >>> person.preferredemail == fresh_account.preferredemail
    True
    >>> person.creation_rationale
    <DBItem PersonCreationRationale.OWNER_CREATED_LAUNCHPAD...

However, if the account has an associated person or has no preferred email
address, a new Person cannot be created.

    >>> person = fresh_account.createPerson(
    ...     PersonCreationRationale.OWNER_CREATED_LAUNCHPAD)
    Traceback (most recent call last):
    ...
    AssertionError: Can't create a Person for an account which already has
    one.

    >>> print clear_account.preferredemail
    None
    >>> person = clear_account.createPerson(
    ...     PersonCreationRationale.OWNER_CREATED_LAUNCHPAD)
    Traceback (most recent call last):
    ...
    AssertionError: Can't create a Person for an account which has no email.

    >>> db_policy = getUtility(IStoreSelector).pop()


== OpenID identifiers ==

The account is given old and new openid identifiers. The old
identifier is created directly in the database; it not available until
the account object is synced.

    >>> new_account = account_set.new(
    ...     AccountCreationRationale.OWNER_CREATED_LAUNCHPAD, 'OID Account',
    ...     openid_mnemonic='oid-account', password=u'clear_password')
    >>> syncUpdate(new_account)
    >>> len(new_account.openid_identifier) == 7
    True
    >>> new_account.new_openid_identifier
    u'.../oid-account'

The IAccountSet object can create a human-readable openid identifier
using the createOpenIDIdentifier() method. It requires a string argument
that is used as the mnemonic in the URL. A user name is a example of
a mnemonic that would be used to create a new openid identifier.

    >>> first_identifier = account_set.createOpenIDIdentifier('user-name')
    >>> first_identifier
    '.../user-name'

There is no distinction between using a string mnemonic and a unicode
mnemonic. A str is always returned.

    >>> account_set.createOpenIDIdentifier(u'user-name')
    '.../user-name'

The mnemonic must be a string or a unicode string, otherwise an error is
raised. The unicode string must contain only ASCII compatible
characters, otherwise an error is raised.

    >>> account_set.createOpenIDIdentifier(None)
    Traceback (most recent call last):
     ...
    AssertionError: The mnemonic must be a non-empty string.

    >>> account_set.createOpenIDIdentifier(u'b\xe4d')
    Traceback (most recent call last):
     ...
    UnicodeEncodeError: 'ascii' codec can't encode character u'\xe4' in
                         position 5: ordinal not in range(128)

An error is raised if a non-unique openid identifier cannot be created
for the mnemonic. All accounts and OpenID relying parties summaries are
checked for to ensure that an openid identifier is not reused. In the
unlikely chance that a unique random token cannot be found for a
mnemonic, an error is raised.

    # Instrument the random number range to ensure a duplicate will
    # be generated.
    >>> naked_account_set = removeSecurityProxy(account_set)
    >>> naked_account_set._MAX_RANDOM_TOKEN_RANGE
    1000
    >>> naked_account_set._MAX_RANDOM_TOKEN_RANGE = 1

    # Use the only random token available for the openid identifier.
    >>> non_unique_account = account_set.new(
    ...     AccountCreationRationale.OWNER_CREATED_LAUNCHPAD, 'Non Unique',
    ...     openid_mnemonic='non-unique', password=u'clear_password')
    >>> syncUpdate(non_unique_account)
    >>> non_unique_account.new_openid_identifier
    u'000/non-unique'

    >>> account_set.createOpenIDIdentifier('non-unique')
    Traceback (most recent call last):
     ...
    AssertionError: An openid_identifier could not be created with the
                    mnemonic 'non-unique'.

All OpenIDRPSummaries are checked to ensure the openid identifier has
never been used. An error is raised in the unlikely event that every
random token for a mnemonic has been used in the past.

    >>> from canonical.launchpad.database import OpenIDRPSummary

    # Change the new_openid_identifier to ensure that the no account
    # uses '000/non-unique'.
    >>> removeSecurityProxy(
    ...     non_unique_account).new_openid_identifier = '111/non-unique'
    >>> syncUpdate(non_unique_account)
    >>> print account_set.getByOpenIDIdentifier('000/non-unique')
    None

    # Add the openid identifier to the history of used openid identifiers.
    # The model object is used because the OpenIDRPSummarySet.record() may
    # use the old openid identifier.
    >>> summary = OpenIDRPSummary(
    ...     account=non_unique_account,
    ...     openid_identifier='http://id.launchpad.dev/000/non-unique',
    ...     trust_root='http://blog.org/')

    >>> import transaction
    >>> transaction.commit()
    >>> account_set.createOpenIDIdentifier('non-unique')
    Traceback (most recent call last):
     ...
    AssertionError: An openid_identifier could not be created with the
                    mnemonic 'non-unique'.

    # Restore random number range.
    >>> naked_account_set._MAX_RANDOM_TOKEN_RANGE = 1000

== OpenID authentications ==

Whenever a user authenticates to a relying party using our OpenID server, we
store that information, which can then later be shown to the account's owner
using IAccount.recently_authenticated_rps.  These are sorted descending by
date.

    >>> from canonical.launchpad.interfaces.openidserver import (
    ...     IOpenIDRPSummarySet)
    >>> from datetime import datetime
    >>> import pytz
    >>> two_thousand_and_seven = datetime(2007, 1, 1, tzinfo=pytz.UTC)
    >>> two_thousand_and_eight = datetime(2008, 1, 1, tzinfo=pytz.UTC)
    >>> summary = getUtility(IOpenIDRPSummarySet).record(
    ...     fresh_account, 'http://example.com/',
    ...     date_used=two_thousand_and_eight)
    >>> summary = getUtility(IOpenIDRPSummarySet).record(
    ...     fresh_account, 'http://blog.example.com/',
    ...     date_used=two_thousand_and_seven)
    >>> transaction.commit()

    >>> [summary.date_last_used.strftime('%Y-%m-%d')
    ...  for summary in fresh_account.recently_authenticated_rps]
    ['2008-01-01', '2007-01-01']


== Cleanup ==

    >>> db_policy = getUtility(IStoreSelector).pop()
