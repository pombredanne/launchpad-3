OpenPGP Import
==============

The importPublicKey method is exposed by IGPGHandler but it's only used
internally by the retrieveKey method.  Ideally, we shouldn't need to
check for all error conditions that we do, but we can't assume the
keyserver is a trusted data source, so we have to do that.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.webapp.testing import verifyObject 
   
    >>> from canonical.launchpad.interfaces import (
    ...      IGPGHandler, IPymeKey)
    >>> gpghandler = getUtility(IGPGHandler)

-------------------------------------------------------------------------
XXX: All these checks for error conditions should probably be moved to a
unit tests somewhere else at some point. -- Guilherme Salgado, 2006-08-23
-------------------------------------------------------------------------

A GPGKeyNotFoundError is raised if we try to import an empty content.

    >>> key = gpghandler.importPublicKey('')
    Traceback (most recent call last):
    ...
    GPGKeyNotFoundError...

The same happens for bogus content.

    >>> key = gpghandler.importPublicKey('XXXXXXXXX')
    Traceback (most recent call last):
    ...
    GPGKeyNotFoundError: ...

Let's recover some coherent data and verify if it works as expected:

    >>> import os
    >>> from canonical.launchpad.ftests.keys_for_tests import gpgkeysdir
    >>> filepath = os.path.join(gpgkeysdir, 'test@canonical.com.pub')
    >>> pubkey = open(filepath).read()
    >>> key = gpghandler.importPublicKey(pubkey)
    >>> verifyObject(IPymeKey, key)
    True
    >>> key.fingerprint
    'A419AE861E88BC9E04B9C26FBA2B9389DFD20543'

Now, try to import a secret key, which will cause a
SecretGPGKeyImportDetected exception to be raised.

    >>> filepath = os.path.join(gpgkeysdir, 'test@canonical.com.sec')
    >>> seckey = open(filepath).read()
    >>> key = gpghandler.importPublicKey(seckey)
    Traceback (most recent call last):
    ...
    SecretGPGKeyImportDetected: ...

Now, try to import two public keys, causing a MoreThanOneGPGKeyFound
exception to be raised.

    >>> filepath = os.path.join(gpgkeysdir, 'foo.bar@canonical.com.pub')
    >>> pubkey2 = open(filepath).read()
    >>> key = gpghandler.importPublicKey('\n'.join([pubkey, pubkey2]))
    Traceback (most recent call last):
    ...
    MoreThanOneGPGKeyFound: ...

Raise a GPGKeyNotFoundError if we try to import a public key with damaged
preamble.

    >>> key = gpghandler.importPublicKey(pubkey[1:])
    Traceback (most recent call last):
    ...
    GPGKeyNotFoundError: ...

Aparently GPGME is able to import an incomplete public key:

    >>> key = gpghandler.importPublicKey(pubkey[:-300])
    >>> assert key is not None
    >>> verifyObject(IPymeKey, key)
    True
    >>> key.fingerprint
    'A419AE861E88BC9E04B9C26FBA2B9389DFD20543'
 
But we get an error if the damage is big: 
(what probably happened in bug #2547)

    >>> key = gpghandler.importPublicKey(pubkey[:-400])
    Traceback (most recent call last):
    ...
    GPGKeyNotFoundError: ...


Keyserver URLs
==============

The gpghandler can also provide us with convenient links to the
keyserver web interface. By default the action is to display the index
page:

    >>> gpghandler.getURLForKeyInServer("DFD20543")
    'http://localhost:11371/pks/lookup?search=0xDFD20543&op=index'

But you can also specify your own action:

    >>> gpghandler.getURLForKeyInServer("DFD20543", action="get")
    'http://localhost:11371/pks/lookup?search=0xDFD20543&op=get'

The fingerprint can be both 8-byte, as above, or a longer string such as
the 40-byte fingerprint we captured above:

    >>> fingerprint = "A419AE861E88BC9E04B9C26FBA2B9389DFD20543"
    >>> gpghandler.getURLForKeyInServer(fingerprint)
    'http://localhost:11371/pks/lookup?search=0xDFD20543&op=index'

The method accepts a flag to retrieve a link to ubuntu's public
keyserver web interface.

    >>> gpghandler.getURLForKeyInServer("DFD20543", public=True)
    'http://keyserver.ubuntu.com:11371/pks/lookup?search=0xDFD20543&op=index'


Fingerprint sanitizing
======================

The GPG handler offers a convenience method to sanitize key
fingerprints:

    >>> print gpghandler.sanitizeFingerprint("XXXXX")
    None

    >>> fingerprint = 'C858 2652 1A6E F6A6 037B  B3F7 9FF2 583E 681B 6469'
    >>> print gpghandler.sanitizeFingerprint(fingerprint)
    C85826521A6EF6A6037BB3F79FF2583E681B6469

    >>> fingerprint = 'c858 2652 1a6e f6a6 037b  b3f7 9ff2 583e 681b 6469'
    >>> print gpghandler.sanitizeFingerprint(fingerprint)
    C85826521A6EF6A6037BB3F79FF2583E681B6469

    >>> print gpghandler.sanitizeFingerprint('681B 6469')
    None

    >>> print gpghandler.sanitizeFingerprint('abnckjdiue')
    None

    >>> non_ascii_chars = u'\xe9\xe1\xed'
    >>> fingerprint = ('c858 2652 1a6e f6a6 037b  b3f7 9ff2 583e 681b 6469 %s'
    ...                % non_ascii_chars)
    >>> print gpghandler.sanitizeFingerprint(fingerprint)
    C85826521A6EF6A6037BB3F79FF2583E681B6469

    >>> fingerprint = (
    ...     '%s c858 2652 1a6e f6a6 037b  b3f7 9ff2 583e 681b 6469 %s'
    ...     % (non_ascii_chars, non_ascii_chars))
    >>> print gpghandler.sanitizeFingerprint(fingerprint)
    None

