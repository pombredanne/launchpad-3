= TALES expressions =

There are several kinds of TALES expressions we've implemented in
Launchpad, to help make it easier to create page templates, without
the need to introduce complex Python code in the template itself.

First, let's bring in a small helper function:

   >>> from canonical.launchpad.ftests import test_tales


== The count: namespace to get numbers ==

count:len gives you a number which is len(thing).

   >>> test_tales('foo/count:len', foo=[])
   0
   >>> test_tales('foo/count:len', foo=[1, 2, 3])
   3
   >>> test_tales('foo/count:len', foo=object())
   Traceback (most recent call last):
   ...
   TypeError: len() of unsized object


== The fmt: namespace to get strings ==

To display the icon for a milestone, use image:icon:

   >>> from canonical.launchpad.database import MilestoneSet
   >>> milestone = MilestoneSet().get(1)
   >>> test_tales("milestone/image:icon", milestone=milestone)
   '<img ... src="/@@/milestone" />'

The same image:icon, as well as a image:logo and a image:logo is also
available for Person, Product, Project, Sprint and Distributions, since
they all implement IHasLogo,.IHasMugshot and IHasIcon.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> person = getUtility(IPersonSet).getByName('sabdfl')
    >>> test_tales("person/image:icon", person=person)
    '<img ... src="/@@/person" />'
    >>> test_tales("person/image:logo", person=person)
    '<img ... src="/@@/person-logo" />'

The Mugshot is presented in a div, floating right, with the mugshot inside
it:

    >>> test_tales("person/image:mugshot", person=person)
    '<div...<img...src="/@@/person-mugshot" />.../div>'

For people we even have different images in case the person in question is not
an actual launchpad user.

    >>> spiv = getUtility(IPersonSet).getByName('spiv')
    >>> spiv.is_valid_person
    False
    >>> test_tales("person/image:icon", person=spiv)
    '<img ... src="/@@/person-inactive" />'
    >>> test_tales("person/image:logo", person=spiv)
    '<img ... src="/@@/person-inactive-logo" />'
    >>> test_tales("person/image:mugshot", person=spiv)
    '...<img...src="/@@/person-inactive-mugshot" />...'

One other thing we have for people is fmt:link, which gives us a link to that
person's page, containing the person name and an icon.

    >>> test_tales("person/fmt:link", person=person)
    u'<a ...><img ... src="/@@/person" />&nbsp;Mark Shuttleworth</a>'

    >>> test_tales("person/fmt:link", person=spiv)
    u'<a ...><img ... src="/@@/person-inactive" />&nbsp;Andrew Bennetts</a>'

    >>> ubuntu_team = getUtility(IPersonSet).getByName('ubuntu-team')
    >>> test_tales("person/fmt:link", person=ubuntu_team)
    u'<a ...><img ... src="/@@/team" />&nbsp;Ubuntu Team</a>'

The fmt:link formatter uses additional path components to extend the
link:

    >>> test_tales("person/fmt:link/foo/bar", person=spiv)
    u'<a href=".../~spiv/foo/bar">...'

We also have image:icon for KarmaCategory:

    >>> from canonical.launchpad.database import KarmaCategory
    >>> for category in KarmaCategory.select(orderBy='title'):
    ...     print test_tales("category/image:icon", category=category)
    <img ... title="Answer Tracker" src="/@@/question" />
    <img ... title="Bug Management" src="/@@/bug" />
    <img ... title="Specification Tracking" src="/@@/blueprint" />
    <img ... title="Translations in Rosetta" src="/@@/translation" />

datetimes can be formatted with fmt:date, fmt:time, fmt:datetime and
fmt:rfc822utcdatetime.

   >>> from datetime import datetime, timedelta
   >>> dt = datetime(2005, 4, 1, 16, 22)
   >>> test_tales('dt/fmt:date', dt=dt)
   '2005-04-01'
   >>> test_tales('dt/fmt:time', dt=dt)
   '16:22:00'
   >>> test_tales('dt/fmt:datetime', dt=dt)
   '2005-04-01 16:22:00'
   >>> test_tales('dt/fmt:rfc822utcdatetime', dt=dt)
   'Fri, 01 Apr 2005 16:22:00 -0000'

To truncate a long string, use fmt:shorten:

    >>> test_tales('foo/fmt:shorten/8', foo='abcdefghij')
    'abcde...'

To preserve newlines in text when displaying as HTML, use
fmt:nl_to_br:

    >>> test_tales('foo/fmt:nl_to_br',
    ...             foo='icicle\nbicycle\ntricycle & troika')
    'icicle<br />\nbicycle<br />\ntricycle &amp; troika'

To "<pre>" format a string, use fmt:nice_pre:

    >>> import pprint, textwrap
    >>> pprint.pprint(textwrap.wrap(
    ...     test_tales('foo/fmt:nice_pre', foo='hello & goodbye')
    ... ))
    ['<pre style="white-space: -moz-pre-wrap;white-space: -o-pre-wrap;word-',
     'wrap: break-word;">hello &amp; goodbye</pre>']

Add manual word breaks to long words in a string:

    >>> test_tales('foo/fmt:break-long-words', foo='short words')
    'short words'
    >>> test_tales('foo/fmt:break-long-words',
    ...     foo='<http://launchpad.net/products/launchpad>')
    '&lt;http:/<wbr></wbr>/launchpad.<wbr></wbr>net/products/<wbr></wbr>launchpad&gt;'


== The fmt: namespace to get strings (hiding) ==

PGP blocks, signatures and full-quoted parts of a message can be
wrapped in markup to hide them:

    >>> pgp_open = ('-----BEGIN PGP SIGNED MESSAGE-----\n'
    ...             'Hash: SHA1\n'
    ...             '\n')
    >>> text = ('Top quoting is simply bad netiquette.\n'
    ...         'The words of the leading text should be displayed\n'
    ...         'normally--no markup to hide it from view.\n'
    ...         'Raise your hand if you can read this.\n'
    ...         '\n')
    >>> signature = ('-- \n'
    ...              '__C U R T I S  C.  H O V E Y_______\n'
    ...              'sinzui.is@example.org\n'
    ...              'Guilty of stealing everything I am.\n'
    ...              '\n')
    >>> pgp_close = ('-----BEGIN PGP SIGNATURE-----\n'
    ...              'Version: GnuPG v1.4.1 (GNU/Linux)\n'
    ...              'Comment: Using GnuPG with Thunderbird\n'
    ...              '\n'
    ...              'iD8DBQFED60Y0F+nu1YWqI0RAqrNAJ9hTww5vqDbxp4xJS8ek58W\n'
    ...              'T2PIWy0CUJsX8RXSt/M51WE=\n'
    ...              '=J2S5\n'
    ...              '-----END PGP SIGNATURE-----\n')

The email-to-html formatter marks up text as html using the
text-to-html formatter, then adds additional markup to identify
signatures and quoted passages. The formatters  wraps the text inside
the paragraph in a span of 'foldable' class. Stylesheets and scripts
in the browser can format or change the behaviour of the text as
needed.

When given simple paragraphs it behaves just as the text-to-html
formatter.

    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo=text)
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>

    >>> print test_tales('foo/fmt:text-to-html',
    ...                  foo=text)
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>

PGP signed messages have opening and closing blocks that are
wrapped in a foldable span.

    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo='\n'.join([pgp_open, text, pgp_close]))
    <p><span class="foldable">-----BEGIN PGP SIGNED MESSAGE-----<br />
    Hash: SHA1
    </span></p>
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>
    <p><span class="foldable">-----BEGIN PGP SIGNATURE-----<br />
    Version: GnuPG v1.4.1 (GNU/Linux)<br />
    Comment: Using GnuPG with Thunderbird<br />
    <br />
    iD8DBQFED60Y0F+<wbr></wbr>nu1YWqI0RAqrNAJ<wbr></wbr>...
    T2PIWy0CUJsX8RX<wbr></wbr>St/M51WE=<br />
    =J2S5<br />
    -----END PGP SIGNATURE-----
    </span></p>

In this example, we see the main paragraph and the signature marked
up as HTML. All the text inside the signature is wrapped with the
foldable span.

    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo='\n'.join([text, signature]))
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>
    <p><span class="foldable"...>--<br />
    __C U R T I S  C.  H O V E Y_______<br />
    sinzui.<wbr></wbr>is@example.<wbr></wbr>org<br />
    Guilty of stealing everything I am.
    </span></p>

Quoted passages are treated somewhat different from signatures because
they often have a citation line before the quoted text. In this
example of the main paragraph and the quoted paragraph, only the
lines that start with the quote identifier ('> ' in this case) are
wrapped with the foldable-quoted span.

    >>> quoted_text = ('Somebody said sometime ago:\n'
    ...                '> 1. Remove the letters  c, j, q, x, w\n'
    ...                '>    from the English Language.\n'
    ...                '> 2. Remove the penny from US currency.\n'
    ...                '\n')
    >>> quoted_text_all = ('> continuing from a previous thought.\n'
    ...                    '> 3. Get new handwriting.\n'
    ...                    '> 4. Add Year Zero to the calendar.\n'
    ...                    '\n')
    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo='\n'.join([text, quoted_text, quoted_text_all]))
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>
    <p>Somebody said sometime ago:<br />
    <span class="foldable-quoted">
    &gt; 1. Remove the letters  c, j, q, x, w<br />
    &gt;    from the English Language.<br />
    &gt; 2. Remove the penny from US currency.
    </span></p>
    <p><span class="foldable-quoted">&gt; continuing from a previous thoug...
    &gt; 3. Get new handwriting.<br />
    &gt; 4. Add Year Zero to the calendar.
    </span></p>

The reverse order works too:

    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo='\n'.join([quoted_text_all, quoted_text, text]))
    <p><span class="foldable-quoted">&gt; continuing from a previous thoug...
    &gt; 3. Get new handwriting.<br />
    &gt; 4. Add Year Zero to the calendar.
    </span></p>
    <p>Somebody said sometime ago:<br />
    <span class="foldable-quoted">
    &gt; 1. Remove the letters  c, j, q, x, w<br />
    &gt;    from the English Language.<br />
    &gt; 2. Remove the penny from US currency.
    </span></p>
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>

Paragraphs that mix quoted and reply text fold only the quoted lines.

    >>> mixed_quoted_text = ('Mister X wrote:\n'
    ...                      '> This is a quoted line\n'
    ...                      'This is a reply to the line above.\n'
    ...                      'This is a continuation line.'
    ...                      '\n')
    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo='\n'.join([mixed_quoted_text, text]))
    <p>Mister X wrote:<br />
    <span class="foldable-quoted">
    &gt; This is a quoted line<br />
    </span>
    This is a reply to the line above.<br />
    This is a continuation line.</p>
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>

A quoted section is folded without affecting the display of the
surrounding paragraph, even if there are no blank lines to separate
the quoted section from the paragraph.

    >>> quoted_remark_text = ('Attribution line\n'
    ...                       '> quoted_line\n'
    ...                       'Remark line.\n'
    ...                       '\n')
    >>> print test_tales('foo/fmt:email-to-html', foo=quoted_remark_text)
    <p>Attribution line<br />
    <span class="foldable-quoted">
    &gt; quoted_line<br />
    </span>
    Remark line.</p>

Paragraphs with nested quoting fold all the quoted lines. There
is no distinction between the nested levels of quoting.

    >>> nested_quoting = ('>>>> four\n'
    ...                   '>>> three\n'
    ...                   '>> two\n'
    ...                   '> one\n')
    >>> print test_tales('foo/fmt:email-to-html', foo=nested_quoting)
    <p><span class="foldable-quoted">&gt;&gt;&gt;&gt; four<br />
    &gt;&gt;&gt; three<br />
    &gt;&gt; two<br />
    &gt; one
    </span></p>

The output from the Python interpreter is not quoted text. Passages
of text that start with '>>> ' are exempted from the 'foldable-quoted'
rules. Note that when '>>> ' occurs inside an existing quoted passage
it will be folded because they are a continuation of a quote (see
the preceding nested quoting test).
# XXX sinzui 2007-08-13 bug=132263:
# Passages may be wrongly be interpreted as Python because they start
# with '>>> '. The formatter does not check that next and previous
# lines of text consistently uses '>>> ' as Python would.

    >>> python = ('>>> tz = pytz.timezone("Asia/Calcutta")\n'
    ...           '>>> mydate = datetime.datetime(2007, 2, 18, 15, 35)\n'
    ...           '>>> print tz.localize(mydate)\n'
    ...           '2007-02-18 15:35:00+05:30\n'
    ...           '\n')
    >>> not_python = ('> This line really is a quoted passage.\n'
    ...               '>>> This does not invoke an exception rule.\n'
    ...               '\n')
    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo='\n'.join([python, not_python]))
    <p>&gt;&gt;&gt; tz = pytz.timezone(<wbr></wbr>"Asia/Calcutta"...
    &gt;&gt;&gt; mydate = datetime.<wbr></wbr>datetime(<wbr></wbr>2007, 2, ...
    2007-02-18 15:35:00+05:30</p>
    <p><span class="foldable-quoted">&gt; This line really is a quoted ...
    &gt;&gt;&gt; This does not invoke an exception rule.
    </span></p>

Quoting styles vary between email clients, and how the user starts the
quote. Starting runs like '>> ' are as valid as '> ', so they are
wrapped in a foldable-quoted span.

    >>> weird_quoted_text = ('Ms. Y wrote:\n'
    ...                      '>> This is a double quoted line\n'
    ...                      '>> > This is a triple quoted line.\n'
    ...                      '\n')
    >>> print test_tales('foo/fmt:email-to-html', foo=weird_quoted_text)
    <p>Ms. Y wrote:<br />
    <span class="foldable-quoted">
    &gt;&gt; This is a double quoted line<br />
    &gt;&gt; &gt; This is a triple quoted line.
    </span></p>

Dpkg generates lines that start with a '|' that will be confused with
quoted text. Dpkg is common in messages, and when it is, we do not
fold lines that start with a '|'. We sometimes receive bad dpkg output
where the lines are broken, and we must take care to identify that
output and not fold it.

    >>> bar_quoted_text = ('Someone said sometime ago:\n'
    ...                    '| Quote passages are folded.\n'
    ...                    '\n')
    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo='\n'.join([text, bar_quoted_text]))
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>
    <p>Someone said sometime ago:<br />
    <span class="foldable-quoted">
    | Quote passages are folded.
    </span></p>

    >>> dpkg = ('dpkg -l libdvdread3\n'
    ...         'Desired=Unknown/Install/Remove/Purge/Hold\n'
    ...         '| Status=Not/Installed/Config-files/Unpacked/Failed-co\n'
    ...         '|/ Err?=(none)/Hold/Reinst-required/X=both-problems\n'
    ...         '||/ Name Version Description\n'
    ...         '+++-==============-==============-====================\n'
    ...         'ii libdvdread3 0.9.7-2ubuntu1 library for reading DVDs\n'
    ...         '\n')
    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo='\n'.join([text, dpkg]))
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>
    <p>dpkg -l libdvdread3<br />
    Desired=<wbr></wbr>Unknown/<wbr></wbr>Install/<wbr></wbr>...
    | Status=<wbr></wbr>Not/Installed/<wbr></wbr>Config-<wbr></wbr>...
    |/ Err?=(none)<wbr></wbr>/Hold/Reinst-<wbr></wbr>required/...
    ||/ Name Version Description<br />
    +++-===<wbr></wbr>=======<wbr></wbr>====-==<wbr></wbr>=======...
    ii libdvdread3 0.9.7-2ubuntu1 library for reading DVDs</p>

    >>> bad_dpkg = ('When dpkg output is in text, possibly tampered with,\n'
    ...             "we must take care to identify '|' quoted passages.\n"
    ...             '$ Desired=Unknown/Install/Remove/Purge/Hold\n'
    ...             '|\n'
    ...             ' Status=Not/Installed/Config-files/Unpacked/Failed-co\n'
    ...             '|/ Err?=(none)/Hold/Reinst-required/X=both-problems\n'
    ...             '||/ Name Version Description\n'
    ...             '+++-==============-==============-==================\n'
    ...             'ii libdvdread3 0.9.7-2ubuntu1 library for reading DVDs\n'
    ...             '\n')
    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo='\n'.join([bad_dpkg]))
    <p>When dpkg output is in text, possibly tampered with,<br />
    we must take care to identify '|' quoted passages.<br />
    $ Desired=<wbr></wbr>Unknown/<wbr></wbr>Install/<wbr></wbr>Remove/...
    |<br />
    &nbsp;Status=<wbr></wbr>Not/Installed/<wbr></wbr>Config-...
    |/ Err?=(none)<wbr></wbr>/Hold/Reinst-<wbr></wbr>required/...
    ||/ Name Version Description<br />
    +++-===<wbr></wbr>=======<wbr></wbr>====-==<wbr></wbr>=======...
    ii libdvdread3 0.9.7-2ubuntu1 library for reading DVDs</p>


The formatter is indifferent to the number and kinds of paragraphs
it must markup. We can format the three examples at the same time.

    >>> print test_tales('foo/fmt:email-to-html',
    ...     foo='\n'.join([text, quoted_text, text, quoted_text, signature]))
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>
    <p>Somebody said sometime ago:<br />
    <span class="foldable-quoted"...>
    &gt; 1. Remove the letters  c, j, q, x, w<br />
    &gt;    from the English Language.<br />
    &gt; 2. Remove the penny from US currency.
    </span></p>
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>
    <p>Somebody said sometime ago:<br />
    <span class="foldable-quoted"...>
    &gt; 1. Remove the letters  c, j, q, x, w<br />
    &gt;    from the English Language.<br />
    &gt; 2. Remove the penny from US currency.
    </span></p>
    <p><span class="foldable"...>--<br />
    __C U R T I S  C.  H O V E Y_______<br />
    sinzui.<wbr></wbr>is@example.<wbr></wbr>org<br />
    Guilty of stealing everything I am.
    </span></p>


== The fmt: namespace to get strings (obfuscation) ==

Email addresses embedded in text can be obfuscated. In cases where
personal information may be in the content, and it will be shown to
unauthenticated users, the email address can be hidden. The address
is replaced with the message '<email address hidden>'.

    >>> test_tales('foo/fmt:obfuscate-email', foo='name.surname@company.com')
    '<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email', foo='name@organization.org.cc')
    '<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email', foo='name+sub@domain.org')
    '<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email',
    ...     foo='long_name@host.long-network.org.cc')
    '<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email',
    ...     foo='"long/name="@organization.org')
    '"<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email',
    ...     foo='long-name@building.museum')
    '<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email', foo='foo@staticmethod.com')
    '<email address hidden>'

    >>> print test_tales('foo/fmt:obfuscate-email/fmt:text-to-html',
    ...     foo=signature)
    <p>--<br />
    __C U R T I S  C.  H O V E Y_______<br />
    &lt;email address hidden&gt;<br />
    Guilty of stealing everything I am.</p>

    >>> # Email addresses and credentials in a URL match.
    >>> test_tales('foo/fmt:obfuscate-email',
    ...     foo='mailto:long-name@very.long.dom.cc')
    'mailto:<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email',
    ...     foo='http://person:password@site.net')
    'http://person:<email address hidden>'

    >>> # An Invalid email address does not match.
    >>> test_tales('foo/fmt:obfuscate-email', foo='name @ host.school.edu')
    'name @ host.school.edu'
    >>> # SSH is not an email address.
    >>> test_tales('foo/fmt:obfuscate-email', foo='person@host')
    'person@host'
    >>> # Perl/shell arrays are not an email address.
    >>> test_tales('foo/fmt:obfuscate-email', foo='(head, tail)=@array')
    '(head, tail)=@array'
    >>> # Python decorators and Java annotations are not email addresses.
    >>> test_tales('foo/fmt:obfuscate-email', foo='@staticmethod')
    '@staticmethod'
    >>> # XPath expressions are not email addresses.
    >>> test_tales('foo/fmt:obfuscate-email', foo='element/@attribute')
    'element/@attribute'
    >>> # An invalid address, some characters, followed by many dots, and
    >>> # some more characters. This pattern (derived from a real example)
    >>> # caused the re to hang the servers and the test suite.
    >>> # The re used one-or-none in a grouping (\.?), which is expensive.
    >>> bad_address = (
    ...     "medicalwei@sara:~$ Spinning................................"
    ...     "...........................................................not")
    >>> test_tales('foo/fmt:obfuscate-email', foo=bad_address)
    'medicalwei@sara:~$ ...'


== Test the 'fmt:' namespace where the context is a dict. ==

fmt:pagetitle takes a page template CONTEXTS dict, and gives you a string
for use in the <title> element of a page.

This case ought to apply only to a page template's CONTEXTS dict.  However, we
have to make this namespace available for all dicts, as there is no type
information to distinguish a page template CONTEXTS dict from any other dict.

    >>> class MockPageTemplateFile:
    ...     filename = '/blah/blah/debug-root-index.pt'
    ...
    >>> CONTEXTS = {'template': MockPageTemplateFile}
    >>> test_tales('foo/fmt:pagetitle', foo=CONTEXTS)
    'Launchpad Debug Home Page'


Test the 'fmt:url' namespace for canonical urls.

    >>> from canonical.launchpad.webapp.interfaces import ICanonicalUrlData
    >>> from zope.interface import implements
    >>> class ObjectThatHasUrl:
    ...     implements(ICanonicalUrlData)
    ...     path = 'bonobo/saki'
    ...     inside = None
    ...     rootsite = None

    >>> object_having_url = ObjectThatHasUrl()
    >>> test_tales('foo/fmt:url', foo=object_having_url)
    u'http://launchpad.dev/bonobo/saki'

Now, we need to test that it gets the correct application URL from the
request.

Make a mock-up IBrowserRequest, and use this as the interaction.

    >>> from zope.publisher.interfaces.browser import \
    ...     IBrowserApplicationRequest
    >>> from zope.interface import implements
    >>> class MockBrowserRequest:
    ...     implements(IBrowserApplicationRequest)
    ...
    ...     interaction = None
    ...     principal = None
    ...
    ...     def getApplicationURL(self):
    ...         return 'https://mandrill.example.org:23'

    >>> participation = MockBrowserRequest()

    >>> login(ANONYMOUS, participation)

Note how the URL has only a path part, because it is for the same site
as the current request.

    >>> test_tales('foo/fmt:url', foo=object_having_url)
    u'/bonobo/saki'


== The some_string/fmt:something helper ==

Test the 'fmt:' namespace where the context is None. In general, these
will return an empty string.  They are provided for ease of handling
NULL values from the database, which become None values for attributes
in content classes.

Everything you can do with 'something/fmt:foo', you should be able to
do with 'None/fmt:foo'.

    >>> test_tales('foo/fmt:shorten', foo=None)
    Traceback (most recent call last):
    ...
    TraversalError: 'you need to traverse a number after fmt:shorten'

    >>> test_tales('foo/fmt:shorten/8', foo=None)
    ''
    >>> test_tales('foo/fmt:nl_to_br', foo=None)
    ''
    >>> test_tales('foo/fmt:nice_pre', foo=None)
    ''
    >>> test_tales('foo/fmt:break-long-words', foo=None)
    ''
    >>> test_tales('foo/fmt:breadcrumbs', foo=None)
    ''
    >>> test_tales('foo/fmt:date', foo=None)
    ''
    >>> test_tales('foo/fmt:time', foo=None)
    ''
    >>> test_tales('foo/fmt:datetime', foo=None)
    ''
    >>> test_tales('foo/fmt:rfc822utcdatetime', foo=None)
    ''
    >>> test_tales('foo/fmt:pagetitle', foo=None)
    ''
    >>> test_tales('foo/fmt:text-to-html', foo=None)
    ''
    >>> test_tales('foo/fmt:email-to-html', foo=None)
    ''
    >>> test_tales('foo/fmt:url', foo=None)
    ''
    >>> test_tales('foo/fmt:exactduration', foo=None)
    ''
    >>> test_tales('foo/image:icon', foo=None)
    ''


== The lp: namespace for presenting DBSchema items ==

This is deprecated, and should raise a deprecation warning in the future,
and eventually be removed.  It is no longer needed, now that we have
an EnumCol for sqlobject.

Test the 'lp:' namespace for presenting DBSchema items.

    >>> from canonical.lp.dbschema import BinaryPackageFormat
    >>> deb = BinaryPackageFormat.DEB.value
    >>> test_tales('deb/lp:BinaryPackageFormat', deb=deb)
    'Ubuntu Package'


== The someobject/required:some.Permission helper ==

Test the 'required:' namespace.  We're already logged in as the anonymous user,
and anonymous users can't edit any person:

    >>> test_tales('person/required:launchpad.Edit', person=person)
    False

Anonymous users can do anything with the zope.Public permission.

    >>> test_tales('person/required:zope.Public', person=person)
    True

Queries about permissions that don't exist will raise an exception:

    >>> test_tales('person/required:mushroom.Badger', person=person)
    Traceback (most recent call last):
    ...
    ValueError: ('Undefined permission id', 'mushroom.Badger')


== The somevalue/enumvalue:ENUMVALUE helper ==

You can test whether a particular value that you have in your page template
matches a particular valid value for that DBSchema enum.

This was going to be called 'enum-value', but Zope doesn't allow this.
To be fixed upstream.

    >>> from canonical.lp.dbschema import BinaryPackageFormat
    >>> deb = BinaryPackageFormat.DEB
    >>> udeb = BinaryPackageFormat.UDEB
    >>> test_tales('deb/enumvalue:DEB', deb=deb)
    True
    >>> test_tales('deb/enumvalue:DEB', deb=udeb)
    False

We don't get a ValueError when we use a value that doesn't appear in the
DBSchema the item comes from.

    >>> test_tales('deb/enumvalue:CHEESEFISH', deb=udeb)
    Traceback (most recent call last):
    ...
    TraversalError: 'The enumerated type BinaryPackageFormat does not have a value CHEESEFISH.'

It is possible for dbschemas to have a 'None' value.  This is a bit awkward,
because when the value is None, we can't do any checking whether a new value
is from the correct schema.  In any case, this case is not currently handled.

The enumvalue tales expression is designed to work with security
wrapped dbschema items too:

    >>> from zope.security.proxy import ProxyFactory
    >>> wrapped_deb = ProxyFactory(BinaryPackageFormat.DEB)
    >>> test_tales('deb/enumvalue:DEB', deb=wrapped_deb)
    True
    >>> test_tales('deb/enumvalue:UDEB', deb=wrapped_deb)
    False
    >>> test_tales('deb/enumvalue:CHEESEFISH', deb=wrapped_deb)
    Traceback (most recent call last):
    ...
    TraversalError: 'The enumerated type BinaryPackageFormat does not have a value CHEESEFISH.'
