== SourcePackagePublishingHistory ==

This class provides public access to publishing records via a SQL view.

    >>> from canonical.launchpad.database import SourcePackagePublishingHistory
    >>> from canonical.launchpad.database import BinaryPackagePublishingHistory

Select a publishing record from the sampledata (pmount is a
interesting one):

    >>> spph = SourcePackagePublishingHistory.get(8)
    >>> spph.sourcepackagerelease.name, spph.distroseries.name
    (u'pmount', u'hoary')

Verify if the object follows its interface contracts:

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     ISourcePackageRelease, IDistroSeries,
    ...     ISourcePackagePublishingHistory,
    ...     ISourcePackage,
    ...     IDistributionSourcePackageRelease)

    >>> verifyObject(ISourcePackagePublishingHistory, spph)
    True

 XXX cprov 20060322: None of the attributes below pass verifyObject().
 So, they claim to implement some thing they don't really have. Most
 of the problems are related with bad interface inheritance.

    >>> IDistroSeries.providedBy(spph.distroseries)
    True

    >>> ISourcePackageRelease.providedBy(spph.sourcepackagerelease)
    True

    >>> ISourcePackageRelease.providedBy(spph.supersededby)
    True

    >>> IDistributionSourcePackageRelease.providedBy(
    ...     spph.meta_sourcepackagerelease)
    True

    >>> IDistributionSourcePackageRelease.providedBy(spph.meta_supersededby)
    True

    >>> ISourcePackage.providedBy(spph.meta_sourcepackage)
    True


== Stanza generation ==

    >>> from canonical.launchpad.interfaces import (
    ...     IArchiveSafePublisher, ISourcePackageFilePublishing,
    ...     ISecureSourcePackagePublishingHistory,
    ...     ISecureBinaryPackagePublishingHistory)

Retrieve any SourcePackagePublishingHistory entry.

    >>> spph = SourcePackagePublishingHistory.get(10)

    >>> verifyObject(ISourcePackagePublishingHistory, spph)
    True

    >>> print spph.displayname
    alsa-utils 1.0.8-1ubuntu1 in warty

A 'stanza' is the name given to a group of attributes related to one
source or binary package in the archive index file, it provides
information to APT, things like, package name, pool path, DSC format,
files checksum, etc.

The archive index should contain one entry for each source or binary
currently published in the archive, it is usually partionated by
component:

<mirror_url_base>/ubuntu/edgy/main/binary-i386/Packages
<mirror_url_base>/ubuntu/edgy/main/source/Sources

The archive index is also available in in compressed formats.

    >>> print spph.getIndexStanza() #doctest: -NORMALIZE_WHITESPACE
    Package: alsa-utils
    Binary: alsa-mixer
    Version: 1.0.8-1ubuntu1
    Section: base
    Maintainer: Mark Shuttleworth <sabdfl@hbd.com>
    Architecture: all
    Standards-Version: 3.6.2
    Format: 1.0
    Directory: pool/main/a/alsa-utils
    Files:
     01234567890123456789012345678925 3 alsa-utils_1.0.8-1ubuntu1.dsc

Empty fields like are suppressed, like 'Build-Depends' or
'Build-Depends-Indep' to avoid extra charge on download.
See sourcepackagerelease.txt for further information about the fields
in question.

Files published are accessible via the files property:

    >>> any_pub_file = spph.files[-1]
    >>> ISourcePackageFilePublishing.providedBy(any_pub_file)
    True

    >>> [(pub_file.libraryfilealias.filename, pub_file.file_type_name,
    ...   pub_file.archive_url) for pub_file in spph.files]
    [(u'alsa-utils_1.0.8-1ubuntu1.dsc', 'dsc',
      u'http://launchpad.dev/ubuntu/pool/main/a/alsa-utils/alsa-utils_1.0.8-1ubuntu1.dsc')]


== Deletion and obsolescence ==

ArchivePublisherBase, which is common to SourcePackagePublishingHistory
and BinaryPackagePublishingHistory, contains the methods requestDeletion
and requestObsolescence.  These will change the publishing record to
the states DELETED and OBSOLETE respectively.

requestDeletion requires a removed_by (IPerson) and optionally a
removal_comment argument.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from zope.component import getUtility
    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> modified_spph = spph.requestDeletion(sabdfl, "testing deletion")

Inspecting the modified record shows it's ready for domination:

    >>> modified_spph.status
    <DBItem PackagePublishingStatus.DELETED, (4) Deleted>
    >>> modified_spph.datesuperseded
    CURRENT_TIMESTAMP AT TIME ZONE 'UTC'
    >>> modified_spph.removed_by.name
    u'sabdfl'
    >>> modified_spph.removal_comment
    u'testing deletion'

requstObsolescence takes no additional arguments:

    >>> modified_spph = spph.requestObsolescence()

Inspecting the modified record shows it's ready for death row (obsoleted
publications skip domination because domination only works in post-release
pockets for stable distroseries):

    >>> modified_spph.status
    <DBItem PackagePublishingStatus.OBSOLETE, (5) Obsolete>
    >>> modified_spph.scheduleddeletiondate
    CURRENT_TIMESTAMP AT TIME ZONE 'UTC'


== Copying and published binarypackages lookup ==

ISourcePackagePublishingHistory provides the getPublishedBinaries
which returns all published binaries build from a source in the pocket
it is published.

We will use SoyuzTestPublisher to generate coherent publications to
test this feature.

    >>> from canonical.launchpad.tests.test_publishing import (
    ...      SoyuzTestPublisher)
    >>> test_publisher = SoyuzTestPublisher()

    >>> from canonical.launchpad.ftests import login
    >>> login('foo.bar@canonical.com')

    >>> test_publisher.prepareBreezyAutotest()

We will create a publication for a source (foo) and two
architecture-independent binaries in ubuntu/breezy-autotest.

    >>> from canonical.launchpad.interfaces import (
    ...     PackagePublishingStatus, PackagePublishingPocket)
    >>> source = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.PROPOSED)
    >>> binaries = test_publisher.getPubBinaries(
    ...     pub_source=source,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.PROPOSED)

    >>> print source.displayname
    foo 666 in breezy-autotest

    >>> for bin in binaries:
    ...     print bin.displayname
    foo-bin 666 in breezy-autotest i386
    foo-bin 666 in breezy-autotest hppa

Using the source publication, ISecureSourcePackagePublishingHistory, we
can obtain the published binaries.

    >>> created_ids = [bin.id for bin in binaries]
    >>> retrieved_ids = [bin.id for bin in source.getPublishedBinaries()]
    >>> sorted(created_ids) == sorted(retrieved_ids)
    True

We can also inspect the builds created for a source publication
without retrieving its binaries.

    >>> for build in source.getBuilds():
    ...     print build.title
    i386 build of foo 666 in ubuntutest breezy-autotest PROPOSED

Now that we know how to retrieve generated binary publication related
to a source publication we can exercise the API provided to copy
publications across suites and/or archives.

One of the most common use-cases for copying a publication is when
archive-admins wants to release for public audience a Stable Release
Update (SRU) which was successfully tested in PROPOSED pocket. This
procedure will consist of a source copy from PROPOSED to UPDATES
including its binaries.

'distroseries' and 'archive' will be constant.

    >>> distroseries = source.distroseries
    >>> archive = source.archive

'pocket' will be UPDATES.

    >>> pocket = PackagePublishingPocket.UPDATES

Let's perform the copy of the source and all its binaries.

    >>> copied_source = source.copyTo(distroseries, pocket, archive)

    >>> copied_binaries = []
    >>> for bin in binaries:
    ...     copied_binaries.append(
    ...          bin.copyTo(distroseries, pocket, archive))

The 'copied' records are instance of Secure{Source,
Binary}PackagePublishingHistory:

    >>> ISecureSourcePackagePublishingHistory.providedBy(copied_source)
    True

    >>> [ISecureBinaryPackagePublishingHistory.providedBy(bin)
    ...  for bin in copied_binaries]
    [True, True]

Copied publications are created as PENDING, so the publisher will have
a chance to verify it's contents and include it in the destination
archive index.

    >>> print copied_source.status.name
    PENDING

    >>> for bin in copied_binaries:
    ...     print bin.status.name
    PENDING
    PENDING

Let's retrieve the 'insecure' corresponding publishing records since
only they provide the API we are interested in.

    >>> copied_source = SourcePackagePublishingHistory.get(copied_source.id)

    >>> copied_binaries = [BinaryPackagePublishingHistory.get(bin.id)
    ...                    for bin in copied_binaries]

Now we can observe that both, the original and the copied sources are
related only with their corresponding binaries, see bug #181834 for
previous broken implementation in this area.

    >>> for bin in source.getPublishedBinaries():
    ...     print bin.displayname, bin.pocket.name, bin.status.name
    foo-bin 666 in breezy-autotest hppa PROPOSED PUBLISHED
    foo-bin 666 in breezy-autotest i386 PROPOSED PUBLISHED

    >>> for bin in copied_source.getPublishedBinaries():
    ...     print bin.displayname, bin.pocket.name, bin.status.name
    foo-bin 666 in breezy-autotest hppa UPDATES PENDING
    foo-bin 666 in breezy-autotest i386 UPDATES PENDING

Note that even PENDING binary publications are returned by
getPublishedBinaries, it considers both PENDING and PUBLISHED status
as active, SUPERSEDED, DELETED and OBSOLETE are excluded.

    >>> source.getPublishedBinaries().count()
    2

When we supersede one of the original binary publications, it gets
excluded from the getPublishedBinaries results.

    >>> superseded = source.getPublishedBinaries()[0].supersede()

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()

    >>> source.getPublishedBinaries().count()
    1

The same happens when we delete the i386 binary, so no binaries are
published in the original location.

    >>> deleted = source.getPublishedBinaries()[0].requestDeletion(
    ...     sabdfl, "go")
    >>> flush_database_updates()

    >>> source.getPublishedBinaries().count()
    0

Finally we will mark both copied binary publication as obsolete and
verify that the getPublishedBinaries result is also empty after that.

    >>> copied_source.getPublishedBinaries().count()
    2

    >>> for bin in copied_source.getPublishedBinaries():
    ...     obsoleted = bin.requestObsolescence()
    >>> flush_database_updates()

    >>> copied_source.getPublishedBinaries().count()
    0

We have to re-publish the superseded and the deleted publications above
because it's used below.

    >>> superseded.status = PackagePublishingStatus.PUBLISHED
    >>> deleted.status = PackagePublishingStatus.PUBLISHED
    >>> flush_database_updates()


== getSourceAndBinaryLibraryFiles ==

This method retrieves LibraryFileAlias records for all source and binary
files associated with this publication.

Using the same Ubuntu source publishing example as above:

    >>> for file in source.getSourceAndBinaryLibraryFiles():
    ...     print file.filename
    foo.dsc
    foo-bin_all.deb
    foo-bin_all.deb

We can also publish a package in a PPA and query on its files:

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> ppa_source = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     archive=cprov.archive)
    >>> ppa_binaries= test_publisher.getPubBinaries(
    ...     pub_source=ppa_source,
    ...     status=PackagePublishingStatus.PUBLISHED)

    >>> for file in ppa_source.getSourceAndBinaryLibraryFiles():
    ...     print file.filename
    foo.dsc
    foo-bin_all.deb
    foo-bin_all.deb

Notice that some files appear twice if they are published in more than one
architecture (e.g. for arch-all files).


== Secure Source Publishing ==

'secure_record' returns a ISecureSourcePackagePublishing instance
corresponding to this publication. This instance also implements
IArchiveSafePublisher.

    >>> sspph = spph.secure_record
    >>> ISecureSourcePackagePublishingHistory.providedBy(sspph)
    True
    >>> verifyObject(IArchiveSafePublisher, sspph)
    True
    >>> sspph.embargo
    False


== Binary and Binary File Publishing ===

Symmetric behaviour is offered for BinaryPackagePublishing,
BinaryPackageFile and ISecureBinaryPackagePublishingHistory

    >>> from canonical.launchpad.interfaces import (
    ...     IBinaryPackagePublishingHistory, IBinaryPackageFilePublishing)

    >>> bpph = BinaryPackagePublishingHistory.get(15)
    >>> print bpph.displayname
    mozilla-firefox 0.9 in woody i386

    >>> IBinaryPackagePublishingHistory.providedBy(bpph)
    True

Generating respective "Packages" stanzas:

    >>> print bpph.getIndexStanza() #doctest: -NORMALIZE_WHITESPACE
    Package: mozilla-firefox
    Source: mozilla-firefox
    Priority: important
    Section: editors
    Maintainer: Mark Shuttleworth <mark@canonical.com>
    Architecture: i386
    Version: 0.9
    Recommends: gcc-3.4-base, libc6 (>= 2.3.2.ds1-4), gcc-3.4 (>= 3.4.1-4sarge1), gcc-3.4 (<< 3.4.2), libstdc++6-dev (>= 3.4.1-4sarge1)
    Replaces: gnome-mozilla-browser
    Suggests: firefox-gnome-support (= 1.0.7-0ubuntu20), latex-xft-fonts, xprint
    Provides: mozilla-firefox
    Depends: gcc-3.4-base, libc6 (>= 2.3.2.ds1-4), gcc-3.4 (>= 3.4.1-4sarge1), gcc-3.4 (<< 3.4.2), libstdc++6-dev (>= 3.4.1-4sarge1)
    Conflicts: firefox, mozilla-web-browser
    Pre-Depends: pmount, foo
    Enhances: pmount, bar
    Breaks: pmount, baz
    Filename: pool/universe/m/mozilla-firefox/mozilla-firefox_0.9_i386.deb
    Size: 3
    MD5sum: 01234567890123456789012345678926
    Description: Mozilla Firefox Web Browser
     Mozilla Firefox Web Browser is .....

    >>> sbpph = bpph.secure_record
    >>> ISecureBinaryPackagePublishingHistory.providedBy(sbpph)
    True
    >>> verifyObject(IArchiveSafePublisher, sbpph)
    True
    >>> sbpph.embargo
    False

    >>> any_file = bpph.files[-1]
    >>> IBinaryPackageFilePublishing.providedBy(any_file)
    True

    >>> [pub_file.libraryfilealias.filename for pub_file in bpph.files]
    [u'mozilla-firefox_0.9_i386.deb']

    >>> [pub_file.archive_url for pub_file in bpph.files]
    [u'http://launchpad.dev/debian/pool/universe/m/mozilla-firefox/mozilla-firefox_0.9_i386.deb']
