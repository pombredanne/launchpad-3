= Personal Package Archives =

An Archive models a Debian Archive ...

  >>> from canonical.launchpad.webapp.testing import verifyObject
  >>> from canonical.lp.dbschema import ArchivePurpose
  >>> from canonical.launchpad.interfaces import (
  ...     IPerson, IPersonSet, IArchiveSet, IArchive,
  ...     IDistributionSet)

  >>> cprov = getUtility(IPersonSet).getByName('cprov')
  >>> cprov_archive = cprov.archive

  >>> cprov_archive.owner.name
  u'cprov'
  >>> cprov_archive.distribution.name
  u'ubuntu'
  >>> cprov_archive.purpose.name
  'PPA'
  >>> cprov_archive.enabled
  True
  >>> cprov_archive.authorized_size
  1234567
  >>> cprov_archive.whiteboard
  u'It is not my fault.'

Useful properties:

  >>> cprov_archive.title
  u'Personal Package Archive for Celso Providelo'

  >>> cprov_archive.archive_url
  u'http://ppa.launchpad.dev/cprov/ubuntu'


== Published Source and Binary Lookup ==

IArchive implements a published source & binary lookup methods,
returning I{Source, Binary}PackagePublishingHistory objects.

  >>> cprov_archive.getPublishedSources().count()
  3

  >>> cprov_archive.getPublishedBinaries().count()
  3

This lookup also support 'name' restriction (as in SQL
"LIKE '%%' || NAME || '%%'").

Let's inspect sources:

  >>> cd_lookup = cprov_archive.getPublishedSources(name='cd')
  >>> cd_lookup.count()
  1
  >>> cd_lookup[0].sourcepackagerelease.name
  u'cdrkit'

  >>> ice_lookup = cprov_archive.getPublishedSources(name='ice')
  >>> ice_lookup.count()
  1
  >>> ice_lookup[0].sourcepackagerelease.name
  u'iceweasel'

  >>> cprov_archive.getPublishedSources(name='foo').count()
  0

Let's inspect binaires:

  >>> moz_lookup = cprov_archive.getPublishedBinaries(name='moz')
  >>> moz_lookup[0].binarypackagerelease.name
  u'mozilla-firefox'

  >>> cprov_archive.getPublishedBinaries(name='foo').count()
  0

'getPublishedBinaries' returns only unique publications, i.e., it
excludes architecture-independent duplications which is necessary for
having correct publication counters and archive size.

  >>> from canonical.launchpad.database.publishing import (
  ...     BinaryPackagePublishingHistory)

  >>> def check_bin_pubs(pubs):
  ...     """Print binary publication details."""
  ...     for pub in pubs:
  ...         title = pub.binarypackagerelease.title
  ...         arch_spec = pub.binarypackagerelease.architecturespecific
  ...         pub_arch = pub.distroarchseries.architecturetag
  ...         print "%s (%s) -> %s" % (title, arch_spec, pub_arch)

The PPA for cprov contain 3 binary publications, however 'pmount' is
'architecture independent', which means that the same binary (DB) is
published for all available architectures, i386 & hppa:

  >>> all_cprov_bin_pubs = BinaryPackagePublishingHistory.selectBy(
  ...      archive=cprov_archive, orderBy=['id'])

  >>> check_bin_pubs(all_cprov_bin_pubs)
  mozilla-firefox-1.0 (True) -> i386
  pmount-0.1-1 (False) -> i386
  pmount-0.1-1 (False) -> hppa
  mozilla-firefox-1.0 (True) -> hppa

'getPublishedBinaries' automatically filters multiple publications of
'pmount' considering only the publication to the 'nominatedarchindep'
(defined for each distroseries).

  >>> unique_cprov_bin_pubs = cprov_archive.getPublishedBinaries()

  >>> check_bin_pubs(unique_cprov_bin_pubs)
  mozilla-firefox-1.0 (True) -> i386
  pmount-0.1-1 (False) -> i386
  mozilla-firefox-1.0 (True) -> hppa

== Package Counters ==

IArchive provides properties to calculate the number and the size of
the packages (sources and binaries) present in the archive. They are
based in the publication lookup methods.

  >>> cprov_archive.number_of_sources
  3
  >>> cprov_archive.number_of_binaries
  3
  >>> cprov_archive.sources_size
  9923399
  >>> cprov_archive.binaries_size
  3

Additionally we have another property to sum up the sources and the
binaries size and a pre-defined increment related to the files created
in the archive (+1kbytes for each publication)

  >>> pool_size = (
  ...     cprov_archive.sources_size + cprov_archive.binaries_size)

  >>> number_of_publications = (
  ...     cprov_archive.number_of_sources + cprov_archive.number_of_binaries)
  >>> indexes_size = number_of_publications * 1024

  >>> estimated_size = cprov_archive.estimated_size

  >>> estimated_size == pool_size + indexes_size
  True

  >>> estimated_size
  9929546


== Build Lookup ==

It also implements a build lookup method, which supports, 'name',
'status' and 'pocket'.

This method can return build records for sources matching the given
'name' as in SQL LIKE:

  >>> cd_lookup = cprov_archive.getBuildRecords(name='cd')
  >>> cd_lookup.count()
  1
  >>> cd_lookup[0].sourcepackagerelease.name
  u'cdrkit'

  >>> ice_lookup = cprov_archive.getBuildRecords(name='ice')
  >>> ice_lookup.count()
  1
  >>> ice_lookup[0].sourcepackagerelease.name
  u'iceweasel'

  >>> cprov_archive.getBuildRecords(name='foo').count()
  0

Or return build records in a specific status:

  >>> from canonical.lp.dbschema import BuildStatus
  >>> cprov_archive.getBuildRecords(build_state=BuildStatus.FULLYBUILT).count()
  3

  >>> cprov_archive.getBuildRecords(
  ...     build_state=BuildStatus.FAILEDTOBUILD).count()
  1

  >>> cprov_archive.getBuildRecords(build_state=BuildStatus.NEEDSBUILD).count()
  0

And finally build records target to a given pocket:

  >>> from canonical.lp.dbschema import PackagePublishingPocket
  >>> cprov_archive.getBuildRecords(
  ...     pocket=PackagePublishingPocket.RELEASE).count()
  4

  >>> cprov_archive.getBuildRecords(
  ...     pocket=PackagePublishingPocket.UPDATES).count()
  0

All the attributes can be combined in order to refine the result:

  >>> cprov_archive.getBuildRecords(
  ...     name='ice',
  ...     build_state=BuildStatus.FULLYBUILT,
  ...     pocket=PackagePublishingPocket.RELEASE).count()
  1


== Publisher configuration provider ==

IArchive has a method to provide a modified Publisher Configuration (see
lib/archivepublisher/config.py), which provides the right paths for its
publication according to the given distribution:

  >>> # cprov 20061127: We should *never* be able to change a PPA
  >>> # distribution, however 'ubuntu' is not prepared for publication, thus
  >>> # we have to override the PPA to 'ubuntutest' in order to perform the
  >>> # tests.

  >>> from zope.security.proxy import removeSecurityProxy
  >>> ubuntutest = getUtility(IDistributionSet)['ubuntutest']

  >>> naked_cprov_archive = removeSecurityProxy(cprov_archive)
  >>> naked_cprov_archive.distribution = ubuntutest
  >>> pubconfig = naked_cprov_archive.getPubConfig()

The base Archive publication location is set in the current Launchpad
configuration file:

  >>> from canonical.config import config
  >>> pubconfig.distroroot == config.personalpackagearchive.root
  True

Then, the archive topology will follow:

<PPA_BASE_DIR>/<PERSONNAME>/<DISTRIBUTION>

  >>> pubconfig.archiveroot
  u'/var/tmp/ppa.test/cprov/ubuntutest'

  >>> pubconfig.poolroot
  u'/var/tmp/ppa.test/cprov/ubuntutest/pool'

  >>> pubconfig.distsroot
  u'/var/tmp/ppa.test/cprov/ubuntutest/dists'

Path not used in *personal* archives publication workflow are set to
None, so they won't get created:

  >>> pubconfig.overrideroot is None
  True
  >>> pubconfig.cacheroot is None
  True
  >>> pubconfig.miscroot is None
  True

Usual methods from Publisher Configuration are preserved:

  >>> pubconfig.distroSeriesNames()
  ['breezy-autotest', 'hoary-test']

  >>> pubconfig.archTagsForSeries('breezy-autotest')
  []

  >>> pubconfig.componentsForSeries('breezy-autotest')
  ['main', 'restricted', 'universe', 'multiverse']


== IArchiveSet Utility ==

This utility provides useful methods to deal with IArchive in other
parts of the system.

  >>> archive_set = getUtility(IArchiveSet)

A new Archive can be created by passing a name and an owner

  >>> name16 = getUtility(IPersonSet).getByName('name16')
  >>> sandbox_archive = archive_set.new(
  ...    purpose=ArchivePurpose.PPA, owner=name16)

  >>> verifyObject(IArchive, sandbox_archive)
  True

  >>> sandbox_archive.owner == name16
  True

IArchiveSet.ensure will either return an existing archive, or make a new
one if there is no existing one.

  >>> name12 = getUtility(IPersonSet).getByName('name12')
  >>> name12_archive = archive_set.ensure(
  ...     owner=name12, distribution=None, purpose=ArchivePurpose.PPA,
  ...     description="Holy mackerel")
  >>> name12_archive.description
  u'Holy mackerel'

Repeating this call with a different description results in the archive
created above returned instead of a new one:

  >>> name12_archive = archive_set.ensure(
  ...     owner=name12, distribution=None, purpose=ArchivePurpose.PPA,
  ...     description="Flaming trousers")
  >>> name12_archive.description
  u'Holy mackerel'

An archive is also associated with a distribution.  This can be found on
the distribution property.  The default distribution is "ubuntu":

  >> sandbox_archive.distribution.name
  u'ubuntu'

An Archive can be retrieved via IPerson.archive property:

  >>> name16.archive == sandbox_archive
  True

IArchiveSet.getByDistroPurpose retrieves an IArchive given a distribution
and an ArchivePurpose:

  >>> from canonical.lp.dbschema import ArchivePurpose
  >>> commercial_archive = getUtility(IArchiveSet).getByDistroPurpose(
  ...     ubuntutest, ArchivePurpose.COMMERCIAL)
  >>> commercial_archive.description
  u'Commercial archive'


IArchive.archive_url will return a URL for the archive that the builder can
use to retrieve files from it.

  >>> commercial_archive.archive_url
  u'http://launchpad.dev/ubuntutest-commercial'

  >>> sandbox_archive.archive_url
  u'http://ppa.launchpad.dev/name16/ubuntu'

  >>> getUtility(IArchiveSet).getByDistroPurpose(
  ...     ubuntutest, ArchivePurpose.PRIMARY).archive_url
  u'http://launchpad.dev/ubuntutest'


The publisher config for COMMERCIAL contains only 'commercial' in its
components.  This prevents non-commercial being published in the commercial
archive.

  >>> comm_pubconf = removeSecurityProxy(
  ...     commercial_archive.getPubConfig())
  >>> for distroseries in comm_pubconf._distroserieses.keys():
  ...     print set(comm_pubconf._distroserieses[distroseries]['components'])
  set(['commercial'])
  set(['commercial'])


IArchive.allowUpdatesToReleasePocket returns whether the archive is allowed
to publish to the RELEASE pocket no matter what state the distroseries is in.

  >>> commercial_archive.allowUpdatesToReleasePocket()
  True

  >>> cprov_archive.allowUpdatesToReleasePocket()
  True

  >>> getUtility(IArchiveSet).getByDistroPurpose(
  ...     ubuntutest, ArchivePurpose.PRIMARY).allowUpdatesToReleasePocket()
  False

Iteration over the own utility is performed against all archives,
including the *main_archives*:

  >>> main_archives = 0
  >>> ppas = 0
  >>> for archive in archive_set:
  ...     if archive.owner is None:
  ...          main_archives += 1
  ...     else:
  ...          ppas += 1
  >>> main_archives, ppas
  (9, 5)
