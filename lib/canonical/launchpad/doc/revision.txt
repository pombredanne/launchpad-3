= Bazaar Revisions =

Branches are collection of revisions, and a revision can exist independently
from any branch. Revisions are created automatically by scanning branches, they
have no creation interface and Launchpad cannot create or modify them.

== Creating revisions ==

XXX: Revisions have an owner attribute. As a convention, the owner of a
Revision is always the Launchpad Admins team. The Revision.owner attribute will
be removed soon. -- DavidAllouche 2005-10-08

>>> from canonical.launchpad.database import Person
>>> admins = Person.selectOneBy(name='admins')

The creator of a revision is identified by a RevisionAuthor. A RevisionAuthor
is not a person because that is only an informational attribute, and even if we
trust it, there's really no simple way to map that reliably to persons.

>>> from canonical.launchpad.database import RevisionAuthor
>>> author = RevisionAuthor(name='ddaa@localhost')
>>> author.name
u'ddaa@localhost'

The log-body of a revision is the commit message of that revision.

>>> log_body_1 = "Initial import"
>>> log_body_2 = "Fix froboizer"

The revision-id is the globally unique id used by the revision control. For
native Bazaar2 revisions it's a GUID, for Bazaar2 imports it's a string based
on the Arch revision id.

>>> revision_id_1 = "Arch-1:ddaa@example.com/junk--devel--base-0"
>>> revision_id_2 = "some random unique string, we do not care, really"

The revision_date is the commit date recorded by the revision control system,
while the date_created is the time when the database record was created.

>>> from datetime import datetime
>>> from pytz import UTC
>>> date = datetime(2005, 3, 8, 12, 0, tzinfo=UTC)
>>> from canonical.launchpad.database import Revision
>>> revision_1 = Revision(owner=admins, log_body=log_body_1,
...     revision_author=author, revision_id=revision_id_1, revision_date=date)

== Ancestors ==

Bazaar revisions can have multiple ancestors, the "leftmost" ancestor is the
revision that was used as a base when committing, other ancestors are used to
record merges. All revisions except initial imports have at least one ancestor.

Ancestors are accessed through their revision_id without using a foreign key so
we can represent revision whose at least one ancestor is a ghost revision.

>>> revision_2 = Revision(owner=admins, log_body=log_body_2,
...     revision_author=author, revision_id=revision_id_2, revision_date=date)

>>> from canonical.launchpad.database import RevisionParent
>>> rev2_parent = RevisionParent(sequence=0, revision=revision_2,
...                              parent_id=revision_1.revision_id)

== Revision numbers ==

Revisions are associated to branches through the RevisionNumber table. A given
revision may appear in different positions in different branches thanks to
Bazaar2 converge-on-pull logic.

>>> from canonical.launchpad.database import Branch
>>> branch = Branch.get(1)
>>> branch.revision_history.count()
0

RevisionNumber does not have a creation interface, like for Revision, new
records are only created by a non-zope batch job.

>>> from canonical.launchpad.database import RevisionNumber
>>> junkcode_sql = Branch.selectOneBy(name='junkcode')
>>> rev_no_1 = RevisionNumber(sequence=1, branch=branch, revision=revision_1)
>>> rev_no_2 = RevisionNumber(sequence=2, branch=branch, revision=revision_2)
>>> rev_no_1.branch == rev_no_2.branch == branch
True

=== Deleting Revision Numbers ===

If a branch gets overwritten or some revisions get uncommitted,
Launchpad's view of the branch will differ from the actual state of
the branch.

If the bzr branch now has fewer revisions than Launchpad's view of the
branch, then some of RevisionNumber records will need to be removed.
The branch scanner does this by calling destroySelf() on the excess
records.

As the branch scanner manipulates branch information through the zope
interfaces, the RevisionNumber objects in question will be security
wrapped.  It is important that they be deletable in this state.

First, get a branch via the IPersonSet utility:

  >>> from zope.component import getUtility
  >>> from canonical.launchpad.interfaces import IPersonSet
  >>> person = getUtility(IPersonSet).getByEmail('test@canonical.com')
  >>> branch = person.getBranch(None, 'junk.dev')


The branch in question is security proxied, and has 6 revisions:

  >>> type(branch)
  <type 'zope.security._proxy._Proxy'>
  >>> branch.revision_count
  6


We can get the last revision from the branch:

  >>> [revno_6] = branch.latest_revisions(1)
  >>> revno_6.sequence
  6
  >>> revno_6.branch == branch
  True
  >>> print revno_6.revision.revision_id
  foo@localhost-20051031170357-1301ad6d387feb23


The revision number object is security proxied, so that you can't
access attributes not exposed in its interface:

  >>> type(revno_6)
  <type 'zope.security._proxy._Proxy'>
  >>> revno_6.forbidden_attribute
  Traceback (most recent call last):
    ...
  ForbiddenAttribute: ('forbidden_attribute', <RevisionNumber at ...>)


This revision can then be deleted in the same way the branch scanner
does, leaving only 5 revisions in the branch:

  >>> branch.truncateHistory(6)
  True
  >>> branch.revision_count
  5


Note that while the RevisionNumber object linking the revision to the
branch has been destroyed, the associated revision object is not (it
may be referenced by some other branch):

  >>> from canonical.launchpad.interfaces import IBranchSet, IRevisionSet
  >>> revision = getUtility(IRevisionSet).getByRevisionId(
  ...     'foo@localhost-20051031170357-1301ad6d387feb23')
  >>> print revision.revision_id
  foo@localhost-20051031170357-1301ad6d387feb23


== IRevisionSet.new() ==

Revision objects can be created using the IRevisionSet utility.
Associated RevisionAuthor and RevisionParent objects will be created
as needed.

  >>> revision = getUtility(IRevisionSet).new(
  ...     revision_id='rev-3',
  ...     log_body='commit message',
  ...     revision_date=date,
  ...     revision_author='ddaa@localhost',
  ...     owner=admins,
  ...     parent_ids=['rev-1', 'rev-2'])
  >>> print revision.revision_id
  rev-3
  >>> print revision.log_body
  commit message
  >>> print revision.revision_date
  2005-03-08 12:00:00+00:00
  >>> print revision.revision_author.name
  ddaa@localhost
  >>> for parent_id in revision.parent_ids:
  ...     print parent_id
  rev-1
  rev-2

== IRevisionSet.getRevisionHistoryForBranch() ==

  >>> branch = getUtility(IBranchSet).get(21)
  >>> for rev_id in getUtility(IRevisionSet).getRevisionHistoryForBranch(branch):
  ...     print rev_id
  test@canonical.com-20051031165248-6f1bb97973c2b4f4
  test@canonical.com-20051031165338-5f2f3d6b10bb3bf0
  foo@localhost-20051031165758-48acedf2b6a2e898
  foo@localhost-20051031170008-098959758bf79803
  foo@localhost-20051031170239-5fce7d6bd3f01efc
  foo@localhost-20051031170357-1301ad6d387feb23
  