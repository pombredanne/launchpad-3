= Facets and menus =

An object has a facetmenu if it can be adapted to IFacetMenu.

=== Construct an example url hierarchy ===

    >>> from canonical.launchpad.webapp import nearest_menu, canonical_url
    >>> from canonical.launchpad.interfaces import (
    ...     ICanonicalUrlData, IFacetMenu, IApplicationMenu, ILink,
    ...     ILinkData, IFacetLink
    ...     )
    >>> from zope.interface import implements, directlyProvides, Interface
    >>> from zope.component import queryAdapter

    >>> class ObjectThatHasUrl:
    ...     implements(ICanonicalUrlData)
    ...     def __init__(self, name, parent):
    ...         self.name = name  # Used in examples later.
    ...         self.path = name  # See ICanonicalUrlData.
    ...         self.inside = parent  # See ICanonicalUrlData.

Here's a useful class that we can use to effectively register adapters for
an object, without actually using adapter registries.  This comes from
PEP-246.

    >>> class Conformable:
    ...     adapt_to = None
    ...     def setAdapter(self, interface, object):
    ...         self.adapt_to = (interface, object)
    ...     def __conform__(self, protocol):
    ...         if self.adapt_to is not None:
    ...             interface, object = self.adapt_to
    ...             if interface.extends(protocol, strict=False):
    ...                 return object(self)
    ...         return None

    >>> class ExampleContentObject(ObjectThatHasUrl, Conformable):
    ...     pass

Let's make three objects that together make a url hierarchy:

  (the root)/sesamestreet/number73

    >>> root = ExampleContentObject('', None)
    >>> street = ExampleContentObject('sesamestreet', root)
    >>> house = ExampleContentObject('number73', street)
    >>> canonical_url(house)
    'http://localhost:8086/sesamestreet/number73'
    >>> canonical_url(street)
    'http://localhost:8086/sesamestreet'


=== Test nearest_menu ===

Right now, none of our example objects have a facet menu.

    >>> nearest_menu(root, IFacetMenu) is None
    True
    >>> nearest_menu(street, IFacetMenu) is None
    True
    >>> nearest_menu(house, IFacetMenu) is None
    True

We'll make the 'street' object be conformable to IFacetMenu.  Making an object
be conformable to IFacetMenu is one way of making the object adaptable to
IFacetMenu.  Another way would be to provide an adapter.

    >>> class ExampleFacetMenu(list):
    ...     implements(IFacetMenu)
    ...     def __init__(self, context):
    ...         list.__init__(self, ['foo', 'bar', 'baz'])
    ...         self.context = context

    >>> street.setAdapter(IFacetMenu, ExampleFacetMenu)
    >>> IFacetMenu(street).__class__ is ExampleFacetMenu
    True
    >>> nearest_menu(root, IFacetMenu) is None
    True
    >>> nearest_menu(street, IFacetMenu).__class__ is ExampleFacetMenu
    True
    >>> nearest_menu(house, IFacetMenu).__class__ is ExampleFacetMenu
    True


== The Link class ==

When you define a menu using class based on FacetMenu, you return Link
objects from its methods.  The Link class is very simple.  You provide
it with a target and some text for the link.  Other optional arguments
are some summary text, the name of an icon, and a boolean saying whether
the link is enabled.  Defaults are to have no summary, no icon, and
to be enabled.

Exactly how a disabled link appears on a page is up to the page template
code that renders links.  Typically, disabled links will be hidden, or
may be shown "greyed out" and not clickable.

These are the attributes that Link instances provide for setting by the
software developer who defines menus.  When you define a Link, you are
defining an object that provides ILinkData.

There are other attributes that are set by the menu infrastructure, and
are used when a Link is rendered in a page.  These attributes are defined
in ILink and IFacetLink.

    >>> from canonical.launchpad.webapp import Link
    >>> no_summary_link = Link('target', 'text')
    >>> ILinkData.providedBy(no_summary_link)
    True
    >>> no_summary_link.target
    'target'
    >>> no_summary_link.text
    'text'
    >>> print no_summary_link.summary
    None
    >>> print no_summary_link.icon
    None
    >>> no_summary_link.enabled
    True

    >>> link = Link('target', 'text', 'summary', icon='icon', enabled=False)
    >>> ILinkData.providedBy(link)
    True
    >>> link.target
    'target'
    >>> link.text
    'text'
    >>> link.summary
    'summary'
    >>> link.icon
    'icon'
    >>> link.enabled
    False


The menu infrastructure adapts a Link instance to ILink (for context and
application menus) and IFacetLink (for facet menus).  This (morally speaking)
allows the menu infrastructure to set the 'name', 'url', 'linked' and
(in the case of IFacetLink) 'selected' attributes of the link.

By using separate interfaces, and by adapting, we keep the different
responsibilities of links clearly separated, and leave room for making
clean changes and optimisations later.

Let's make a couple of Link instances, adapt them to ILink and IFacetLink,
and show that getting and setting the appropriate attributes works.

We use two separate links because setting attributes on the adapted link
will change the data in the underlying link instance.  We may change this
later, to allow some links to be precomputed or shared, but right now,
link instances are meant to be created freshly on each request, and not
shared or reused.

    >>> link1 = Link('target', 'text', 'summary', icon='icon', enabled=False)
    >>> link2 = Link('target', 'text', 'summary', icon='icon', enabled=False)

    >>> for menu_link in ILink(link1), IFacetLink(link2):
    ...     print menu_link.name, menu_link.url, menu_link.linked
    ...     menu_link.name = 'name'
    ...     menu_link.url = 'url'
    ...     menu_link.linked = False
    ...     print menu_link.name, menu_link.url, menu_link.linked
    None None True
    name url False
    None None True
    name url False

    >>> facet_menu_link = IFacetLink(link2)
    >>> facet_menu_link.selected
    False
    >>> facet_menu_link.selected = True
    >>> facet_menu_link.selected
    True


== The FacetMenu class ==

    >>> from canonical.launchpad.webapp import FacetMenu

FacetMenu is meant to be used as a base-class for writing your own IFacetMenu
classes.  Here's what happens when you use it on its own.

    >>> bad_idea_menu = FacetMenu(object())
    >>> for link in bad_idea_menu.iterlinks():
    ...     pass
    Traceback (most recent call last):
    ...
    AssertionError: Subclasses of FacetMenu must provide self.links

So, we must test FacetMenu by making our own menu subclass.  We'll just call
our menu 'Facets'.  One thing missing from this class is the 'usedfor'
declaration.  We need to use this in practice because we need to know how to
register our menu as an adapter.  For this part of the test, we won't worry
about that.

The FacetMenu class also allows you to specify the 'defaultlink' attribute,
which is None by default (for no default link), but can be the name of the
default link for this menu.

    >>> class Facets(FacetMenu):
    ...
    ...     links = ['foo', 'bar']
    ...
    ...     def foo(self):
    ...         target = '+foo'
    ...         text = 'Foo'
    ...         return Link(target, text)
    ...
    ...     def bar(self):
    ...         target = '+bar'
    ...         text = 'Bar'
    ...         summary = (
    ...             'More explanation about Bar of %s' % self.context.name)
    ...         return Link(target, text, summary)

Now, we can make an instance of this Facets class, with a contextobject to
show that its methods can access `self.context`.

    >>> facetmenu = Facets(street)

We can go through each attribute of each of the links, checking that they
are as we expect.

    >>> for link in facetmenu.iterlinks():
    ...     print '--- link %s ---' % link.name
    ...     for attrname in sorted(IFacetLink.names(all=True)):
    ...         print '%s: %s' % (attrname, getattr(link, attrname))
    --- link foo ---
    enabled: True
    icon: None
    linked: True
    name: foo
    selected: False
    summary: None
    target: +foo
    text: Foo
    url: http://localhost:8086/sesamestreet/+foo
    --- link bar ---
    enabled: True
    icon: None
    linked: True
    name: bar
    selected: False
    summary: More explanation about Bar of sesamestreet
    target: +bar
    text: Bar
    url: http://localhost:8086/sesamestreet/+bar


== Enabled links and disabled links ==

Often, we want to make a facet menu that uses the standard facet menu links,
but with only some of them enabled.

To do this, we make a new menu class that extends an existing one.  We need
to provide a set of link names that are to be enabled.  All other links will
be disabled.

    >>> class OnlySomeEnabledFacets(Facets):
    ...
    ...     enable_only = ['foo']

Now, we can make an instance of this class.

    >>> onlysomeenabledfacetmenu = OnlySomeEnabledFacets(street)

We look at the links, to make sure they are as we expect.

    >>> for link in onlysomeenabledfacetmenu.iterlinks():
    ...     print '--- link %s ---' % link.name
    ...     print 'enabled:', link.enabled
    --- link foo ---
    enabled: True
    --- link bar ---
    enabled: False

If 'enable_only' contains a link name that does not appear in 'links', we
should get a warning.

    >>> class UnknownEnableOnlyFacets(Facets):
    ...
    ...     enable_only = ['bar', 'quux']

Now, we can make an instance of this class.

    >>> unknownenableonlyfacets = UnknownEnableOnlyFacets(street)

    >>> for link in unknownenableonlyfacets.iterlinks():
    ...     print '--- link %s ---' % link.name
    ...     print 'enabled:', link.enabled
    Traceback (most recent call last):
    ...
    AssertionError: Links in 'enable_only' not found in 'links': quux


== The MenuLink and FacetLink adapter classes ==

The menus system needs to be able to adapt ILinkData objects to objects
that provide ILink or IFacetLink.  The menus system needs to be able to
set the 'enabled', 'name', 'url', 'linked, and for IFacetLink, 'selected'
attributes, but without altering the underlying ILinkData object.

    >>> somelink = Link('target', 'text', 'summary', icon='icon')
    >>> ILinkData.providedBy(somelink)
    True
    >>> ILink.providedBy(somelink)
    False
    >>> adaptedtolink = ILink(somelink)
    >>> ILink.providedBy(adaptedtolink)
    True

It is important we don't get a facetlink here, so that we can do views on links
if we want to, and have distinct views on facet and other links.

    >>> IFacetLink.providedBy(adaptedtolink)
    False

    >>> adaptedtolink.target
    'target'
    >>> adaptedtolink.text
    'text'
    >>> adaptedtolink.summary
    'summary'
    >>> adaptedtolink.icon
    'icon'
    >>> adaptedtolink.enabled
    True
    >>> adaptedtolink.enabled = False
    >>> adaptedtolink.enabled
    False
    >>> somelink.enabled
    True


== How do we tell which link from a facetmenu is the selected one? ==

A link will be selected if its name is passed to the facet menu's
iterlinks method, or otherwise, if its name is the defaultlink.

    >>> for link in facetmenu.iterlinks(selectedfacetname='bar'):
    ...     print '--- link %s ---' % link.name
    ...     print 'selected:', link.selected
    --- link foo ---
    selected: False
    --- link bar ---
    selected: True

When a link name is passed in, but no link of that name is in the menu, it
is not an error.  No link is selected.

    >>> for link in facetmenu.iterlinks(selectedfacetname='nosuchname'):
    ...     print '--- link %s ---' % link.name
    ...     print 'selected:', link.selected
    --- link foo ---
    selected: False
    --- link bar ---
    selected: False

No selected link is given, but the default is 'foo', so 'foo' will be selected.

    >>> facetmenu.defaultlink = 'foo'
    >>> for link in facetmenu.iterlinks():
    ...     print '--- link %s ---' % link.name
    ...     print 'selected:', link.selected
    --- link foo ---
    selected: True
    --- link bar ---
    selected: False

Now, 'foo' is still the default, but 'bar' has been selected.  So only 'bar'
will be selected.

    >>> for link in facetmenu.iterlinks(selectedfacetname='bar'):
    ...     print '--- link %s ---' % link.name
    ...     print 'selected:', link.selected
    --- link foo ---
    selected: False
    --- link bar ---
    selected: True

We still have 'foo' as the default.  This time, 'nosuchlink' has been selected.
As there is no such link, nothing will be selected.

    >>> for link in facetmenu.iterlinks(selectedfacetname='nosuchlink'):
    ...     print '--- link %s ---' % link.name
    ...     print 'selected:', link.selected
    --- link foo ---
    selected: False
    --- link bar ---
    selected: False


== How do we tell whether a link from a facetmenu is linked? ==

A link is linked if its link's target differs from the current URL.

To test this, we need a dummy request object that provides `getURL()`.

    >>> # Needed for getApplicationURL()
    >>> from zope.publisher.interfaces.http import IHTTPApplicationRequest
    >>> # Needed for registering a default view name.
    >>> from zope.publisher.interfaces.browser import IBrowserRequest
    >>> class DummyRequest:
    ...     implements(IHTTPApplicationRequest, IBrowserRequest)
    ...
    ...     def __init__(self, url, query=None, url1=None):
    ...         self.url = url
    ...         self.query = query
    ...         self.url1 = url1  # returned from getURL(1)
    ...
    ...     def getURL(self, level=0):
    ...         assert 0 <= level <=1, 'level must be 0 or 1'
    ...         if level == 0:
    ...             return self.url
    ...         else:
    ...             assert self.url1 is not None, (
    ...                 'Must set url1 in DummyRequest')
    ...             return self.url1
    ...
    ...     def getApplicationURL(self):
    ...         # Just the http://place:port part, so stop at the 3rd slash.
    ...         return '/'.join(self.url.split('/', 3)[:3])
    ...
    ...     def get(self, key, default=None):
    ...         assert key == 'QUERY_STRING', 'we handle only QUERY_STRING'
    ...         if self.query is None:
    ...             return default
    ...         else:
    ...             return self.query

    >>> from canonical.launchpad.webapp.menu import Url

The following request is for a url that is different from all of the facet
menu links for 'sesamestreet'.  So, all links will be linked.

    >>> request = Url('http://localhost:8086/sesamestreet/+xxx')
    >>> facets = Facets(street)
    >>> for link in facets.iterlinks(request):
    ...     print link.url, link.linked
    http://localhost:8086/sesamestreet/+foo True
    http://localhost:8086/sesamestreet/+bar True

This next request is for +foo, but with a query string.  So, both links will
still be linked.

XXX
    >>> request = DummyRequest(
    ...     'http://localhost:8086/sesamestreet/+foo', query="123")
    >>> facets = Facets(street)
    >>> for link in facets.iterlinks():
    ...     print link.url, link.linked
    http://localhost:8086/sesamestreet/+foo True
    http://localhost:8086/sesamestreet/+bar True

Next, we'll use the link +bar.  The +bar link will not be linked.

    >>> request = Url('http://localhost:8086/sesamestreet/+bar')
    >>> facets = Facets(street)
    >>> for link in facets.iterlinks(request):
    ...     print link.url, link.linked
    http://localhost:8086/sesamestreet/+foo True
    http://localhost:8086/sesamestreet/+bar False

Now, we use +bar with a trailing slash.  The +bar link will still be not
linked.

    >>> request = Url('http://localhost:8086/sesamestreet/+bar/')
    >>> facets = Facets(street)
    >>> for link in facets.iterlinks(request):
    ...     print link.url, link.linked
    http://localhost:8086/sesamestreet/+foo True
    http://localhost:8086/sesamestreet/+bar False


We need to test the case when we have a link with a blank target.
This will be the common case for default links.

    >>> class BlankTargetTestFacets(Facets):
    ...
    ...     links = Facets.links + ['baz']
    ...     defaultlink = 'foo'
    ...
    ...     def foo(self):
    ...         target = ''
    ...         text = 'Foo'
    ...         return Link(target, text)
    ...
    ...     def baz(self):
    ...         target = '+baz'
    ...         text = 'Baz'
    ...         summary = (
    ...             'More explanation about Baz of %s' % self.context.name)
    ...         return Link(target, text, summary)

    >>> request = Url('http://localhost:8086/sesamestreet/+bar')
    >>> facets = BlankTargetTestFacets(street)
    >>> for link in facets.iterlinks(request):
    ...     print link.url, link.linked
    http://localhost:8086/sesamestreet/ True
    http://localhost:8086/sesamestreet/+bar False
    http://localhost:8086/sesamestreet/+baz True


XXX The following stuff needs testing properly, using the TALES code, which
    does the actual defaultViewName lookup and URL calculations.
    SteveAlexander, 2005-09-12

Sometimes, we need to take into account the default view name for an object.
Let's say that the default view name for an IStreet is '+foo'.  This is
the common case where the overview link is the default view name.

    >> class IStreet(Interface):
    ..     """A street."""
    >> directlyProvides(street, IStreet)
    >> from zope.app.tests import ztapi
    >> ztapi.setDefaultViewName(IStreet, '+foo')
    >> from zope.component import getDefaultViewName
    >> getDefaultViewName(street, request)
    '+foo'

So, in this example, the first link should not be 'linked' because it is
equivalent to the default view name for a street.  The TALES infrastructure
actually calculates a shortened URL for this case.
XXX: need to test this with the TALES stuff.
     SteveAlexander, 2005-09-12

    >>> request = Url('http://localhost:8086/sesamestreet/')
    >>> facets = BlankTargetTestFacets(street)
    >>> for link in facets.iterlinks(request):
    ...     print link.url, link.linked
    http://localhost:8086/sesamestreet/ False
    http://localhost:8086/sesamestreet/+bar True
    http://localhost:8086/sesamestreet/+baz True


=== Absolute url targets ===

We will want to make links with absolute urls as targets.

Absolute urls can be made with a full url, including the host part, or as
a url path beginning with '/'.

Sometimes the target will be within Launchpad.  Other times, the link will be
to an external site.

When the link is to an external site, we'll want to note that as an attribute
of the Link.  That will come as a future enhancement.  External links will
always be linked.

When the link is to a page in Launchpad, we need to treat it the same as
a normal relative link.  That is, we need to compute 'linked' and 'selected'
as for relative links.  The usual use-case is computing an absolute link
to a page inside launchpad using canonical_url.  In this case, the host and
protocol part of the url will be the same for the canonical_url as for the
current request.  This is what we will use to see if we have a link to a
page within Launchpad.

    >>> class AbsoluteUrlTargetTestFacets(FacetMenu):
    ...
    ...     links = ['foo', 'bar', 'baz', 'spoo']
    ...
    ...     def foo(self):
    ...         target = ''
    ...         text = 'Foo'
    ...         return Link(target, text)
    ...
    ...     def bar(self):
    ...         target = 'ftp://barlink.example.com/barbarbar'
    ...         text = 'External bar'
    ...         return Link(target, text)
    ...
    ...     def baz(self):
    ...         target = 'http://localhost:8086/sesamestreet/+baz'
    ...         text = 'Baz'
    ...         return Link(target, text)
    ...
    ...     def spoo(self):
    ...         target = '/sesamestreet/+spoo'
    ...         text = 'Spoo'
    ...         return Link(target, text)

The url1 is needed because we still have the defaultViewName registered from
earlier in this doctest.

    >>> canonical_url(street)
    'http://localhost:8086/sesamestreet'

    >>> request = Url('http://localhost:8086/sesamestreet')

    >>> facets = AbsoluteUrlTargetTestFacets(street)
    >>> for link in facets.iterlinks(request):
    ...     print link.url, link.linked
    http://localhost:8086/sesamestreet/ False
    ftp://barlink.example.com/barbarbar True
    http://localhost:8086/sesamestreet/+baz True
    http://localhost:8086/sesamestreet/+spoo True


== Application Menus ==

Application menus are defined for a context object for a particular named
Facet menu item.  The name of the facet menu item used is whichever facet
is selected from the nearest context object that has an IFacetMenu adapter.

Defining an ApplicationMenu works like defining a FacetMenu, except we
also need to say what facet menu item it is for.

    >>> from canonical.launchpad.webapp import ApplicationMenu

ApplicationMenu is meant to be used as a base-class for writing your own
IApplicationMenu classes.  Here's what happens when you use it on its own.

    >>> bad_idea_menu = ApplicationMenu(object())
    >>> for link in bad_idea_menu.iterlinks():
    ...     pass
    Traceback (most recent call last):
    ...
    AssertionError: Subclasses of ApplicationMenu must provide self.links

So, we must test ApplicationMenu by making our own menu subclass.  We'll
just call our menu 'FooApplicationMenu' as we intend it to be used when the
'foo' facet is selected.  Two things missing from this class are the 'usedfor'
declaration and the 'facet' declaration.  We need to use these in practice
because we need to know how to register our menu as an adapter.  For this
part of the test, we won't worry about that.

    >>> class FooApplicationMenu(ApplicationMenu):
    ...
    ...     links = ['first']
    ...     facet = 'foo'
    ...
    ...     def first(self):
    ...         target = '+first'
    ...         text = 'First menu'
    ...         return Link(target, text)

Now, we can make an instance of this FooApplicationMenu class.  We should
really be using some link text that shows that its methods can access
`self.context`. That's a minor TODO item.

    >>> housefooappmenu = FooApplicationMenu(house)

We can go through each attribute of each of the links, checking that they
are as we expect.

    >>> for link in housefooappmenu.iterlinks():
    ...     print '--- link %s ---' % link.name
    ...     for attrname in sorted(ILink.names(all=True)):
    ...         print '%s: %s' % (attrname, getattr(link, attrname))
    --- link first ---
    enabled: True
    icon: None
    linked: True
    name: first
    summary: None
    target: +first
    text: First menu
    url: http://localhost:8086/sesamestreet/number73/+first


== Registering menus in ZCML ==

First, we define a couple of interfaces, and put them in the
canonical.launchpad.ftests module.

    >>> class IThingHavingFacets(Interface):
    ...     pass
    >>> import canonical.launchpad.ftests
    >>> getattr(canonical.launchpad.ftests, 'IThingHavingFacets', None) is None
    True
    >>> canonical.launchpad.ftests.IThingHavingFacets = IThingHavingFacets
    >>> IThingHavingFacets.__module__ = 'canonical.launchpad.ftests'

    >>> class IThingHavingApplicationMenus(Interface):
    ...     pass
    >>> import canonical.launchpad.ftests
    >>> getattr(canonical.launchpad.ftests, 'IThingHavingApplicationMenus',
    ...         None) is None
    True
    >>> canonical.launchpad.ftests.IThingHavingApplicationMenus = \
    ...     IThingHavingApplicationMenus
    >>> IThingHavingApplicationMenus.__module__ = 'canonical.launchpad.ftests'

Next, we define a FacetMenu subclass to be used for IThingHavingFacets, using a
usedfor class attribute to say what interface it is to be registered for, and
put it too in the canonical.launchpad.ftests module.

    >>> class FacetsForThing(Facets):
    ...     usedfor = IThingHavingFacets

    >>> getattr(canonical.launchpad.ftests, 'FacetsForThing', None) is None
    True
    >>> canonical.launchpad.ftests.FacetsForThing = FacetsForThing


And likewise for an application menu registered for
IThingHavingApplicationMenus.

    >>> class FooMenuForThing(FooApplicationMenu):
    ...     usedfor = IThingHavingApplicationMenus
    ...     facet = 'foo'

    >>> getattr(canonical.launchpad.ftests, 'FooMenuForThing', None) is None
    True
    >>> canonical.launchpad.ftests.FooMenuForThing = FooMenuForThing


Now, check that we have no IFacetMenu adapter for an IThingHavingFacets object.

    >>> class SomeThing:
    ...     implements(IThingHavingFacets)
    >>> something_with_facets = SomeThing()
    >>> IFacetMenu(something_with_facets, None) is None
    True

We also need to check that we have no IApplicationMenu adapter named 'foo' for
an IThingHavingApplicationMenus object.

    >>> class SomeOtherThing:
    ...     implements(IThingHavingApplicationMenus)
    >>> something_with_appmenus = SomeOtherThing()
    >>> queryAdapter(something_with_appmenus, IApplicationMenu, 'foo') is None
    True

    >>> from zope.configuration import xmlconfig
    >>> zcmlcontext = xmlconfig.string("""
    ... <configure xmlns:browser="http://namespaces.zope.org/browser">
    ...   <include file="lib/canonical/launchpad/webapp/meta.zcml" />
    ...   <browser:menus
    ...       module="canonical.launchpad.ftests"
    ...       classes="FacetsForThing FooMenuForThing"
    ...       />
    ... </configure>
    ... """)

    >>> menu = IFacetMenu(something_with_facets)
    >>> menu.context = something_with_facets
    >>> menu.__class__ is FacetsForThing
    True
    >>> menu = queryAdapter(something_with_appmenus, IApplicationMenu, 'foo')
    >>> menu.context = something_with_appmenus
    >>> menu.__class__ is FooMenuForThing
    True

The browser:menus directive also makes security declarations for the adapters.


== Using menus in page templates ==

We use menus in page templates by using the `thing/menu:typeofmenu`
TALES namespace.

First, let's look at `thing/menu:facet`.  What this does is to look up
nearest_menu(thing, IFacetMenu), getting an IFacetMenu adapter from it.
Then, it sets the request attribute from the interaction, and returns the
adapter.

    >>> from canonical.launchpad.ftests import test_tales

    >>> participation = DummyRequest(
    ...     'http://localhost:8086/sesamestreet/+bar')
    >>> participation.interaction = None
    >>> login(ANONYMOUS, participation)

    >>> class View:
    ...     __launchpad_facetname__ = 'bar'
    ...
    >>> view = View()

    >>> street.adapt_to = None
    >>> directlyProvides(street, IThingHavingFacets)
    >>> house.adapt_to = None
    >>> directlyProvides(house, IThingHavingApplicationMenus)
    >>> links = test_tales('CONTEXTS/menu:facet', context=house, view=view)
    >>> for link in links:
    ...     print link.url, link.selected
    http://localhost:8086/sesamestreet/+foo False
    http://localhost:8086/sesamestreet/+bar True


The result of `house/menu:application` will be empty at the moment, because
we registered only one application menu for a house, against 'foo'.  The
'bar' facet is the one selected, so we don't get any application menu.

    >>> menu = test_tales('CONTEXTS/menu:application', context=house, view=view)
    >>> list(menu)
    []

Now, if we change the view's __launchpad_facetname__ so that the 'foo' facet
is selected, we get a couple of menus.

    >>> view.__launchpad_facetname__ = 'foo'
    >>> links = test_tales(
    ...     'CONTEXTS/menu:application', context=house, view=view)
    >>> for link in links:
    ...     print link.url
    http://localhost:8086/sesamestreet/number73/+first

When there is no menu for a thing, we get an empty iterator.

    >>> menu = test_tales('CONTEXTS/menu:facet', context=root, view=view)
    >>> list(menu)
    []
    >>> menu = test_tales('CONTEXTS/menu:application', context=root, view=view)
    >>> list(menu)
    []


== Cleaning up ==

We're done testing the zcml, so we can clean up the canonical.launchpad.ftests
module.

    >>> del canonical.launchpad.ftests.FacetsForThing
    >>> del canonical.launchpad.ftests.FooMenuForThing
    >>> del canonical.launchpad.ftests.IThingHavingFacets
    >>> del canonical.launchpad.ftests.IThingHavingApplicationMenus


== The Url class ==

    >>> from canonical.launchpad.webapp.menu import Url
    >>> url1 = Url('http://localhost/foo/bar?123')
    >>> url2 = Url('http://localhost/foo/bar/baz')
    >>> url2.is_inside(url1)
    True

These next two are equivalent, so the answer should be True, even through
the "outside" one is shorter than the "inside" one.

    >>> url1 = Url('http://localhost/foo/bar/')
    >>> url2 = Url('http://localhost/foo/bar')
    >>> url2.is_inside(url1)
    True

The next two are exactly the same.  We consider a url to be inside itself.

    >>> url1 = Url('http://localhost/foo/bar/')
    >>> url2 = Url('http://localhost/foo/bar/')
    >>> url2.is_inside(url1)
    True

In the next case, the string of url2 starts with the string of url1.  But,
because url2 continues within the same path step, url2 is not inside url1.

    >>> url1 = Url('http://localhost/foo/ba')
    >>> url2 = Url('http://localhost/foo/bar')
    >>> url2.is_inside(url1)
    False

Here, url2 is url1 plus an extra path step.  So, url2 is inside url1.

    >>> url1 = Url('http://localhost/foo/bar/')
    >>> url2 = Url('http://localhost/foo/bar/baz')
    >>> url2.is_inside(url1)
    True

