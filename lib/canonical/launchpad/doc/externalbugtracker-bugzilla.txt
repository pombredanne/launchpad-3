ExternalBugTracker: Bugzilla
============================

An ExternalBugtracker is used to talk to remote bug trackers and update bug
watches. This document describes how the Bugzilla implementation of
ExternalBugTracker works.

Basics
------

The class that implements EBT is called Bugzilla. It works differently
depending on which version of Bugzilla it is talking to. If it's a
version we can't parse, UnparseableBugTrackerVersion is raised:

    >>> from canonical.launchpad.components.externalbugtracker import Bugzilla
    >>> from canonical.testing import LaunchpadZopelessLayer
    >>> txn = LaunchpadZopelessLayer.txn
    >>> external_bugzilla = Bugzilla('http://example.com/', version='A.B4')
    Traceback (most recent call last):
      ...
    UnparseableBugTrackerVersion:
    Failed to parse version 'A.B4' for http://...

Since we don't want to depend on a working network connection, we use a
slightly modified implementation.

    >>> from canonical.launchpad.ftests.externalbugtracker import TestBugzilla
    >>> from canonical.launchpad.interfaces import IBugTrackerSet
    >>> gnome_bugzilla = getUtility(IBugTrackerSet).getByName('gnome-bugzilla')
    >>> external_bugzilla = TestBugzilla(gnome_bugzilla.baseurl)
    >>> version = external_bugzilla._probe_version()
    >>> version
    (2, 20)

Status Conversion
-----------------

It contains a function for converting one of its own status to a Malone
status. Bugzilla statuses consist of two parts, the status, and the
resolution, separated by a space character. The resolution only exists
if the bug is closed:

    >>> external_bugzilla.convertRemoteStatus('UNCONFIRMED').title
    'New'
    >>> external_bugzilla.convertRemoteStatus('NEW').title
    'Confirmed'
    >>> external_bugzilla.convertRemoteStatus('ASSIGNED').title
    'In Progress'
    >>> external_bugzilla.convertRemoteStatus('REOPENED').title
    'Confirmed'
    >>> external_bugzilla.convertRemoteStatus('NEEDINFO').title
    'Incomplete'
    >>> external_bugzilla.convertRemoteStatus('NEEDINFO_REPORTER').title
    'Incomplete'
    >>> external_bugzilla.convertRemoteStatus('MODIFIED').title
    'Fix Committed'
    >>> external_bugzilla.convertRemoteStatus('UPSTREAM').title
    'Confirmed'
    >>> external_bugzilla.convertRemoteStatus('PENDINGUPLOAD').title
    'Fix Committed'
    >>> external_bugzilla.convertRemoteStatus('RESOLVED FIXED').title
    'Fix Released'
    >>> external_bugzilla.convertRemoteStatus(
    ...     'CLOSED PATCH_ALREADY_AVAILABLE').title
    'Fix Released'
    >>> external_bugzilla.convertRemoteStatus('RESOLVED CODE_FIX').title
    'Fix Released'
    >>> external_bugzilla.convertRemoteStatus('VERIFIED WONTFIX').title
    "Won't Fix"
    >>> external_bugzilla.convertRemoteStatus('CLOSED INVALID').title
    'Invalid'

If the status can't be converted an UnknownRemoteStatusError will be
returned.

    >>> external_bugzilla.convertRemoteStatus('FOO').title
    Traceback (most recent call last):
      ...
    UnknownRemoteStatusError


Updating Bug Watches
--------------------

The main use of an ExternalBugtracker is to update bug watches. This is
done through updateBugWatches(), which expects a list of bug watches to
update:

    >>> from canonical.launchpad.scripts.checkwatches import BugWatchUpdater
    >>> bug_watch_updater = BugWatchUpdater(txn)
    >>> for bug_watch in gnome_bugzilla.watches:
    ...     print "%s: %s" % (bug_watch.remotebug, bug_watch.remotestatus)
    304070: None
    3224:
    >>> bug_watch_updater.updateBugWatches(
    ...     external_bugzilla, gnome_bugzilla.watches)
    INFO:...:Updating 2 watches on http://bugzilla.gnome.org/bugs
    WARNING:...Didn't find bug u'304070' on
    http://bugzilla.gnome.org/bugs (local bugs: 15).

    >>> for bug_watch in gnome_bugzilla.watches:
    ...     print "%s: %s" % (bug_watch.remotebug, bug_watch.remotestatus)
    304070: None
    3224: RESOLVED FIXED

Let's add a handful of watches:

    >>> from canonical.launchpad.interfaces import (
    ...     IBugSet, IBugWatchSet, IPersonSet)
    >>> sample_person = getUtility(IPersonSet).getByEmail('test@canonical.com')
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bug_watch_set = getUtility(IBugWatchSet)

    >>> expected_remote_statuses = dict(
    ...     [(int(bug_watch.remotebug), bug_watch.remotestatus)
    ...      for bug_watch in gnome_bugzilla.watches])
    >>> for remote_bug_id in range(50,55):
    ...     bug_watch = bug_watch_set.createBugWatch(
    ...         bug=bug_one, owner=sample_person, bugtracker=gnome_bugzilla,
    ...         remotebug=str(remote_bug_id))
    ...     external_bugzilla.bugzilla_bugs[remote_bug_id] = (
    ...         'RESOLVED', 'FIXED')
    ...     expected_remote_statuses[remote_bug_id] = 'RESOLVED FIXED'
    >>> from canonical.launchpad.ftests import sync
    >>> for bug_watch in gnome_bugzilla.watches:
    ...     sync(bug_watch)

Set the batch threshold higher than the number of bug watches.

    >>> external_bugzilla.batch_query_threshold = 10

Then updateBugWatches() will make one request per bug watch:

    >>> external_bugzilla.trace_calls = True
    >>> bug_watch_updater.updateBugWatches(
    ...     external_bugzilla, gnome_bugzilla.watches)
    INFO:...:Updating 7 watches on http://bugzilla.gnome.org/bugs
    CALLED _postPage()
    CALLED _postPage()
    CALLED _postPage()
    CALLED _postPage()
    CALLED _postPage()
    CALLED _postPage()
    CALLED _postPage()
    WARNING:...:Didn't find bug u'304070' on
    http://bugzilla.gnome.org/bugs (local bugs: 15).

    >>> remote_statuses = dict(
    ...     [(int(bug_watch.remotebug), bug_watch.remotestatus)
    ...      for bug_watch in gnome_bugzilla.watches])
    >>> remote_statuses == expected_remote_statuses
    True

    >>> external_bugzilla.trace_calls = False

Let's add a few more watches:

    >>> expected_remote_statuses = dict(
    ...     [(int(bug_watch.remotebug), bug_watch.remotestatus)
    ...      for bug_watch in gnome_bugzilla.watches])
    >>> for remote_bug_id in range(100,300):
    ...     bug_watch = bug_watch_set.createBugWatch(
    ...         bug=bug_one, owner=sample_person, bugtracker=gnome_bugzilla,
    ...         remotebug=str(remote_bug_id))
    ...     external_bugzilla.bugzilla_bugs[remote_bug_id] = (
    ...         'ASSIGNED', '')
    ...     expected_remote_statuses[remote_bug_id] = 'ASSIGNED'
    >>> for bug_watch in gnome_bugzilla.watches:
    ...     sync(bug_watch)


Set the batch threshold very low and remove the batch size limit:

    >>> external_bugzilla.batch_query_threshold = 0
    >>> external_bugzilla.batch_size = None

Instead of issuing one request per bug watch, like was done before,
updateBugWatches() issues only one request to update all watches:

    >>> external_bugzilla.trace_calls = True
    >>> bug_watch_updater.updateBugWatches(
    ...     external_bugzilla, gnome_bugzilla.watches)
    INFO:...:Updating 207 watches on http://bugzilla.gnome.org/bugs
    CALLED _postPage()
    WARNING:...:Didn't find bug u'304070' on
    http://bugzilla.gnome.org/bugs (local bugs: 15).

    >>> remote_statuses = dict(
    ...     [(int(bug_watch.remotebug), bug_watch.remotestatus)
    ...      for bug_watch in gnome_bugzilla.watches])
    >>> remote_statuses == expected_remote_statuses
    True

    >>> external_bugzilla.trace_calls = False

updateBugWatches() updates the lastchecked attribute on the watches, so
now no bug watches are in need of updating:

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()
    >>> gnome_bugzilla.getBugWatchesNeedingUpdate(23).count()
    0

If the status isn't different, the lastchanged attribute doesn't get
updated:

    >>> import pytz
    >>> from datetime import datetime, timedelta
    >>> bug_watch = gnome_bugzilla.watches[0]
    >>> now = datetime.now(pytz.timezone('UTC'))
    >>> bug_watch.lastchanged = now - timedelta(weeks=2)
    >>> old_last_changed = bug_watch.lastchanged
    >>> bug_watch_updater.updateBugWatches(external_bugzilla, [bug_watch])
    INFO:...:Updating 1 watches on http://bugzilla.gnome.org/bugs
    >>> bug_watch.lastchanged == old_last_changed
    True

Now let's take a look at what happens when a bug watch is linked to
from a bug task.

    >>> bug_nine = getUtility(IBugSet).get(9)
    >>> thunderbird_task = bug_nine.bugtasks[0]
    >>> print thunderbird_task.status.title
    Unknown
    >>> thunderbird_task.bugwatch.remotestatus is None
    True

We don't yet support updating the importance for Bugzilla bugs, so let's set it
to some bogus value, to see that it gets set to UNKNOWN.

    >>> from canonical.launchpad.interfaces import BugTaskImportance
    >>> thunderbird_task.importance = BugTaskImportance.HIGH

We need to create a new ExternalBugtracker for the Mozilla tracker:

    >>> mozilla_bugzilla = getUtility(IBugTrackerSet).getByName(
    ...     'mozilla.org')
    >>> external_bugzilla = TestBugzilla(mozilla_bugzilla.baseurl, '2.20')
    >>> external_bugzilla.bugzilla_bugs = {1234: ('ASSIGNED', '')}

Let's update the bug watch, and see that the linked bug watch got
synced:

    >>> bug_watch_updater.updateBugWatches(
    ...     external_bugzilla, [thunderbird_task.bugwatch])
    INFO:...:Updating 1 watches on https://bugzilla.mozilla.org

    >>> bug_nine = getUtility(IBugSet).get(9)
    >>> thunderbird_task = bug_nine.bugtasks[0]
    >>> print thunderbird_task.status.title
    In Progress
    >>> print thunderbird_task.importance.title
    Unknown
    >>> print thunderbird_task.bugwatch.remotestatus
    ASSIGNED

If we change the bugtask status, it will be updated again even though
the remote status hasn't changed. This can happen if we change the
status mapping.

    >>> from canonical.launchpad.interfaces import BugTaskStatus
    >>> thunderbird_task.transitionToStatus(
    ...     BugTaskStatus.CONFIRMED,
    ...     getUtility(IPersonSet).getByName('no-priv'))
    >>> bug_watch_updater.updateBugWatches(
    ...     external_bugzilla, [thunderbird_task.bugwatch])
    INFO:...:Updating 1 watches on https://bugzilla.mozilla.org

    >>> bug_nine = getUtility(IBugSet).get(9)
    >>> thunderbird_task = bug_nine.bugtasks[0]
    >>> print thunderbird_task.status.title
    In Progress
    >>> print thunderbird_task.bugwatch.remotestatus
    ASSIGNED

If there are two bug watches, linked to different bugs, pointing to the
same remote bug, both will of course be updated.

    >>> external_bugzilla.bugzilla_bugs[42] = ('RESOLVED', 'FIXED')
    >>> bug_watch1 = bug_watch_set.createBugWatch(
    ...     bug=bug_one, owner=sample_person, bugtracker=mozilla_bugzilla,
    ...     remotebug='42')
    >>> bug_watch1_id = bug_watch1.id
    >>> bug_two = getUtility(IBugSet).get(2)
    >>> bug_watch2 = bug_watch_set.createBugWatch(
    ...     bug=bug_two, owner=sample_person, bugtracker=mozilla_bugzilla,
    ...     remotebug='42')
    >>> bug_watch2_id = bug_watch2.id
    >>> bug_watch_updater.updateBugWatches(
    ...     external_bugzilla, [bug_watch1, bug_watch2])
    INFO:...:Updating 2 watches on https://bugzilla.mozilla.org

    >>> bug_watch1 = getUtility(IBugWatchSet).get(bug_watch1_id)
    >>> print bug_watch1.remotestatus
    RESOLVED FIXED
    >>> bug_watch2 = getUtility(IBugWatchSet).get(bug_watch2_id)
    >>> print bug_watch2.remotestatus
    RESOLVED FIXED

If updateBugWatches() can't parse the XML file returned from the remote
bug tracker, an error is logged.

    >>> external_bugzilla._postPage = (
    ...     lambda self, data: '<invalid xml>')
    >>> bug_watch_updater.updateBugWatches(
    ...     external_bugzilla, [bug_watch1, bug_watch2])
    Traceback (most recent call last):
    ...
    UnparseableBugData:
    Failed to parse XML description for https://bugzilla.mozilla.org...

The error is also recorded in each bug watch's last_error_type field so that
it can be displayed to the user.

    >>> bug_watch1 = getUtility(IBugWatchSet).get(bug_watch1_id)
    >>> bug_watch1.last_error_type.title
    'Unparsable Bug'
    >>> bug_watch2 = getUtility(IBugWatchSet).get(bug_watch2_id)
    >>> bug_watch2.last_error_type.title
    'Unparsable Bug'
