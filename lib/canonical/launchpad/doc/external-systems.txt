External Systems
================

An ExternalBugtracker is used to talk to remote bug trackers and update bug
watches. This document describes how they work. They work differently
depending on which version of the bugtracker they talk to. If it's an
unknown version, UnsupportedBugTrackerVersion is raised:

    >>> from canonical.launchpad.components.externalbugtracker import Bugzilla
    >>> external_bugzilla = Bugzilla('http://foo.com/', version='2.15')
    >>> external_bugzilla.updateBugWatches([])
    Traceback (most recent call last):
      ...
    UnsupportedBugTrackerVersion: Unsupported version '2.15' for http://foo.com

Since we don't want to depend on a working network connection, we use a
slightly modified implementation.

    >>> from canonical.launchpad.ftests.externalbugtracker import TestBugzilla
    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     get_external_bugtracker)
    >>> from canonical.launchpad.interfaces import IBugTrackerSet
    >>> gnome_bugzilla = getUtility(IBugTrackerSet).getByName('gnome-bugzilla')
    >>> external_bugzilla = TestBugzilla(gnome_bugzilla.baseurl)
    >>> version = external_bugzilla._probe_version()
    >>> version
    u'2.20+'

It contains a function for converting one of its own status to a Malone
status. Bugzilla statuses consist of two parts, the status, and the
resolution, separated by a space character. The resolution only exists
if the bug is closed:

    >>> external_bugzilla.convertRemoteStatus('UNCONFIRMED').title
    'Unconfirmed'
    >>> external_bugzilla.convertRemoteStatus('NEW').title
    'Confirmed'
    >>> external_bugzilla.convertRemoteStatus('ASSIGNED').title
    'In Progress'
    >>> external_bugzilla.convertRemoteStatus('REOPENED').title
    'Confirmed'
    >>> external_bugzilla.convertRemoteStatus('NEEDINFO').title
    'Needs Info'
    >>> external_bugzilla.convertRemoteStatus('UPSTREAM').title
    'Confirmed'
    >>> external_bugzilla.convertRemoteStatus('PENDINGUPLOAD').title
    'Fix Committed'
    >>> external_bugzilla.convertRemoteStatus('RESOLVED FIXED').title
    'Fix Released'
    >>> external_bugzilla.convertRemoteStatus('VERIFIED WONTFIX').title
    'Rejected'
    >>> external_bugzilla.convertRemoteStatus('CLOSED INVALID').title
    'Rejected'

If the status can't be converted, Unkown is returned, and a warning
is logged.

    >>> external_bugzilla.convertRemoteStatus('FOO').title
    WARNING:...:Unknown Bugzilla status 'FOO' at http://bugzilla.gnome.org/bugs
    'Unknown'

UNKNOWN_REMOTE_STATUS maps to Unknown without generating a warning.

    >>> from canonical.launchpad.interfaces import UNKNOWN_REMOTE_STATUS
    >>> external_bugzilla.convertRemoteStatus(UNKNOWN_REMOTE_STATUS).title
    'Unknown'


The main use of an ExternalBugtracker is to update bug watches. This is
done through updateBugWatches(), which expects a list of bug watches to
update:

    >>> for bug_watch in gnome_bugzilla.watches:
    ...     print "%s: %s" % (bug_watch.remotebug, bug_watch.remotestatus)
    3224:
    >>> external_bugzilla.updateBugWatches(gnome_bugzilla.watches)
    >>> for bug_watch in gnome_bugzilla.watches:
    ...     print "%s: %s" % (bug_watch.remotebug, bug_watch.remotestatus)
    3224: RESOLVED FIXED

Let's add a few more watches:

    >>> from canonical.launchpad.interfaces import (
    ...     IBugSet, IBugWatchSet, IPersonSet)
    >>> sample_person = getUtility(IPersonSet).getByEmail('test@canonical.com')
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bug_watch_set = getUtility(IBugWatchSet)
    >>> expected_remote_statuses = dict(
    ...     [(int(bug_watch.remotebug), bug_watch.remotestatus)
    ...      for bug_watch in gnome_bugzilla.watches])
    >>> for remote_bug_id in range(100,300):
    ...     bug_watch = bug_watch_set.createBugWatch(
    ...         bug=bug_one, owner=sample_person, bugtracker=gnome_bugzilla,
    ...         remotebug=str(remote_bug_id))
    ...     external_bugzilla.bugzilla_bugs[remote_bug_id] = (
    ...         'ASSIGNED', '')
    ...     expected_remote_statuses[remote_bug_id] = 'ASSIGNED'

Instead of issuing one request per bug watch, like was done before,
updateBugWatches() issues only one request to update all watches:

    >>> external_bugzilla.trace_calls = True
    >>> external_bugzilla.updateBugWatches(gnome_bugzilla.watches)
    CALLED _postPage()

    >>> remote_statuses = dict(
    ...     [(int(bug_watch.remotebug), bug_watch.remotestatus)
    ...      for bug_watch in gnome_bugzilla.watches])
    >>> remote_statuses == expected_remote_statuses
    True

    >>> external_bugzilla.trace_calls = False

updateBugWatches() updates the lastchecked attribute on the watches, so
now no bug watches are in need of updating:

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()
    >>> gnome_bugzilla.getBugWatchesNeedingUpdate(23).count()
    0

If the status isn't different, the lastchanged attribute doesn't get
updated:

    >>> import pytz
    >>> from datetime import datetime, timedelta
    >>> bug_watch = gnome_bugzilla.watches[0]
    >>> now = datetime.now(pytz.timezone('UTC'))
    >>> bug_watch.lastchanged = now - timedelta(weeks=2)
    >>> old_last_changed = bug_watch.lastchanged
    >>> external_bugzilla.updateBugWatches([bug_watch])
    >>> bug_watch.lastchanged == old_last_changed
    True

Now let's take a look at what happens when a bug watch is linked to
from a bug task.

    >>> login('foo.bar@canonical.com')
    >>> bug_nine = getUtility(IBugSet).get(9)
    >>> thunderbird_task = bug_nine.bugtasks[0]
    >>> print thunderbird_task.status.title
    Unknown
    >>> thunderbird_task.bugwatch.remotestatus is None
    True

We don't yet support updating the importance for Bugzilla bugs, so let's set it
to some bogus value, to see that it gets set to UNKNOWN.

    >>> from canonical.lp.dbschema import BugTaskImportance
    >>> thunderbird_task.importance = BugTaskImportance.HIGH

We need to create a new ExternalBugtracker for the Mozilla tracker:

    >>> mozilla_bugzilla = getUtility(IBugTrackerSet).getByName(
    ...     'mozilla.org')
    >>> external_bugzilla = TestBugzilla(
    ...     mozilla_bugzilla.baseurl, version)
    >>> external_bugzilla.bugzilla_bugs = {1234: ('ASSIGNED', '')}

Let's update the bug watch, and see that the linked bug watch got
synced:

    >>> external_bugzilla.updateBugWatches([thunderbird_task.bugwatch])
    >>> print thunderbird_task.status.title
    In Progress
    >>> print thunderbird_task.importance.title
    Unknown
    >>> print thunderbird_task.bugwatch.remotestatus
    ASSIGNED

If we change the bugtask status, it will be updated again even though
the remote status hasn't changed. This can happen if we change the
status mapping.

    >>> from canonical.lp.dbschema import BugTaskStatus
    >>> thunderbird_task.transitionToStatus(BugTaskStatus.CONFIRMED)
    >>> external_bugzilla.updateBugWatches([thunderbird_task.bugwatch])
    >>> print thunderbird_task.status.title
    In Progress
    >>> print thunderbird_task.bugwatch.remotestatus
    ASSIGNED


If there are two bug watches, linked to different bugs, pointing to the
same remote bug, both will of course be updated.


    >>> external_bugzilla.bugzilla_bugs[42] = ('RESOLVED', 'FIXED')
    >>> bug_watch1 = bug_watch_set.createBugWatch(
    ...     bug=bug_one, owner=sample_person, bugtracker=mozilla_bugzilla,
    ...     remotebug='42')
    >>> bug_two = getUtility(IBugSet).get(2)
    >>> bug_watch2 = bug_watch_set.createBugWatch(
    ...     bug=bug_two, owner=sample_person, bugtracker=mozilla_bugzilla,
    ...     remotebug='42')
    >>> external_bugzilla.updateBugWatches([bug_watch1, bug_watch2])
    >>> print bug_watch1.remotestatus
    RESOLVED FIXED
    >>> print bug_watch2.remotestatus
    RESOLVED FIXED



If updateBugWatches() can't parse the XML file returned from the remote
bug tracker, an error is logged.

    >>> external_bugzilla._postPage = (
    ...     lambda self, data: '<invalid xml>')
    >>> external_bugzilla.updateBugWatches(gnome_bugzilla.watches)
    ERROR:...:Failed to parse XML description...


debbugs
-------

The debbugs syncing is done by reading from a local debbugs db, so we
can use the real class for testing as well. We just need to point it to
our test debbugs db. If we create it without specifying a db location,
it will use the config value:

    >>> from canonical.config import config
    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     DebBugs)
    >>> external_debbugs = DebBugs()
    >>> external_debbugs.db_location == config.malone.debbugs_db_location
    True

We'll initialize it with our test db though:

    >>> import os.path
    >>> from canonical.launchpad.components.ftests import __file__
    >>> test_db_location = os.path.join(
    ...     os.path.dirname(__file__), 'debbugs_db')
    >>> external_debbugs = DebBugs(db_location=test_db_location)
    >>> external_debbugs.db_location == test_db_location
    True

    >>> debbugs = getUtility(IBugTrackerSet).getByName('debbugs')
    >>> bug_watches = list(debbugs.getBugWatchesNeedingUpdate(23))
    >>> len(bug_watches)
    4

    >>> external_debbugs.updateBugWatches(bug_watches)
    >>> for bug_watch in bug_watches:
    ...     print "%s: %s" % (bug_watch.remotebug, bug_watch.remotestatus)
    280883: done grave woody security
    304014: open important
    327452: done critical patch security
    327549: open important security

The lastchecked attribute got updated for each bug watch, so no more
watches are in need of an update:

    >>> flush_database_updates()
    >>> debbugs.getBugWatchesNeedingUpdate(23).count()
    0

And the linked bugtasks got updated:

    >>> bugtasks = []
    >>> for bug_watch in bug_watches:
    ...     bugtasks += list(bug_watch.bugtasks)
    >>> for bugtask in sorted(bugtasks, key=lambda bugtask: bugtask.id):
    ...     print bugtask.bug.id, bugtask.targetname, bugtask.status.title,
    ...     print bugtask.importance.title
    1 mozilla-firefox (Debian) Unconfirmed Unknown
    3 mozilla-firefox (Debian) Unconfirmed Unknown
    7 evolution (Debian) Fix Released Unknown

The retrieval of the remote status is done by _getRemoteStatus().

    >>> external_debbugs._getRemoteStatus('304014')
    'open important'

Sometimes the severity field is missing in the bug summary. That will
cause importance to be set to medium, equivalent to the default normal severity
in debbugs.

    >>> import email
    >>> summary = email.message_from_file(
    ...     open(os.path.join(
    ...         test_db_location, 'db-h', '01', '237001.summary')))
    >>> 'Severity' not in summary
    True

    >>> external_debbugs._getRemoteStatus('237001')
    'open normal'

If we pass a bug number that doesn't exist in the debbugs db,
BugNotFound is raised.

    >>> external_debbugs._getRemoteStatus('42')
    Traceback (most recent call last):
    ...
    BugNotFound: 42

If we pass a non-integer bug id, InvalidBugId is raised.

    >>> external_debbugs._getRemoteStatus('foo')
    Traceback (most recent call last):
    ...
    InvalidBugId: Debbugs bug number not an integer: foo

Let's take closer look at the status conversion. Debbugs has basically
only two statuses, 'open' and 'done', so in order to get a more fine
grained mapping to Malone statuses, we need to look at the tags as
well. The most simple mapping is from 'done', in debbugs it means that
the bug has been fixed and a new package with the fix has been
uploaded, so it maps to 'Fix Released.

    >>> print external_debbugs.convertRemoteStatus('done normal').title
    Fix Released

If the status is simply 'open', we map it to 'Unconfirmed', since
there's no way of knowing if the bug is confirmed or not.

    >>> print external_debbugs.convertRemoteStatus('open normal').title
    Unconfirmed

If the 'wontfix' tag is present we map it to 'Confirmed', since even
though the bug won't be fixed, it's still a confirmed bug.

    >>> print external_debbugs.convertRemoteStatus('open normal wontfix').title
    Confirmed

If the 'moreinfo' tag is present, we map the status to 'Needs Info'.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'open normal moreinfo').title
    Needs Info

Of course, if the 'moreinfo' tag is present and the status is 'done',
we still map to 'Fix Released'.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'done normal moreinfo').title
    Fix Released

If the 'help' tag is present, it means that the maintainer is
requesting help with the bug, so it's most likely a confirmed bug.

    >>> print external_debbugs.convertRemoteStatus('open normal help').title
    Confirmed

The 'pending' tag means that a fix is about to be uploaded, so it maps
to 'Fix Committed'.

    >>> print external_debbugs.convertRemoteStatus('open normal pending').title
    Fix Committed

The 'fixed' tag means that the bug has been either fixed or work around
somehow, but there's still an issue to be solved. We map it to 'Fix
Committed', so that people can see that a fix is available.

    >>> print external_debbugs.convertRemoteStatus('open normal fixed').title
    Fix Committed

If the bug is forwarded upstream, it should mean that it's a confirmed
bug.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'open normal upstream').title
    Confirmed

And of course, if the maintainer marked the bug as 'confirmed'.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'open normal confirmed').title
    Confirmed


If it has been fixed upstream, it's definitely a confirmed bug.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'open normal fixed-upstream').title
    Confirmed

If it has been fixed in experimental, we mark it 'Fix Committed' until
the fix has reached the unstable distribution.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'open normal fixed-in-experimental').title
    Fix Committed

All other tags we map to 'Unconfirmed'.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'open normal unreproducible lfs woody').title
    Unconfirmed

If we pass in a malformed status string, we map it to 'Unknown' and
log an error.

    >>> print external_debbugs.convertRemoteStatus('open').title
    ERROR:...:Malformed debbugs status: 'open'
    Unknown

UNKNOWN_REMOTE_STATUS maps to Unknown.

    >>> print external_debbugs.convertRemoteStatus(UNKNOWN_REMOTE_STATUS).title
    Unknown

checkwatches.py
---------------

This updating and syncing of bug watches is done by a cronscript. We
can't test it properly, since we don't yet have a mock HTTP server we
can use for testing, so let's make sure that it doesn't try to contact
any external servers.

    >>> from canonical.database.sqlbase import cursor
    >>> from canonical.database.constants import UTC_NOW
    >>> cur = cursor()
    >>> cur.execute("UPDATE BugWatch SET lastchecked=%s" % UTC_NOW)
    >>> import transaction
    >>> transaction.commit()

    >>> import subprocess
    >>> process = subprocess.Popen(
    ...     'cronscripts/checkwatches.py', shell=True,
    ...     stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.PIPE)
    >>> (out, err) = process.communicate()
    >>> out
    ''
    >>> process.returncode
    0

    >>> print err
    INFO    creating lockfile
    INFO    No watches to update on http://bugs.debian.org
    INFO    No watches to update on http://bugzilla.gnome.org/bugs
    INFO    No watches to update on https://bugzilla.mozilla.org/
    INFO    Skipping updating Ubuntu Bugzilla watches.

