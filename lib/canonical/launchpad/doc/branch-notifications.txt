= Email Notifications for Branches =

Only subscribers get email notifications.  If the owner/author
of the branch want to receive emails, then they need to subscribe
to the branch.

There are two situations where emails are sent out for branches:
 - when a user modifies the state of the branch object using the UI
 - when the branch scanner scans new revisions in the branches history

== Email Format ==

All branch notification emails use a standard email template.

The functions that handle the emailing of the branch email messages are
in the mailnotification module.

The email_branch_modified_notifications function loads the email template
(branch-modified.txt), and sets the subject based on the branch
details.  The function also adds the header X-Launchpad-Branch,
and populates the footer of the email with the branch details,
the reason why the user is getting the email, and a link that
they can click on to unsubscribe or edit their email notification
settings.  The function also sends the email to the list of
recipients.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     BranchSubscriptionNotificationLevel, BranchSubscriptionDiffSize,
    ...     IBranchSet)
    >>> from canonical.launchpad.mail import stub
    >>> from canonical.launchpad.mailnotification import (
    ...     email_branch_modified_notifications)
    >>> from canonical.launchpad.tests.mail_helpers import pop_notifications
    >>> branch = getUtility(IBranchSet).getByUniqueName('~name12/firefox/main')
    >>> subscription = branch.subscribe(
    ...     branch.owner,
    ...     BranchSubscriptionNotificationLevel.FULL,
    ...     BranchSubscriptionDiffSize.WHOLEDIFF)
    >>> email_branch_modified_notifications(
    ...     branch, ['test@canonical.com'], 'foo@canonical.com',
    ...     'The contents.', branch.getNotificationRecipients())

    >>> notifications = pop_notifications()
    >>> len(notifications)
    1
    >>> branch_notification = notifications[0]
    >>> print branch_notification['To']
    test@canonical.com
    >>> print branch_notification['From']
    foo@canonical.com
    >>> print branch_notification['Subject']
    [Branch ~name12/firefox/main] Mozilla Firefox Mainline
    >>> print branch_notification['X-Launchpad-Branch']
    ~name12/firefox/main
    >>> print branch_notification['X-Launchpad-Message-Rationale']
    Subscriber
    >>> notification_body = branch_notification.get_payload()
    >>> print notification_body #doctest: -NORMALIZE_WHITESPACE
    The contents.
    <BLANKLINE>
    --
    Mozilla Firefox Mainline
    http://code.launchpad.dev/~name12/firefox/main
    <BLANKLINE>
    You are receiving this branch notification because you are subscribed to it.
    To unsubscribe from this branch go to http://code.launchpad.dev/~name12/fir=
    efox/main/+edit-subscription.
    <BLANKLINE>
    >>> branch.unsubscribe(branch.owner)


== Subscriptions ==

When users subscribe to the branch, they specify which branch
modified events they want to receive email for.  This is one of the
following four options:
  * No email
  * Attribute notifications only
  * Revision notifications only
  * All notifications

If the user specifies that they are interested in receiving revision
notifications, then they can additionally specify a size limit for the
diff that is generated by comparing the new branch revision to the
previous one.  The size limit is one of the following:
  * No diff
  * 500 lines
  * 1000 lines
  * 5000 lines
  * Send the entire diff

    >>> from canonical.launchpad.interfaces import IBranch, IPersonSet
    >>> personset = getUtility(IPersonSet)

    >>> branch.subscribe(
    ...     personset.getByEmail('no-priv@canonical.com'),
    ...     BranchSubscriptionNotificationLevel.NOEMAIL,
    ...     BranchSubscriptionDiffSize.NODIFF)
    <BranchSubscription ...

    >>> branch.subscribe(
    ...     personset.getByEmail('test@canonical.com'),
    ...     BranchSubscriptionNotificationLevel.ATTRIBUTEONLY,
    ...     BranchSubscriptionDiffSize.NODIFF)
    <BranchSubscription ...

    >>> branch.subscribe(
    ...     personset.getByEmail('carlos@canonical.com'),
    ...     BranchSubscriptionNotificationLevel.DIFFSONLY,
    ...     BranchSubscriptionDiffSize.NODIFF)
    <BranchSubscription ...

    >>> branch.subscribe(
    ...     personset.getByEmail('jeff.waugh@ubuntulinux.com'),
    ...     BranchSubscriptionNotificationLevel.DIFFSONLY,
    ...     BranchSubscriptionDiffSize.HALFKLINES)
    <BranchSubscription ...

    >>> branch.subscribe(
    ...     personset.getByEmail('celso.providelo@canonical.com'),
    ...     BranchSubscriptionNotificationLevel.DIFFSONLY,
    ...     BranchSubscriptionDiffSize.ONEKLINES)
    <BranchSubscription ...

    >>> branch.subscribe(
    ...     personset.getByEmail('daf@canonical.com'),
    ...     BranchSubscriptionNotificationLevel.DIFFSONLY,
    ...     BranchSubscriptionDiffSize.FIVEKLINES)
    <BranchSubscription ...

    >>> branch.subscribe(
    ...     personset.getByEmail('mark@hbd.com'),
    ...     BranchSubscriptionNotificationLevel.FULL,
    ...     BranchSubscriptionDiffSize.WHOLEDIFF)
    <BranchSubscription ...

Team are subscribed in the same way.

    >>> branch.subscribe(
    ...     personset.getByName('launchpad'),
    ...     BranchSubscriptionNotificationLevel.FULL,
    ...     BranchSubscriptionDiffSize.WHOLEDIFF)
    <BranchSubscription ...

And to make sure we have them:

    >>> for subscription in branch.subscriptions:
    ...     print subscription.person.name
    no-priv
    name12
    carlos
    jdub
    cprov
    daf
    sabdfl
    launchpad

The getNotificationRecipients method returns an instance of
NotificationRecipientSet (see doc/notification_recipient_set.txt).  The
NotificationRecipientSet is used to remember why the email recipients
are getting the emails.  The branch object adds all the branch
subscriptions to the NotificationRecipientSet and sets the reason to be
the subscription itself.  The subscription itself is passed through as
the reason, since not every subscriber gets every type of email.  The
filtering of the subscriptions are done in the notification handlers.
The header value is also set and sent as part of the message in the
email header X-Launchpad-Message-Rationale.  The
X-Launchpad-Message-Rationale header is added to email sent by launchpad
to allow email filtering.

    >>> recipients = branch.getNotificationRecipients()
    >>> interested_levels = (
    ...     BranchSubscriptionNotificationLevel.DIFFSONLY,
    ...     BranchSubscriptionNotificationLevel.FULL)
    >>> for email in recipients.getEmails():
    ...     subscription, header = recipients.getReason(email)
    ...     if subscription.notification_level in interested_levels:
    ...         print email, subscription.max_diff_lines.title, header
    carlos@canonical.com          Don't send diffs  Subscriber
    celso.providelo@canonical.com 1000 lines        Subscriber
    daf@canonical.com             5000 lines        Subscriber
    foo.bar@canonical.com         Send entire diff  Subscriber @launchpad
    jeff.waugh@ubuntulinux.com    500 lines         Subscriber
    mark@hbd.com                  Send entire diff  Subscriber


== Limiting the size of diff received by email ==

    # A helper function to print out the To header and
    # email body
    >>> def print_to_and_body(email):
    ...     print 'To: %s\n%s' % (email['To'], email.get_payload())

We need to create some sufficiently large diffs to compare against.

    >>> diff = '\n'.join([str(value) for value in xrange(6000)])
    >>> message = 'Test message.\n'

    >>> from canonical.launchpad.mailnotification import (
    ...     send_branch_revision_notifications)

Send the revision notifications.

    >>> send_branch_revision_notifications(
    ...     branch, 'no-reply@canonical.com', message, diff)
    >>> notifications = pop_notifications()
    >>> len(notifications)
    6
    >>> print_to_and_body(notifications.pop(0))
    To: carlos@canonical.com
    Test message.
    <BLANKLINE>
    <BLANKLINE>
    --...

    >>> print_to_and_body(notifications.pop(0))
    To: celso.providelo@canonical.com
    Test message.
    <BLANKLINE>
    The size of the diff (6000 lines) is larger than your specified limit of 10=
    00 lines...

    >>> print_to_and_body(notifications.pop(0))
    To: daf@canonical.com
    Test message.
    <BLANKLINE>
    The size of the diff (6000 lines) is larger than your specified limit of 50=
    00 lines...

Foo Bar is getting the email due to his membership in the Launchpad
developers team, and as such the unsubscription link is to the team
subscription.

    >>> print_to_and_body(notifications.pop(0))
    To: foo.bar@canonical.com
    Test message.
    <BLANKLINE>
    0 1 ... 5999...
    To unsubscribe from this branch go to http://code.launchpad.dev/~name12/fir=
    efox/main/+subscription/launchpad.

    >>> print_to_and_body(notifications.pop(0))
    To: jeff.waugh@ubuntulinux.com
    Test message.
    <BLANKLINE>
    The size of the diff (6000 lines) is larger than your specified limit of 50=
    0 lines...

Mark's unsubscription link is to his personal branch subscription.

    >>> print_to_and_body(notifications.pop(0))
    To: mark@hbd.com
    Test message.
    <BLANKLINE>
    0 1 ... 5999...
    To unsubscribe from this branch go to http://code.launchpad.dev/~name12/fir=
    efox/main/+edit-subscription.

And just to be sure, lets create one with 800 lines.

    >>> diff = '\n'.join([str(value) for value in xrange(800)])
    >>> send_branch_revision_notifications(
    ...     branch, 'no-reply@canonical.com', message, diff)
    >>> notifications = pop_notifications()
    >>> len(notifications)
    6

Still just the log message for carlos:

    >>> print_to_and_body(notifications.pop(0))
    To: carlos@canonical.com
    Test message.
    <BLANKLINE>
    <BLANKLINE>
    --...

Diff for celso:

    >>> print_to_and_body(notifications.pop(0))
    To: celso.providelo@canonical.com
    Test message.
    <BLANKLINE>
    0 1 ... 799...

Diff for daf:

    >>> print_to_and_body(notifications.pop(0))
    To: daf@canonical.com
    Test message.
    <BLANKLINE>
    0 1 ... 799...

Everything for Foo Bar:

    >>> print_to_and_body(notifications.pop(0))
    To: foo.bar@canonical.com
    Test message.
    <BLANKLINE>
    0 1 ... 799...

Limit hit for jeff:

    >>> print_to_and_body(notifications.pop(0))
    To: jeff.waugh@ubuntulinux.com
    Test message.
    <BLANKLINE>
    The size of the diff (800 lines) is larger than your specified limit of 500=
     lines...

And everything for mark:

    >>> print_to_and_body(notifications.pop(0))
    To: mark@hbd.com
    Test message.
    <BLANKLINE>
    0 1 ... 799...

Unsubscribe everybody.

    >>> for subscription in branch.subscriptions:
    ...     branch.unsubscribe(subscription.person)
    >>> len(list(branch.subscriptions))
    0


== Group subscriptions ==

If a group is subscribed the emails are sent to the members of that team.
If an individual is also subscribed to the branch, then the setting
the individual specifies overrides any setting that they would receive
from a team registration.

If a team is registered, and that team has an email address assigned,
then that email address is used for the notifications.

    >>> branch.subscribe(
    ...     personset.getByEmail('david.allouche@canonical.com'),
    ...     BranchSubscriptionNotificationLevel.DIFFSONLY,
    ...     BranchSubscriptionDiffSize.HALFKLINES)
    <BranchSubscription ...

    >>> branch.subscribe(
    ...     personset.getByName('vcs-imports'),
    ...     BranchSubscriptionNotificationLevel.DIFFSONLY,
    ...     BranchSubscriptionDiffSize.FIVEKLINES)
    <BranchSubscription ...

The ubuntu-team has an email address supplied (support@ubuntu.com), so
that is used rather than the email addresses of the seven members.

    >>> branch.subscribe(
    ...     personset.getByName('ubuntu-team'),
    ...     BranchSubscriptionNotificationLevel.DIFFSONLY,
    ...     BranchSubscriptionDiffSize.ONEKLINES)
    <BranchSubscription ...

    >>> recipients = branch.getNotificationRecipients()
    >>> for email in recipients.getEmails():
    ...     subscription, header = recipients.getReason(email)
    ...     if subscription.notification_level in interested_levels:
    ...         print email, subscription.max_diff_lines.title, header
    david.allouche@canonical.com  500 lines   Subscriber
    foo.bar@canonical.com        5000 lines   Subscriber @vcs-imports
    robertc@robertcollins.net    5000 lines   Subscriber @vcs-imports
    support@ubuntu.com           1000 lines   Subscriber @ubuntu-team


== Attribute emails ==

    # Another helper function to print out the To, From and Subject headers
    # and the email body
    >>> def print_email_details(email):
    ...     print 'To: %s\nFrom: %s\nSubject: %s\n%s' % (
    ...         email['To'], email['From'], email['Subject'], email.get_payload())

It is the form infrastructure that fires off the SQLObjectModifedEvent,
so we'll fake that bit here.  The page tests will check the emails
sent.

Resubscribe our test user.

    >>> branch.subscribe(
    ...     personset.getByEmail('test@canonical.com'),
    ...     BranchSubscriptionNotificationLevel.ATTRIBUTEONLY,
    ...     BranchSubscriptionDiffSize.NODIFF)
    <BranchSubscription ...

    >>> from zope.event import notify
    >>> from canonical.launchpad.event import SQLObjectModifiedEvent
    >>> from canonical.launchpad.webapp.snapshot import Snapshot

    >>> login('test@canonical.com')
    >>> before_modification = Snapshot(branch, providing=IBranch)

    >>> branch.whiteboard = 'This is the new whiteboard'

Even though the branch notification emails don't use the field
names just now, we'll pass them through anyway

    >>> notify(SQLObjectModifiedEvent(branch,
    ...                               before_modification,
    ...                               ['whiteboard']))

    >>> notifications = pop_notifications()
    >>> len(notifications)
    1
    >>> print_email_details(notifications.pop())
    To: test@canonical.com
    From: Sample Person <test@canonical.com>
    Subject: [Branch ~name12/firefox/main] Mozilla Firefox Mainline
    Whiteboard changed to:
    <BLANKLINE>
    This is the new whiteboard
    <BLANKLINE>
    --
    Mozilla Firefox Mainline
    http://code.launchpad.dev/~name12/firefox/main
    <BLANKLINE>
    You are receiving this branch notification because you are subscribed to it.
    To unsubscribe from this branch go to http://code.launchpad.dev/~name12/fir=
    efox/main/+edit-subscription.


The fields that are currently tracked with the delta, and cause
an email to be sent out are:
  * name
  * title
  * summary
  * url
  * whiteboard
  * lifecycle_status

So, if all the UI fields are changed, you should get an email that looks
something like this:

    >>> branch = getUtility(IBranchSet).getByUniqueName('~name12/firefox/main')

    >>> before_modification = Snapshot(branch, providing=IBranch)

    >>> branch.name = 'new-name'
    >>> branch.title = 'New title'
    >>> branch.summary = 'A new summary'
    >>> branch.url = 'http://example.com/foo'
    >>> branch.whiteboard = 'This is a multiline whiteboard\n' \
    ...  'with a really long line that should invoke the splitting ' \
    ...  'algorithm in the mail wrapper to make sure that the line ' \
    ...  'is not too long'
    >>> from canonical.launchpad.interfaces import BranchLifecycleStatus
    >>> branch.lifecycle_status = BranchLifecycleStatus.DEVELOPMENT
    >>> updated_fields = ['name','title','summary','url','whiteboard','lifecycle_status']
    >>> notify(SQLObjectModifiedEvent(
    ...     branch, before_modification, updated_fields))

    >>> notifications = pop_notifications()
    >>> len(notifications)
    1
    >>> print_email_details(notifications.pop())
    To: test@canonical.com
    From: Sample Person <test@canonical.com>
    Subject: [Branch ~name12/firefox/new-name] New title
        Name: main =3D> new-name
        Title: Mozilla Firefox Mainline =3D> New title
        Branch URL: http://bazaar.example.com/mozilla@arch.ubuntu.com/mozilla--=
    MAIN--0 =3D> http://example.com/foo
        Status: New =3D> Development
    <BLANKLINE>
    Summary changed to:
    <BLANKLINE>
    A new summary
    <BLANKLINE>
    Whiteboard changed to:
    <BLANKLINE>
    This is a multiline whiteboard
    with a really long line that should invoke the splitting algorithm in the m=
    ail wrapper to make sure that the line is not too long
    <BLANKLINE>
    --
    New title
    http://code.launchpad.dev/~name12/firefox/new-name
    <BLANKLINE>
    You are receiving this branch notification because you are subscribed to it.
    To unsubscribe from this branch go to http://code.launchpad.dev/~name12/fir=
    efox/new-name/+edit-subscription.


== Unicode in emails ==

All the text fields of a branch are considered unicode, so the email
must also handle the unicode.

    >>> before_modification = Snapshot(branch, providing=IBranch)

    >>> branch.title = u'New \ua000 title '
    >>> branch.summary = u'A new \ua000 summary'
    >>> updated_fields = ['title','summary']
    >>> notify(SQLObjectModifiedEvent(
    ...     branch, before_modification, updated_fields))

    >>> notifications = pop_notifications()
    >>> len(notifications)
    1
    >>> print_email_details(notifications.pop())
    To: test@canonical.com
    From: Sample Person <test@canonical.com>
    Subject: =?utf-8?q?=5BBranch_=7Ename12/firefox/new-name=5D_New_=EA=80=80_ti?=
             =?utf-8?q?tle_?=
        Title: New title =3D> New =EA=80=80 title =
    <BLANKLINE>
    Summary changed to:
    <BLANKLINE>
    A new =EA=80=80 summary
    <BLANKLINE>
    --
    New =EA=80=80 title =
    http://code.launchpad.dev/~name12/firefox/new-name
    <BLANKLINE>
    You are receiving this branch notification because you are subscribed to it.
    To unsubscribe from this branch go to http://code.launchpad.dev/~name12/fir=
    efox/new-name/+edit-subscription.


== Blank titles ==

If the title of the branch is None then the subject line just contains
the unique name in square brackets.  This happens if the branch was created
by pushing the branch to launchpad.

    >>> branch.title = None
    >>> before_modification = Snapshot(branch, providing=IBranch)

    >>> branch.name = 'foo'
    >>> updated_fields = ['name']
    >>> notify(SQLObjectModifiedEvent(
    ...     branch, before_modification, updated_fields))

    >>> notifications = pop_notifications()
    >>> len(notifications)
    1
    >>> print_email_details(notifications.pop())
    To: test@canonical.com
    From: Sample Person <test@canonical.com>
    Subject: [Branch ~name12/firefox/foo]
        Name: new-name =3D> foo
    <BLANKLINE>
    --
    <BLANKLINE>
    http://code.launchpad.dev/~name12/firefox/foo
    <BLANKLINE>
    You are receiving this branch notification because you are subscribed to it.
    To unsubscribe from this branch go to http://code.launchpad.dev/~name12/fir=
    efox/foo/+edit-subscription.


== Overwriting Nones  ==

If the branch was created by pushing, then some of the fields are None.
We don't want to show None in the email, so we show (not set) instead.

    >>> before_modification = Snapshot(branch, providing=IBranch)

    >>> branch.title = 'A new title'
    >>> updated_fields = ['title']
    >>> notify(SQLObjectModifiedEvent(
    ...     branch, before_modification, updated_fields))

    >>> notifications = pop_notifications()
    >>> len(notifications)
    1
    >>> print_email_details(notifications.pop())
    To: test@canonical.com
    From: Sample Person <test@canonical.com>
    Subject: [Branch ~name12/firefox/foo] A new title
        Title: (not set) =3D> A new title
    <BLANKLINE>
    --
    A new title
    http://code.launchpad.dev/~name12/firefox/foo
    <BLANKLINE>
    You are receiving this branch notification because you are subscribed to it.
    To unsubscribe from this branch go to http://code.launchpad.dev/~name12/fir=
    efox/foo/+edit-subscription.
