= Source Packages =

A source package is a thing from which binary packages are built, to then be
installed using a package management tool like apt-get or rpm. One named source
package in a distro may be used to build several different named binary
packages, on one or more architectures. One named binary package in a distro
may have been built from more than one named source package (e.g. a different
source package may have been used to build "foo" on i386 vs. "foo" on ppc.)


== Named Source Package ==

The are various metadata we're interested in collecting about a bundle of code
used to build binary packages for installation in a particular distro series.
One such thing is the name of that bundle of code. This is abstracted into a
separate SourcePackageName table.

Accessing source package names is done through the ISourcePackageNameSet
utility.

The ISourcePackageNameSet utility is accessed in the usual fashion:

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import ISourcePackageNameSet
    >>> sourcepackagenameset = getUtility(ISourcePackageNameSet)

To retrieve a specific source package name, use ISourcePackageNameSet.get:

    >>> firefox = sourcepackagenameset.get(1)
    >>> print firefox.name
    mozilla-firefox

To retrieve a specific source package name by its name, use
ISourcePackageNameSet.queryByName:

    >>> firefox = sourcepackagenameset.queryByName("mozilla-firefox")
    >>> print firefox.name
    mozilla-firefox

If the package doesn't exist, queryByName returns None:

    >>> biscoito = sourcepackagenameset.queryByName("biscoito")
    >>> print biscoito
    None


=== Latest published component ===

The 'latest_published_component' attribute indicates the component where
the package was last published.

    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> ubuntu_warty = ubuntu.getSeries('warty')
    >>> firefox_warty = ubuntu_warty.getSourcePackage('mozilla-firefox')
    >>> firefox_warty.latest_published_component.name
    u'main'

It's worth noting that the returned component is the one in the latest
publishing record, not the component where the package was last
uploaded. After a package has been uploaded, and a SourcePackageRelease
record has been created, the component may be changed. The
SourcePackageRelease will still have the same component as the original
upload, even though it gets changed in the publishing record.

    # Remove the security proxy to access the non-public
    # _getPublishingHistory method.
    >>> from zope.security.proxy import removeSecurityProxy
    >>> publishing_history = removeSecurityProxy(
    ...     firefox_warty)._getPublishingHistory()
    >>> for publishing in publishing_history:
    ...     print publishing.status.name, publishing.component.name
    PENDING main
    PUBLISHED main

    >>> from canonical.database.sqlbase import flush_database_caches
    >>> from canonical.launchpad.database import Component
    >>> from canonical.launchpad.database import (
    ...     SecureSourcePackagePublishingHistory)
    >>> from canonical.launchpad.ftests import syncUpdate

    # SourcePackagePublishingHistory is just a view on
    # SecureSourcePackagePublishingHistory with some rows removed, so need
    # to update the SecureSourcePackagePublishingHistory table.
    >>> latest_publishing = SecureSourcePackagePublishingHistory.get(
    ...     publishing_history[-1].id)
    >>> universe = Component.byName('universe')
    >>> latest_publishing.component = universe
    >>> syncUpdate(latest_publishing)
    >>> flush_database_caches()

    >>> for release in firefox_warty.distinctreleases:
    ...     print release.component.name
    main
    >>> firefox_warty.latest_published_component.name
    u'universe'

Only PUBLISHED records are considered when looking the latest published
component. If there are no PUBLISHED records, None is returned.

    >>> from canonical.launchpad.interfaces import PackagePublishingStatus

    >>> latest_publishing.status = PackagePublishingStatus.SUPERSEDED
    >>> syncUpdate(latest_publishing)
    >>> print firefox_warty.latest_published_component
    None

SourcePackage traversing is also provided through the available
published versions. Note that all versions ever published in the
SourcePackage context will be reachable.

    >>> pmount_hoary = ubuntu['hoary'].getSourcePackage('pmount')

    >>> for release in pmount_hoary.releases:
    ...     print release.title, release.publishing_history[0].status.name
    pmount 0.1-1 (source) in Ubuntu SUPERSEDED
    pmount 0.1-2 (source) in Ubuntu PUBLISHED

    >>> print pmount_hoary['0.1-1'].title
    pmount 0.1-1 (source) in ubuntu hoary

    >>> print pmount_hoary['0.1-2'].title
    pmount 0.1-2 (source) in ubuntu hoary

    >>> len(list(pmount_hoary.distinctreleases))
    2

'pmount_0.1-1' in hoary is SUPERSEDED but not yet 'removed from disk'.

    >>> secure_pub =  SecureSourcePackagePublishingHistory.get(
    ...     pmount_hoary['0.1-1'].publishing_history[0].id)
    >>> secure_pub.datesuperseded is not None
    True
    >>> secure_pub.dateremoved is None
    True

We will emulate disk-removal to ensure it will continue to be
reachable. See bug #179028 for further information.

    >>> from datetime import timedelta
    >>> secure_pub.dateremoved = secure_pub.datesuperseded + timedelta(days=1)
    >>> syncUpdate(secure_pub)

    >>> for release in pmount_hoary.releases:
    ...     print release.title, release.publishing_history[0].status.name
    pmount 0.1-1 (source) in Ubuntu SUPERSEDED
    pmount 0.1-2 (source) in Ubuntu PUBLISHED

    >>> print pmount_hoary['0.1-1'].title
    pmount 0.1-1 (source) in ubuntu hoary

    >>> len(list(pmount_hoary.distinctreleases))
    2

We will leave the pmount_0.1-1 marked as 'removed from disk' because
we do want it to affect the next test cases.


== Distribution Source Packages ==

In some cases it's useful to be able to refer to a source package at a
distribution level, independent of any particular distroseries. For
example, with Malone, a bug is usually filed on a distribution
sourcepackage (filing a bug on a specific distroseries actually means
something quite different, but is outside the scope of this document.)

To retrieve a distribution source package, use the getSourcePackage
method on a distribution:

    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, IDistributionSourcePackage)
    >>> ubuntu = getUtility(IDistributionSet).get(1)
    >>> ubuntu_firefox = ubuntu.getSourcePackage(firefox)
    >>> IDistributionSourcePackage.providedBy(ubuntu_firefox)
    True
    >>> print ubuntu_firefox.name
    mozilla-firefox
    >>> print ubuntu_firefox.title
    Source Package "mozilla-firefox" in Ubuntu Linux
    >>> print ubuntu_firefox.displayname
    mozilla-firefox in ubuntu
    >>> ubuntu_firefox.distribution == ubuntu
    True
    >>> ubuntu_firefox.sourcepackagename == firefox
    True

Distro sourcepackages know how to compare to each other:

    >>> debian = getUtility(IDistributionSet).get(3)
    >>> ubuntu_firefox_also = ubuntu.getSourcePackage(firefox)
    >>> debian_firefox = debian.getSourcePackage(firefox)

    >>> ubuntu_firefox_also == ubuntu_firefox
    True
    >>> ubuntu_firefox != debian_firefox
    True

You can search for bugs in an IDistroSourcePackage using the
.searchTasks method:

    >>> from canonical.launchpad.interfaces import (
    ...     BugTaskSearchParams, BugTaskStatus)
    >>> params = BugTaskSearchParams(
    ...     status=BugTaskStatus.NEW, user=None)
    >>> tasks = ubuntu_firefox.searchTasks(params)
    >>> tasks.count()
    1
    >>> tasks[0].id
    17


== Packaging ==

Distribution packages are linked to upstream productseries through the
packaging process. Here we test the code that links all of those.

First, let's get some useful objects from the db.

    >>> from canonical.launchpad.database import SourcePackageName
    >>> evolution = SourcePackageName.byName('evolution')
    >>> a52dec = SourcePackageName.byName('a52dec')
    >>> netapplet = SourcePackageName.byName('netapplet')
    >>> firefox = SourcePackageName.byName('mozilla-firefox')
    >>> pmount = SourcePackageName.byName('pmount')

    >>> from canonical.launchpad.database import DistroSeries
    >>> warty = DistroSeries.get(1)
    >>> hoary = DistroSeries.get(3)
    >>> sarge = DistroSeries.get(7)
    >>> sid = DistroSeries.get(8)
    >>> g2k5 = DistroSeries.get(9)

Now let's make sure that we can see a productseries for a source package.

    >>> from canonical.launchpad.database import SourcePackage
    >>> sp = SourcePackage(sourcepackagename=firefox, distroseries=hoary)
    >>> sp.productseries.name
    u'1.0'

Now we make sure there is no Packaging data for a52dec in hoary.

    >>> from canonical.launchpad.database import PackagingUtil
    >>> a52decsp = SourcePackage(sourcepackagename=a52dec,
    ...     distroseries=hoary) 
    >>> a52decsp.productseries.name
    u'trunk'

    >>> PackagingUtil().packagingEntryExists(
    ...     productseries=a52decsp.productseries,
    ...     sourcepackagename=a52dec,
    ...     distroseries=hoary)
    False

So far so good.

Now verify we still get a product for that source package, thanks to the
fact that we have Warty data for it

    >>> PackagingUtil().packagingEntryExists(
    ...     productseries=a52decsp.productseries,
    ...     sourcepackagename=a52dec,
    ...     distroseries=warty)
    True

    >>> a52decsp.productseries.product.name
    u'a52dec'

Similarly, we should be able to get the packaging information from a parent
distroseries, on the basis that a derivative is highly unlikely to change
the packaging drastically without changing the name of the package.

First, show there is no packging data for a52dec in g2k5:

    >>> PackagingUtil().packagingEntryExists(
    ...     productseries=a52decsp.productseries,
    ...     sourcepackagename=a52dec,
    ...     distroseries=g2k5)
    False 

Now verify we still get a product for that source package

    >>> sp = SourcePackage(sourcepackagename=a52dec, distroseries=g2k5)
    >>> sp.productseries.product.name
    u'a52dec'

And if we want to link that productseries to a source package in that
distroseries

    >>> from canonical.launchpad.interfaces import PackagingType
    >>> from canonical.launchpad.database import Person
    >>> foobar = Person.byName('name16')
    >>> PackagingUtil().createPackaging(
    ...     productseries=sp.productseries,
    ...     sourcepackagename=a52dec,
    ...     distroseries=g2k5,
    ...     packaging=PackagingType.PRIME,
    ...     owner=foobar)

    >>> PackagingUtil().packagingEntryExists(
    ...     productseries=sp.productseries,
    ...     sourcepackagename=a52dec,
    ...     distroseries=g2k5)
    True

Packaging entries can be deleted using PackagingUtil.deletePackaging.

    >>> PackagingUtil().deletePackaging(
    ...     productseries=sp.productseries,
    ...     sourcepackagename=a52dec,
    ...     distroseries=g2k5)
    >>> PackagingUtil().packagingEntryExists(
    ...     productseries=sp.productseries,
    ...     sourcepackagename=a52dec,
    ...     distroseries=g2k5)
    False

Linkified changelogs are available through SourcePackageReleaseView:
XXX julian 2007-09-17
This is duplicating the page test. Instead it should be more like the bug
number linkification just below.

    >>> from zope.component import queryMultiAdapter
    >>> from zope.publisher.browser import TestRequest
    >>> mock_form = {}
    >>> request = TestRequest(form=mock_form)
    >>> sp = SourcePackage(sourcepackagename=pmount, distroseries=hoary)
    >>> spr = sp['0.1-2']
    >>> spr_view = queryMultiAdapter((spr, request), name="+changelog")
    >>> print spr_view.changelog_entry
    This is a placeholder changelog for pmount 0.1-2

    >>> spr = sp['0.1-1']
    >>> spr_view = queryMultiAdapter((spr, request), name="+changelog")
    >>> print spr_view.changelog_entry
    pmount (0.1-1) hoary; urgency=low
    <BLANKLINE>
     * Fix description (Malone #1)
     * Fix debian (Debian #2000)
     * Fix warty (Warty Ubuntu #1)
    <BLANKLINE>
     -- Sample Person &lt;email address hidden&gt; Tue, 7 Feb 2006 12:10:08 +0300
    <BLANKLINE>
    <BLANKLINE>

The view will linkify bug numbers of the format "LP: #number" in the changelog
if number is a valid bug ID (also see Soyuz page tests
24-sourcepackage-changelog.txt).  The changelog() method calls a method
_linkify_bug_numbers() to do this.

Zero or more spaces may appear between the ":" and the "#".

    >>> spr_view._linkify_bug_numbers("LP: #10")
    u'LP: <a href="/bugs/10" title="another test bug">#10</a>'

    >>> spr_view._linkify_bug_numbers("LP:         #10")
    u'LP:         <a href="/bugs/10" title="another test bug">#10</a>'

    >>> spr_view._linkify_bug_numbers("LP:#10")
    u'LP:<a href="/bugs/10" title="another test bug">#10</a>'

    >>> spr_view._linkify_bug_numbers("LP: #999")
    'LP: <a href="/bugs/999" title="No such bug">#999</a>'

    >>> spr_view._linkify_bug_numbers("garbage")
    'garbage'

    >>> spr_view._linkify_bug_numbers("LP: #10, #7")
    u'LP: <a href="/bugs/10" title="another test bug">#10</a>,
    <a href="/bugs/7" title="A test bug">#7</a>'


== Comparing Sourcepackages ==

Lastly, note that sourcepackages know how to compare to each other:

    >>> hoary_firefox_one = SourcePackage(
    ...     sourcepackagename=firefox, distroseries=hoary)
    >>> hoary_firefox_two = SourcePackage(
    ...     sourcepackagename=firefox, distroseries=hoary)
    >>> warty_firefox = SourcePackage(
    ...     sourcepackagename=firefox, distroseries=warty)

    >>> hoary_firefox_one == hoary_firefox_two
    True
    >>> hoary_firefox_one != warty_firefox
    True
    >>> hoary_firefox_one == warty_firefox
    False

And they can be used as dictionary keys also:

    >>> hash(hoary_firefox_one) == hash(hoary_firefox_two)
    True
    >>> hash(hoary_firefox_one) != hash(warty_firefox)
    True

    >>> a_map = {}
    >>> a_map[hoary_firefox_one] = 'hoary'
    >>> a_map[warty_firefox] = 'warty'
    >>> a_map[hoary_firefox_two]
    'hoary'
    >>> a_map[warty_firefox]
    'warty'


== Direct Packagings ==

The direct packaging returns the IPackaging related to the source
package.

    >>> print sp.direct_packaging
    None
    >>> print hoary_firefox_one.direct_packaging.productseries.title
    Mozilla Firefox Series: 1.0
    >>> print warty_firefox.direct_packaging.productseries.title
    Mozilla Firefox Series: trunk

If multiple product series link to a sourcepackage, direct_packaging
returns the last packaging added:

    >>> from canonical.launchpad.interfaces import IProductSet
    >>> firefox_product = getUtility(IProductSet).getByName('firefox')
    >>> firefox_trunk = firefox_product.getSeries('trunk')
    >>> PackagingUtil().createPackaging(
    ...     sourcepackagename=firefox,
    ...     distroseries=hoary,
    ...     productseries=firefox_trunk,
    ...     packaging=PackagingType.PRIME,
    ...     owner=foobar)
    >>> print hoary_firefox_one.direct_packaging.productseries.title
    Mozilla Firefox Series: trunk


== Release History ==

    >>> len(list(hoary_firefox_one.distinctreleases))
    1

== Interface implementation ==

SourcePackageName implements IHasTranslationImports interface:

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     IHasTranslationImports)
    >>> IHasTranslationImports.providedBy(warty_firefox)
    True
    >>> verifyObject(IHasTranslationImports, warty_firefox)
    True
