= Source Packages =

A source package is a thing from which binary packages are built, to then be
installed using a package management tool like apt-get or rpm. One named source
package in a distro may be used to build several different named binary
packages, on one or more architectures. One named binary package in a distro
may have been built from more than one named source package (e.g. a different
source package may have been used to build "foo" on i386 vs. "foo" on ppc.)


== Named Source Package ==

The are various metadata we're interested in collecting about a bundle of code
used to build binary packages for installation in a particular distro series.
One such thing is the name of that bundle of code. This is abstracted into a
separate SourcePackageName table.

Accessing source package names is done through the ISourcePackageNameSet
utility.

The ISourcePackageNameSet utility is accessed in the usual fashion:

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import ISourcePackageNameSet
    >>> sourcepackagenameset = getUtility(ISourcePackageNameSet)

To retrieve a specific source package name, use ISourcePackageNameSet.get:

    >>> firefox = sourcepackagenameset.get(1)
    >>> print firefox.name
    mozilla-firefox

To retrieve a specific source package name by its name, use
ISourcePackageNameSet.queryByName:

    >>> firefox = sourcepackagenameset.queryByName("mozilla-firefox")
    >>> print firefox.name
    mozilla-firefox

If the package doesn't exist, queryByName returns None:

    >>> biscoito = sourcepackagenameset.queryByName("biscoito")
    >>> print biscoito
    None


=== Latest published component ===

The 'latest_published_component' attribute indicates the component where
the package was last published.

    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> ubuntu_warty = ubuntu.getSeries('warty')
    >>> firefox_warty = ubuntu_warty.getSourcePackage('mozilla-firefox')
    >>> firefox_warty.latest_published_component.name
    u'main'

It's worth noting that the returned component is the one in the latest
publishing record, not the component where the package was last
uploaded. After a package has been uploaded, and a SourcePackageRelease
record has been created, the component may be changed. The
SourcePackageRelease will still have the same component as the original
upload, even though it gets changed in the publishing record.

    # Remove the security proxy to access the non-public
    # _getPublishingHistory method.
    >>> from zope.security.proxy import removeSecurityProxy
    >>> publishing_history = removeSecurityProxy(
    ...     firefox_warty)._getPublishingHistory()
    >>> for publishing in publishing_history:
    ...     print publishing.status.name, publishing.component.name
    PENDING main
    PUBLISHED main

    >>> from canonical.database.sqlbase import flush_database_caches
    >>> from canonical.launchpad.database import Component
    >>> from canonical.launchpad.database import (
    ...     SecureSourcePackagePublishingHistory)
    >>> from canonical.launchpad.ftests import syncUpdate

    # SourcePackagePublishingHistory is just a view on
    # SecureSourcePackagePublishingHistory with some rows removed, so need
    # to update the SecureSourcePackagePublishingHistory table.
    >>> latest_publishing = SecureSourcePackagePublishingHistory.get(
    ...     publishing_history[-1].id)
    >>> universe = Component.byName('universe')
    >>> latest_publishing.component = universe
    >>> syncUpdate(latest_publishing)
    >>> flush_database_caches()

    >>> for release in firefox_warty.distinctreleases:
    ...     print release.component.name
    main
    >>> firefox_warty.latest_published_component.name
    u'universe'

Only PUBLISHED records are considered when looking the latest published
component. If there are no PUBLISHED records, None is returned.

    >>> from canonical.lp.dbschema import PackagePublishingStatus

    >>> latest_publishing.status = PackagePublishingStatus.REMOVED
    >>> syncUpdate(latest_publishing)
    >>> print firefox_warty.latest_published_component
    None


== Distribution Source Packages ==

In some cases it's useful to be able to refer to a source package at a
distribution level, independent of any particular distroseries. For
example, with Malone, a bug is usually filed on a distribution
sourcepackage (filing a bug on a specific distroseries actually means
something quite different, but is outside the scope of this document.)

To retrieve a distribution source package, use the getSourcePackage
method on a distribution:

    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, IDistributionSourcePackage)
    >>> ubuntu = getUtility(IDistributionSet).get(1)
    >>> ubuntu_firefox = ubuntu.getSourcePackage(firefox)
    >>> IDistributionSourcePackage.providedBy(ubuntu_firefox)
    True
    >>> print ubuntu_firefox.name
    mozilla-firefox
    >>> print ubuntu_firefox.title
    Source Package "mozilla-firefox" in Ubuntu Linux
    >>> print ubuntu_firefox.displayname
    mozilla-firefox in ubuntu
    >>> ubuntu_firefox.distribution == ubuntu
    True
    >>> ubuntu_firefox.sourcepackagename == firefox
    True

Distro sourcepackages know how to compare to each other:

    >>> debian = getUtility(IDistributionSet).get(3)
    >>> ubuntu_firefox_also = ubuntu.getSourcePackage(firefox)
    >>> debian_firefox = debian.getSourcePackage(firefox)

    >>> ubuntu_firefox_also == ubuntu_firefox
    True
    >>> ubuntu_firefox != debian_firefox
    True

You can search for bugs in an IDistroSourcePackage using the
.searchTasks method:

    >>> from canonical.launchpad.interfaces import (
    ...     BugTaskSearchParams, BugTaskStatus)
    >>> params = BugTaskSearchParams(
    ...     status=BugTaskStatus.NEW, user=None)
    >>> tasks = ubuntu_firefox.searchTasks(params)
    >>> tasks.count()
    1
    >>> tasks[0].id
    17


== Packaging ==

Distribution packages are linked to upstream productseries through the
packaging process. Here we test the code that links all of those.

First, let's get some useful objects from the db.

    >>> from canonical.launchpad.database import SourcePackageName
    >>> evolution = SourcePackageName.byName('evolution')
    >>> a52dec = SourcePackageName.byName('a52dec')
    >>> netapplet = SourcePackageName.byName('netapplet')
    >>> firefox = SourcePackageName.byName('mozilla-firefox')
    >>> pmount = SourcePackageName.byName('pmount')

    >>> from canonical.launchpad.database import DistroSeries
    >>> warty = DistroSeries.get(1)
    >>> hoary = DistroSeries.get(3)
    >>> sarge = DistroSeries.get(7)
    >>> sid = DistroSeries.get(8)
    >>> g2k5 = DistroSeries.get(9)

Now let's make sure that we can see a productseries for a source package.

    >>> from canonical.launchpad.database import SourcePackage
    >>> sp = SourcePackage(sourcepackagename=firefox, distroseries=hoary)
    >>> sp.productseries.name
    u'1.0'

Now we make sure there is no Packaging data for a52dec in hoary.

    >>> from canonical.launchpad.database import PackagingUtil
    >>> a52decsp = SourcePackage(sourcepackagename=a52dec,
    ...     distroseries=hoary) 
    >>> a52decsp.productseries.name
    u'trunk'

    >>> PackagingUtil().packagingEntryExists(
    ...     productseries=a52decsp.productseries,
    ...     sourcepackagename=a52dec,
    ...     distroseries=hoary)
    False

So far so good.

Now verify we still get a product for that source package, thanks to the
fact that we have Warty data for it

    >>> PackagingUtil().packagingEntryExists(
    ...     productseries=a52decsp.productseries,
    ...     sourcepackagename=a52dec,
    ...     distroseries=warty)
    True

    >>> a52decsp.productseries.product.name
    u'a52dec'

Similarly, we should be able to get the packaging information from a parent
distroseries, on the basis that a derivative is highly unlikely to change
the packaging drastically without changing the name of the package.

First, show there is no packging data for a52dec in g2k5:

    >>> PackagingUtil().packagingEntryExists(
    ...     productseries=a52decsp.productseries,
    ...     sourcepackagename=a52dec,
    ...     distroseries=g2k5)
    False 

Now verify we still get a product for that source package

    >>> sp = SourcePackage(sourcepackagename=a52dec, distroseries=g2k5)
    >>> sp.productseries.product.name
    u'a52dec'

And if we want to link that productseries to a source package in that
distroseries

    >>> from canonical.lp.dbschema import PackagingType
    >>> from canonical.launchpad.database import Person
    >>> foobar = Person.byName('name16')
    >>> PackagingUtil().createPackaging(
    ...     productseries=sp.productseries,
    ...     sourcepackagename=a52dec,
    ...     distroseries=g2k5,
    ...     packaging=PackagingType.PRIME,
    ...     owner=foobar)

    >>> PackagingUtil().packagingEntryExists(
    ...     productseries=sp.productseries,
    ...     sourcepackagename=a52dec,
    ...     distroseries=g2k5)
    True

Linkified changelogs are available through SourcePackageReleaseView:

    >>> from zope.component import queryView
    >>> from zope.publisher.browser import TestRequest
    >>> mock_form = {}
    >>> request = TestRequest(form=mock_form)
    >>> sp = SourcePackage(sourcepackagename=pmount, distroseries=hoary)
    >>> spr = sp['0.1-2']
    >>> spr_view = queryView(spr, "+changelog", request)
    >>> print spr_view.changelog()
    This is a placeholder changelog for pmount 0.1-2

    >>> spr = sp['0.1-1']
    >>> spr_view = queryView(spr, "+changelog", request)
    >>> print spr_view.changelog()
    pmount (<a href="../../../hoary/+source/pmount/0.1-1">0.1-1</a>) hoary; urgency=low
    <BLANKLINE>
     * Fix description (Malone #1)
     * Fix debian (Debian #2000)
     * Fix warty (Warty Ubuntu #1)
    <BLANKLINE>
     -- Sample Person &lt;test@canonical.com&gt; Tue, 7 Feb 2006 12:10:08 +0300
    <BLANKLINE>
    <BLANKLINE>

Checking handy Sourcepackage properties:

XXX cprov 20060125: it's still very primitive test but it's better
than nothing ... bug # 29659

    >>> sp.manifest.uuid
    u'e0451064-b405-4f52-b387-ebfc1a7ee298'

    >>> len(sp.releases)
    2

SQLObject won't let us use .count on the results set returned from 
distinctreleases, so we use this ugly hack:

    >>> len(list(sp.distinctreleases))
    2


== Comparing Sourcepackages ==

Lastly, note that sourcepackages know how to compare to each other:

    >>> hoary_firefox_one = SourcePackage(sourcepackagename=firefox, distroseries=hoary)
    >>> hoary_firefox_two = SourcePackage(sourcepackagename=firefox, distroseries=hoary)
    >>> warty_firefox = SourcePackage(sourcepackagename=firefox, distroseries=warty)

    >>> hoary_firefox_one == hoary_firefox_two
    True
    >>> hoary_firefox_one != warty_firefox
    True
    >>> hoary_firefox_one == warty_firefox
    False


== Direct Packagings ==

    >>> print sp.direct_packaging
    None
    >>> print hoary_firefox_one.direct_packaging.productseries.title
    Mozilla Firefox Series: 1.0
    >>> print warty_firefox.direct_packaging.productseries.title
    Mozilla Firefox Series: trunk


== Release History ==

    >>> len(list(hoary_firefox_one.distinctreleases))
    1

== Interface implementation ==

SourcePackageName implements IHasTranslationImports interface:

    >>> from zope.interface.verify import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     IHasTranslationImports)
    >>> IHasTranslationImports.providedBy(warty_firefox)
    True
    >>> verifyObject(IHasTranslationImports, warty_firefox)
    True
