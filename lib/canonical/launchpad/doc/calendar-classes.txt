
This tests the basic functionality of the calendar database classes

  >>> from canonical.launchpad.ftests.harness import \
  ...     LaunchpadFunctionalTestSetup
  >>> LaunchpadFunctionalTestSetup().setUp()

  >>> from datetime import datetime, timedelta
  >>> import pytz
  >>> UTC = pytz.timezone('UTC')

First we need to import the relevant database classes and interfaces

  >>> from zope.component import getUtility
  >>> from schoolbell.interfaces import ICalendar, ICalendarEvent
  >>> from canonical.launchpad.interfaces import ILaunchpadCalendar
  >>> from canonical.launchpad.database import (Calendar, CalendarEvent,
  ...     CalendarEventSet, PersonSet, ProjectSet)

Get hold of some objects without calendars.

  >>> person = PersonSet().getByName('sabdfl')
  >>> project = ProjectSet()['mozilla']
  >>> product = project.getProduct('firefox')

These objects do not initially have calendars:

  >>> print person.calendar
  None
  >>> print project.calendar
  None
  >>> print product.calendar
  None

The calendar can be created with the getOrCreateCalendar() method:

  >>> person_calendar = cal = person.getOrCreateCalendar()
  >>> project_calendar = project.getOrCreateCalendar()
  >>> product_calendar = product.getOrCreateCalendar()
  >>> person.sync()
  >>> project.sync()
  >>> product.sync()
  >>> person_calendar == person.calendar
  True
  >>> project_calendar == project.calendar
  True
  >>> product_calendar == product.calendar
  True

Calendars can be attached to multiple types of objects (people,
products, projects).  It is difficult to represent a "calendar ->
parent" relationship in the database schema due to the difference in
possible types, but can be found using an SQL query.  This is wrapped
by the "parent" descriptor of the calendar:

  >>> person_calendar.parent == person
  True
  >>> project_calendar.parent == project
  True
  >>> product_calendar.parent == product
  True

The owner of the calendar is taken from the parent object:

  >>> person_calendar.owner == person
  True
  >>> project_calendar.owner == project.owner
  True
  >>> product_calendar.owner == product.owner
  True


Calendar objects implement the ILaunchpadCalendar interface, which
inherits from ICalendar:

  >>> from canonical.launchpad.webapp.testing import verifyObject
  >>> verifyObject(ILaunchpadCalendar, person_calendar)
  True
  >>> verifyObject(ICalendar, person_calendar)
  True


Calendars are iterable.  The calendars we just created are empty
though:

  >>> list(person_calendar)
  []

Let us actually create some events so iteration becomes more interesting.

  >>> e1 = CalendarEvent(unique_id="e1", calendar=cal, title="Hack",
  ...                    dtstart=datetime(2004, 12, 15, 0, 35, tzinfo=UTC),
  ...                    duration=timedelta(minutes=1))
  >>> e2 = CalendarEvent(unique_id="e2", calendar=cal, title="ditto",
  ...                    dtstart=datetime(2004, 12, 15, 0, 37, tzinfo=UTC),
  ...                    duration=timedelta(minutes=2))
  >>> sorted(event.unique_id for event in cal)
  [u'e1', u'e2']

We can look up events by their unique IDs:

  >>> cal.find('e1').title
  u'Hack'
  >>> cal.find('e3')
  Traceback (most recent call last):
    ...
  NotFoundError: 'e3'

We can look up events through CalendarEventSet:

   >>> cal_event_set = CalendarEventSet()
   >>> cal_event_set[1].title
   u'Event 1'
   >>> cal_event_set['foo']
   Traceback (most recent call last):
   ...
   NotFoundError: 'Unable to locate calendar event with ID foo'

   >>> cal_event_set['9999999']
   Traceback (most recent call last):
   ...
   NotFoundError: 'Unable to locate calendar event with ID 9999999'

Calendar events implement the ICalendarEvent interface:

  >>> verifyObject(ICalendarEvent, e1)
  True

Calendar events can be ordered by their start dates:

  >>> e1 == e2
  False
  >>> e1 < e2
  True

  >>> e1 == e1
  True
  >>> e1 < e1
  False

We can see all events that occur within a particular time interval
using expand():

  >>> events = cal.expand(datetime(2004, 12, 15, 0, 0, tzinfo=UTC),
  ...                     datetime(2004, 12, 15, 0, 36, tzinfo=UTC))
  >>> [e.title for e in events]
  [u'Hack']


The Calendar database objects also support adding events via the
ICalendar interface:

  >>> from schoolbell.simple import SimpleCalendarEvent
  >>> e = SimpleCalendarEvent(datetime(2004, 12, 15, 19, 48, tzinfo=UTC),
  ...         timedelta(hours=1), "Dinner, please!",
  ...         unique_id="new1")
  >>> e2 = cal.addEvent(e)

The calendar actually makes a copy of the event (because it cannot
store arbitrary classes in the database), and returns that copy

  >>> e2 is e
  False
  >>> e2 == e
  True

The new event is visible in the calendar

  >>> sorted(event.unique_id for event in cal)
  [u'e1', u'e2', u'new1']

You cannot add another event with the same UID

  >>> cal.addEvent(e)
  Traceback (most recent call last):
    ...
  ValueError: event 'new1' already in calendar

You can remove calendar events.

  >>> cal.removeEvent(e1)
  >>> sorted(event.unique_id for event in cal)
  [u'e2', u'new1']

If you try to remove an event that is not in the calendar, you get a
ValueError.

  >>> cal.removeEvent(e1)
  Traceback (most recent call last):
    ...
  ValueError: event u'e1' not in calendar


  >>> LaunchpadFunctionalTestSetup().tearDown()
