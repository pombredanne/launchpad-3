= Person =

The Person class is what we use to represent Launchpad users, teams and
some people which have done work on the free software community but are not
Launchpad users.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet, IPerson, IEmailAddressSet, IHasStanding,
    ...     IHasTranslationImports)
    >>> from canonical.launchpad.ftests import login, ANONYMOUS
    >>> login(ANONYMOUS)

Any Person object (either a person or a team) implements IPerson...

    >>> personset = getUtility(IPersonSet)
    >>> foobar = personset.getByName('name16')
    >>> foobar.isTeam()
    False
    >>> verifyObject(IPerson, foobar)
    True
    >>> ubuntu_team = personset.getByName('ubuntu-team')
    >>> ubuntu_team.isTeam()
    True
    >>> verifyObject(IPerson, ubuntu_team)
    True

...and IHasTranslationImports...

    >>> IHasTranslationImports.providedBy(foobar)
    True
    >>> verifyObject(IHasTranslationImports, foobar)
    True
    >>> IHasTranslationImports.providedBy(ubuntu_team)
    True
    >>> verifyObject(IHasTranslationImports, ubuntu_team)
    True

...and IHasStanding.  Teams can technically also have standing, but it's
meaningless because teams cannot post to mailing lists.

    >>> IHasStanding.providedBy(foobar)
    True
    >>> verifyObject(IHasStanding, foobar)
    True


== The IPersonSet utility ==

Access to people (Persons or Teams) is done through the IPersonSet
utility:

You can create a new person using the createPersonAndEmail method of
IPersonSet. All you need for that is a valid email address. You can also
hide the user email addresses.

Some of our scripts may create Person entries, and in these cases they must
provide a rationale and a comment (optional) for the creation of that Person
entry. These are displayed on the home pages of unvalidated Launchpad
profiles, to make it clear that those profiles were not created by the
people they represent and why they had to be created. Because the comment
will be displayed verbatim in a web page, it must start with the word "when"
followed by a description of the action that caused the entry to be created.

    >>> from canonical.launchpad.interfaces import (
    ...     EmailAddressStatus, PersonCreationRationale)
    >>> p, email = personset.createPersonAndEmail(
    ...     'randomuser@randomhost.com', PersonCreationRationale.POFILEIMPORT,
    ...     comment='when importing the Portuguese translation of firefox',
    ...     hide_email_addresses=True)
    >>> p.teamowner is None
    True
    >>> email.status == EmailAddressStatus.NEW
    True
    >>> p.is_valid_person # Not valid because no preferred email address
    False
    >>> p.hide_email_addresses
    True

Since this person has chosen to hide his email addresses they won't be visible
to other users which are not admins.

    >>> from canonical.launchpad.webapp.authorization import check_permission
    >>> login(email.email)
    >>> check_permission('launchpad.View', email)
    True

    >>> login('test@canonical.com')
    >>> check_permission('launchpad.View', email)
    False

    >>> login('guilherme.salgado@canonical.com')
    >>> check_permission('launchpad.View', email)
    True
    >>> login(ANONYMOUS)

By default, newly created Person entries will have AccountStatus.NOACCOUNT as
their account_status.  This is only changed if/when we turn that entry into an
actual user account. (Currently, we assume that a Person entry is turned into
a user account when its first email address is confirmed)

    >>> p.account_status
    <DBItem AccountStatus.NOACCOUNT...
    >>> p.setPreferredEmail(email)
    >>> email.status
    <DBItem EmailAddressStatus.PREFERRED...
    >>> p.account_status
    <DBItem AccountStatus.ACTIVE...

In the case of teams, though, the account_status is not changed as their
account_status must always be set to NOACCOUNT. (Notice how we use
setContactAddress() rather than setPreferredEmail() here, since the latter
can be used only for people and the former only for teams)

    >>> shipit_admins = personset.getByName('shipit-admins')
    >>> shipit_admins.account_status
    <DBItem AccountStatus.NOACCOUNT...

    >>> emailset = getUtility(IEmailAddressSet)
    >>> email = emailset.new('foo@baz.com', shipit_admins)
    >>> shipit_admins.setContactAddress(email)
    >>> email.status
    <DBItem EmailAddressStatus.PREFERRED...
    >>> shipit_admins.account_status
    <DBItem AccountStatus.NOACCOUNT...

Unlike people, teams don't need a contact address, so we can pass None
to setContactAddress() to leave a team without a contact address.

    >>> shipit_admins.setContactAddress(None)
    >>> email.status
    <DBItem EmailAddressStatus.VALIDATED...
    >>> print shipit_admins.preferredemail
    None

When a new sourcepackage is imported and a Person entry has to be created
because we don't know about the maintainer of that package, the code to create
the person should look like this:

    >>> person, emailaddress = personset.createPersonAndEmail(
    ...     'random@random.com', PersonCreationRationale.SOURCEPACKAGEIMPORT,
    ...     comment='when the ed package was imported into Ubuntu Breezy')
    >>> person.is_valid_person
    False
    >>> person.creation_comment
    u'when the ed package was imported into Ubuntu Breezy'

Checking .is_valid_person issues a DB query to the
ValidPersonOrTeamCache, unless it's already been cached. To avoid many
small queries when checking whether a lot of people are valid,
getValidPersons() can be used. This is useful for filling the ORM
cache, so that code in other places can check .is_valid_person, without
it issuing a DB query.

    >>> non_valid_person = person
    >>> non_valid_person.is_valid_person
    False
    >>> foobar.is_valid_person
    True
    >>> valid_persons = personset.getValidPersons([non_valid_person, foobar])
    >>> [person.name for person in valid_persons]
    [u'name16']


=== Personal standing ===

People have a property called 'personal standing', which affects for
example their ability to post to mailing lists they are not members of.
It's a form of automatic moderation.  Most people have unknown standing,
which is the default.

    >>> login('foo.bar@canonical.com')
    >>> lifeless = personset.getByName('lifeless')
    >>> lifeless.personal_standing
    <DBItem PersonalStanding.UNKNOWN...

A person also has a reason for why their standing is what it is.  The
default value of None means that no reason for the personal_standing
value is available.

    >>> print lifeless.personal_standing_reason
    None

A Launchpad administrator may change a person's standing, and may give a
reason for the change.

    >>> from canonical.launchpad.interfaces import PersonalStanding
    >>> lifeless.personal_standing = PersonalStanding.GOOD
    >>> lifeless.personal_standing_reason = 'Such a cool guy!'
    >>> from canonical.launchpad.ftests import syncUpdate
    >>> syncUpdate(lifeless)

    >>> lifeless.personal_standing
    <DBItem PersonalStanding.GOOD...
    >>> print lifeless.personal_standing_reason
    Such a cool guy!

Non-administrators may not change a person's standing.

    >>> login('test@canonical.com')
    >>> lifeless.personal_standing = PersonalStanding.POOR
    Traceback (most recent call last):
    ...
    Unauthorized: ...
    >>> lifeless.personal_standing_reason = 'Such a cool guy!'
    Traceback (most recent call last):
    ...
    Unauthorized: ...

    >>> logout()
    >>> login('foo.bar@canonical.com')
    >>> lifeless.personal_standing
    <DBItem PersonalStanding.GOOD...
    >>> print lifeless.personal_standing_reason
    Such a cool guy!
    >>> login(ANONYMOUS)


=== Ubunteros ===

Anybody who signed the last version of Ubuntu's Code of Conduct is considered
an Ubuntero.  To list all Ubunteros, use IPersonSet.getUbunteros():

    >>> [p.name for p in personset.getUbunteros()]
    [u'name16']

To check if a person is an Ubuntero, use IPerson.is_ubuntero:

    >>> foobar.is_ubuntero
    True


=== Looking Up Users by OpenID Identifier ===

Each Launchpad user is assigned an unchanging OpenID identity URL.
The last component of this URL is specific to the user, and can be
used to look up the user:

    >>> person = personset.getByOpenIdIdentifier('name12_oid')
    >>> print person.displayname
    Sample Person

If we look up a string not associated with any user, None is returned:

    >>> print personset.getByOpenIdIdentifier('no-such-identifier')
    None

While an identifier may be assigned to a team, it will not be
returned:

    >>> team = personset.getByName('simple-team')
    >>> team.isTeam()
    True
    >>> team.openid_identifier
    u'simple-team_oid'
    >>> print personset.getByOpenIdIdentifier('simple-team_oid')
    None

Accounts that have not been validated are not returned either:

    >>> person = personset.getByName('matsubara')
    >>> person.is_valid_person
    False
    >>> person.openid_identifier
    u'matsubara_oid'
    >>> print personset.getByOpenIdIdentifier('matsubara_oid')
    None


== Teams ==

As we said above, the Person class is overloaded to represent teams so
we may have Person objects which are, in fact, teams. To find out
whether a given object is a person or a team we can use the isTeam()
method of IPerson or check if the object provides the ITeam interface.

    >>> from canonical.launchpad.interfaces import ITeam
    >>> ddaa = personset.getByName('ddaa')
    >>> ddaa.isTeam()
    False
    >>> ITeam.providedBy(ddaa)
    False

    >>> landscape_devs = personset.getByName('landscape-developers')
    >>> landscape_devs.isTeam()
    True
    >>> ITeam.providedBy(landscape_devs)
    True
    >>> verifyObject(ITeam, landscape_devs)
    True

Also note that a team will never have a Launchpad account, so its
account_status will always be NOACCOUNT.

    >>> landscape_devs.account_status
    <DBItem AccountStatus.NOACCOUNT...


=== Creating teams ===

Teams are created by the IPersonSet.newTeam() method, which takes the team
owner and some of the team's details, returning the newly created team.

    >>> new_team = personset.newTeam(ddaa, 'new-team', 'Just a new team')
    >>> new_team.name
    u'new-team'
    >>> new_team.teamowner.name
    u'ddaa'

If the given name is already in use by another team/person, an exception is
raised.

    >>> personset.newTeam(ddaa, 'ddaa', 'Just a new team')
    Traceback (most recent call last):
    ...
    NameAlreadyTaken:...


=== Turning people into teams ===

Launchpad may create Person entries automatically and it always assumes
these are actual people.  Sometimes, though, these should actually be teams,
so we provide an easy way to turn one of these auto created entries into
teams.

    >>> not_a_person, dummy = personset.createPersonAndEmail(
    ...     'foo@random.com', PersonCreationRationale.SOURCEPACKAGEIMPORT,
    ...     comment='when the ed package was imported into Ubuntu Feisty')
    >>> not_a_person.isTeam()
    False
    >>> not_a_person.is_valid_person
    False
    >>> not_a_person.account_status
    <DBItem AccountStatus.NOACCOUNT...

    # Empty stub.test_emails as later we'll want to show that no notifications
    # are sent when we add the owner as a member of the team.
    >>> from canonical.launchpad.mail import stub
    >>> stub.test_emails = []

    >>> not_a_person.convertToTeam(team_owner=ddaa)
    >>> not_a_person.isTeam()
    True
    >>> ITeam.providedBy(not_a_person)
    True
    >>> verifyObject(ITeam, not_a_person)
    True
    >>> print not_a_person.password
    None

The team owner is also added as an administrator of its team.

    >>> [member.name for member in not_a_person.adminmembers]
    [u'ddaa']

    # As said previously, no notifications are sent when we add the team owner
    # as a member of his team.
    >>> transaction.commit()
    >>> stub.test_emails
    []

And we can even add other members to our new team!

    >>> login('foo.bar@canonical.com')
    >>> not_a_person.addMember(lifeless, reviewer=ddaa)
    >>> login(ANONYMOUS)
    >>> [member.name for member in not_a_person.activemembers]
    [u'ddaa', u'lifeless']

This functionality is only available for non-team Person entries whose
account_status is NOACCOUNT, though.

    >>> ddaa.account_status
    <DBItem AccountStatus.ACTIVE...
    >>> ddaa.convertToTeam(team_owner=landscape_devs)
    Traceback (most recent call last):
    ...
    AssertionError: Only Person entries whose account_status is NOACCOUNT...

    >>> not_a_person.convertToTeam(team_owner=landscape_devs)
    Traceback (most recent call last):
    ...
    AssertionError: Can't convert a team to a team.


=== Team members ===

The relationship between a person and a team is stored in TeamMemberships
table. TeamMemberships have a status (which can be any item of
TeamMembershipStatus) and represent the current state of the relationship
between that person and that team. Only TeamMembershipStatus with an ADMIN
or APPROVED status are considered active.

    >>> [member.displayname for member in landscape_devs.approvedmembers]
    [u'Guilherme Salgado']
    >>> [member.displayname for member in landscape_devs.adminmembers]
    [u'Sample Person']

The IPerson.activemembers property will always include all approved and admin
members of that team.

    >>> [member.displayname for member in landscape_devs.activemembers]
    [u'Guilherme Salgado', u'Sample Person']

TeamMemberships with a PROPOSED or INVITED status represent a person/team
which has proposed himself as a member or which has been invited to join
the team.

    >>> [member.displayname for member in landscape_devs.proposedmembers]
    [u'Foo Bar']
    >>> [member.displayname for member in landscape_devs.invited_members]
    [u'Launchpad Developers']

Similarly, we have IPerson.pendingmembers which includes both invited and
proposed members.

    >>> [member.displayname for member in landscape_devs.pendingmembers]
    [u'Foo Bar', u'Launchpad Developers']

Finally, we have EXPIRED and DEACTIVATED TeamMemberships, which represent
former (inactive) members of a team.

    >>> [member.displayname for member in landscape_devs.expiredmembers]
    [u'Karl Tilbury']
    >>> [member.displayname for member in landscape_devs.deactivatedmembers]
    [u'No Privileges Person']

We can get a list of all inactive members of a team with the
IPerson.inactivemembers property.

    >>> [member.displayname for member in landscape_devs.inactivemembers]
    [u'Karl Tilbury', u'No Privileges Person']

We can also iterate over the TeamMemberships themselves, which is useful
when we want to display details about them rather than just the member.

    >>> [(membership.person.displayname, membership.status.name)
    ...  for membership in landscape_devs.member_memberships]
    [(u'Guilherme Salgado', 'APPROVED'), (u'Sample Person', 'ADMIN')]
    >>> [(membership.person.displayname, membership.status.name)
    ...  for membership in landscape_devs.getInvitedMemberships()]
    [(u'Launchpad Developers', 'INVITED')]
    >>> [(membership.person.displayname, membership.status.name)
    ...  for membership in landscape_devs.getProposedMemberships()]
    [(u'Foo Bar', 'PROPOSED')]
    >>> [(membership.person.displayname, membership.status.name)
    ...  for membership in landscape_devs.getInactiveMemberships()]
    [(u'Karl Tilbury', 'EXPIRED'), (u'No Privileges Person', 'DEACTIVATED')]

An IPerson has an inTeam method to allow us to easily check if a
person is a member (directly or through other teams) of a team. It
accepts an object implementing IPerson, which is the common use case
when checking permissions.

    >>> ddaa.is_valid_person
    True
    >>> vcs_imports = personset.getByName('vcs-imports')
    >>> lifeless.inTeam(vcs_imports) and ddaa.inTeam(vcs_imports)
    True

That method can also be used to check that a given IPerson is a member of
itself. We can do that because people and teams have TeamParticipation
entries for themselves.

    >>> ddaa.inTeam(ddaa)
    True
    >>> ddaa.hasParticipationEntryFor(ddaa)
    True

    >>> vcs_imports.inTeam(vcs_imports)
    True
    >>> vcs_imports.hasParticipationEntryFor(vcs_imports)
    True

The inTeam method is cached to avoid unnecessary database lookups - this
was a cause of a number of timeouts

    >>> from zope.security.proxy import removeSecurityProxy
    >>> naked_lifeless = removeSecurityProxy(lifeless)
    >>> naked_lifeless._inTeam_cache[vcs_imports.id]
    True
    >>> naked_lifeless._inTeam_cache[vcs_imports.id] = False
    >>> lifeless.inTeam(vcs_imports)
    False
    >>> naked_lifeless._inTeam_cache[vcs_imports.id] = True
    >>> lifeless.inTeam(vcs_imports)
    True

IPerson has a method to clear it; this is used between IPerson instances
to ensure that the cache can be kept consistent when membership changes.

    >>> naked_lifeless.clearInTeamCache()
    >>> naked_lifeless._inTeam_cache
    {}

** See lib/canonical/launchpad/doc/teammembership.txt for more information
   about team membership/participation.


=== Email notifications to teams ===

If a team has a contact email address, all notifications we send to the
team will go to that address.

    >>> ubuntu_team = personset.getByName('ubuntu-team')
    >>> ubuntu_team.preferredemail.email
    u'support@ubuntu.com'
    >>> from canonical.launchpad.helpers import contactEmailAddresses
    >>> contactEmailAddresses(ubuntu_team)
    set(['support@ubuntu.com'])

On the other hand, if a team doesn't have a contact email address, all
notifications we send to the team will go to the preferred email of
each direct member of that team.

    >>> vcs_imports.preferredemail is None
    True
    >>> sorted(member.preferredemail.email
    ...        for member in vcs_imports.activemembers)
    [u'david.allouche@canonical.com', u'foo.bar@canonical.com',
     u'robertc@robertcollins.net']
    >>> sorted(contactEmailAddresses(vcs_imports))
    ['david.allouche@canonical.com', 'foo.bar@canonical.com',
     'robertc@robertcollins.net']


=== Team Visibility ===

A Team can have its visibility attribute set to PersonVisibility.PUBLIC
or PersonVisibility.PRIVATE_MEMBERSHIP. To prevent leaking of
private membership information, private-membership teams are only
allowed to be connected with a few different database objects. This is
enforced in the model, but there are also checks in the form handling to
provide clearer error messages.

The PublicPersonChoice for interface classes and the public_person_validator
for SQLObject classes only allow public teams to be assigned to the
specified field.

The SQLObject validators will raise an InvalidField exception if an
invalid team is passed to the constructor or is used to set one of
the attributes.

myteam is a private-membership team, so public_person_validator
will reject it for the BugSubscription.person and
BugSubscription.subscribed_by attributes.

    >>> login('foo.bar@canonical.com')
    >>> from canonical.launchpad.interfaces import IBugSet, IPersonSet
    >>> from canonical.launchpad.database import BugSubscription
    >>> person_set = getUtility(IPersonSet)
    >>> bug_set = getUtility(IBugSet)
    >>> myteam = person_set.getByName('myteam')
    >>> guadamen = person_set.getByName('guadamen')
    >>> bug = bug_set.get(1)
    >>> BugSubscription(bug=bug, person=myteam, subscribed_by=guadamen)
    Traceback (most recent call last):
    ...
    InvalidField: Cannot link person
    (name=myteam, visibility=PRIVATE_MEMBERSHIP) to <BugSubscription...
    >>> bug_subscription = BugSubscription(bug=bug, person=guadamen,
    ...                                    subscribed_by=guadamen)
    >>> bug_subscription.person = myteam
    Traceback (most recent call last):
    ...
    InvalidField: Cannot link person
    (name=myteam, visibility=PRIVATE_MEMBERSHIP) to <BugSubscription...

== Latest Team Memberships ==

The key concept in displaying the latest team memberships is that the team
list is actually sorted by date joined.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> personset = getUtility(IPersonSet)
    >>> foobar = personset.getByName('name16')
    >>> membership_list = foobar.getLatestApprovedMembershipsForPerson()
    >>> for membership in membership_list:
    ...     print membership.datejoined
    2008-05-14 12:07:14.227450+00:00
    2007-01-17 14:13:39.692693+00:00
    2006-05-15 22:23:29.062603+00:00
    2005-10-13 13:03:41.668724+00:00
    2005-07-12 14:36:09.587753+00:00

== Deactivating user accounts ==

Any user can deactivate his own account, in case they don't want it anymore
or they don't want to be shown as Launchpad users.

As seen below, Foo Bar has a bunch of stuff assigned/owned to/by him in
Launchpad which we'll want to be reassigned/unassigned if his account is
deactivated.  Unfortunatel, Foo Bar has no specifications assigned to him, so
we'll assign one just to prove that deactivating his account will cause this
spec to be reassigned.

    >>> foobar.specifications().count() > 0
    True
    >>> from canonical.launchpad.database import Person, Specification
    >>> spec = Specification.selectFirst("assignee IS NULL", orderBy='id')
    >>> spec.assignee = foobar
    >>> flush_database_updates()

    >>> [membership.team.name for membership in foobar.myactivememberships]
    [u'canonical-partner-dev', u'guadamen', u'admins',
     u'launchpad-buildd-admins', u'launchpad', u'testing-spanish-team',
     u'name18', u'ubuntu-team', u'vcs-imports']
    >>> [email.email for email in foobar.validatedemails]
    []
    >>> foobar.name
    u'name16'
    >>> foobar.preferredemail.email
    u'foo.bar@canonical.com'
    >>> [coc.active for coc in foobar.signedcocs]
    [True]
    >>> from canonical.launchpad.interfaces import BugTaskSearchParams
    >>> params = BugTaskSearchParams(foobar, assignee=foobar)
    >>> foobar.searchTasks(params).count() > 0
    True
    >>> len(foobar.assigned_specs) > 0
    True
    >>> foobar_pillars = []
    >>> for pillar_name in foobar.getOwnedOrDrivenPillars():
    ...     pillar = pillar_name.pillar
    ...     if pillar.owner == foobar or pillar.driver == foobar:
    ...         foobar_pillars.append(pillar_name)
    >>> len(foobar_pillars) > 0
    True
    >>> foobar_teams = list(Person.selectBy(teamowner=foobar))
    >>> len(foobar_teams) > 0
    True
    >>> foobar.is_valid_person
    True

    >>> comment = ("I'm a silly person who doesn't want to be listed "
    ...            "as a Launchpad user.")

The deactivateAccount method is restricted to the user himself --not even
launchpad admins can use it.

    >>> login('mark@hbd.com')
    >>> foobar.deactivateAccount(comment)
    Traceback (most recent call last):
    ...
    Unauthorized: ...'launchpad.Special')

    >>> login('foo.bar@canonical.com')
    >>> foobar.deactivateAccount(comment)
    >>> flush_database_updates()
    >>> from canonical.database.sqlbase import flush_database_caches
    >>> flush_database_caches()

Deactivating an account changes many of the person's attributes.  It adds a
'-deactivatedaccount' suffix to the person's name...

    >>> foobar.name
    u'name16-deactivatedaccount'

...an account status of DEACTIVATED...

    >>> foobar.account_status
    <DBItem AccountStatus.DEACTIVATED...
    >>> foobar.account_status_comment
    u"I'm a silly person who doesn't want to be listed as a Launchpad user."

...to have no team memberships...

    >>> [membership.team.name for membership in foobar.myactivememberships]
    []

...and no validated/preferred email addresses...

    >>> [email.email for email in foobar.validatedemails]
    []
    >>> print getattr(foobar.preferredemail, 'email', None)
    None

...no signed codes of conduct...

    >>> [coc.active for coc in foobar.signedcocs]
    [False]

...no assigned bug tasks...

    >>> foobar.searchTasks(params).count()
    0

...no assigned specs...

    >>> len(foobar.assigned_specs)
    0

...no owned teams...

    >>> Person.selectBy(teamowner=foobar).count()
    0

...no owned or driven pillars...
    >>> foobar.getOwnedOrDrivenPillars().count()
    0

...and, finally, to not be considered a valid person in Launchpad.

    >>> foobar.is_valid_person
    False

It's also important to note that the teams/pillars owned/driven by Foo Bar
are now owned/driven by the registry admins team.

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> registry_experts = getUtility(ILaunchpadCelebrities).registry_experts

    >>> registry_pillars = set(registry_experts.getOwnedOrDrivenPillars())
    >>> registry_pillars.issuperset(foobar_pillars)
    True

    >>> registry_teams = set(Person.selectBy(teamowner=registry_experts))
    >>> registry_teams.issuperset(foobar_teams)
    True

    # We need to restore Foo Bar's name because some of our further tests rely
    # on that name existing in the database and it'd be a lot more painful
    # to update them. :/
    >>> foobar.name = 'name16'
    >>> flush_database_updates()


== Searching ==

You can search based on a person's name or displayname, or any of the email
addresses that belongs to a person using the methods provided by IPersonSet.

While we don't have Full Text Indexes in the emailaddress table, we'll be
trying to match the text only against the beginning of an email address:

    # First we'll define a utility function to help us displaying the results.
    >>> emailset = getUtility(IEmailAddressSet)
    >>> def print_people(results):
    ...     for person in results:
    ...         emails = [email.email
    ...                   for email in emailset.getByPerson(person)]
    ...         print "%s (%s): %s" % (
    ...             person.displayname, person.name, emails)

    >>> print_people(personset.find('ubuntu'))
    Mirror Administrators (ubuntu-mirror-admins): []
    Sigurd Gartmann (sigurd-ubuntu): [u'sigurd-ubuntu@brogar.org']
    Ubuntu Doc Team (doc): [u'doc@lists.ubuntu.com']
    Ubuntu Gnome Team (name18): []
    Ubuntu Team (ubuntu-team): [u'support@ubuntu.com']
    Ubuntu Translators (ubuntu-translators): []

    >>> print_people(personset.find('steve.alexander'))
    Steve Alexander (stevea): [u'steve.alexander@ubuntulinux.com']

Searching only for People based on their names or email addresses:

    >>> print_people(personset.findPerson('james.blackwell'))
    James Blackwell (jblack): [u'james.blackwell@ubuntulinux.com']

    >>> print_people(personset.findPerson('dave'))
    Dave Miller (justdave): [u'dave.miller@ubuntulinux.com',
                             u'justdave@bugzilla.org']

By default, when searching only for people, any person whose account is
inactive is not included in the list, but we can tell findPerson to include
them as well.

    >>> from canonical.launchpad.interfaces import AccountStatus
    >>> dave = personset.getByName('justdave')
    >>> removeSecurityProxy(dave).account_status = AccountStatus.DEACTIVATED
    >>> flush_database_updates()
    >>> list(personset.findPerson('dave'))
    []

    >>> print_people(
    ...     personset.findPerson('dave', exclude_inactive_accounts=False))
    Dave Miller (justdave): [u'dave.miller@ubuntulinux.com',
                             u'justdave@bugzilla.org']

    >>> removeSecurityProxy(dave).account_status = AccountStatus.ACTIVE
    >>> flush_database_updates()
    >>> login(ANONYMOUS)

Searching only for Teams based on their names or email addresses:

    >>> print_people(personset.findTeam('support'))
    Ubuntu Team (ubuntu-team): [u'support@ubuntu.com']

    >>> print_people(personset.findTeam('translators'))
    Ubuntu Translators (ubuntu-translators): []


== Packages related to a person ==

To obtain the packages a person is related to, we can use:

 1. getLatestMaintainedPackages(),
 2. getLatestUploadedButNotMaintainedPackages(),
 3. getLatestUploadedPPAPackages

The 1st will return the latest SourcePackageReleases related to a
person in which he is listed as the Maintainer. The second will return
the latest SourcePackageReleases a person uploaded (and where he isn't
the maintainer).

Both, 1st and 2nd methods, only consider sources upload to primary archives.

The 3rd method returns SourcePackageReleases uploaded by the person in
question to any PPA.

    >>> sabdfl = personset.getByName('sabdfl')
    >>> for sprelease in sabdfl.getLatestMaintainedPackages():
    ...     print (sprelease.name, sprelease.upload_distroseries.fullseriesname,
    ...            sprelease.version)
    (u'alsa-utils', u'Debian Sid', u'1.0.9a-4')
    (u'pmount', u'Ubuntu Hoary', u'0.1-2')
    (u'netapplet', u'Ubuntu Warty', u'0.99.6-1')
    (u'netapplet', u'Ubuntu Hoary', u'1.0-1')
    (u'alsa-utils', u'Ubuntu Warty', u'1.0.8-1ubuntu1')
    (u'mozilla-firefox', u'Ubuntu Hoary', u'0.9')
    (u'evolution', u'Ubuntu Hoary', u'1.0')

    >>> for sprelease in sabdfl.getLatestUploadedButNotMaintainedPackages():
    ...     print (sprelease.name, sprelease.upload_distroseries.fullseriesname,
    ...            sprelease.version)
    (u'cdrkit', u'Ubuntu Breezy-autotest', u'1.0')
    (u'libstdc++', u'Ubuntu Hoary', u'b8p')
    (u'cnews', u'Ubuntu Hoary', u'cr.g7-37')
    (u'linux-source-2.6.15', u'Ubuntu Hoary', u'2.6.15.3')
    (u'alsa-utils', u'Ubuntu Hoary', u'1.0.9a-4ubuntu1')


    >>> sabdfl_spreleases = sabdfl.getLatestUploadedPPAPackages()
    >>> for sprelease in sabdfl_spreleases:
    ...     print (sprelease.name,
    ...            sprelease.version,
    ...            sprelease.creator.name,
    ...            sprelease.maintainer.name,
    ...            sprelease.upload_archive.owner.name,
    ...            sprelease.upload_distroseries.fullseriesname)
    (u'iceweasel', u'1.0', u'sabdfl', u'name16', u'sabdfl', u'Ubuntu Warty')

We will change modify the first SourcePackageRelease to reproduce the
issue mentioned in bug 157303, where source with same creator and
maintainer got omitted from the results:

    >>> any_spr = sabdfl_spreleases[0]
    >>> naked_spr = removeSecurityProxy(any_spr)
    >>> naked_spr.maintainer = sabdfl
    >>> flush_database_updates()

    >>> sabdfl_spreleases = sabdfl.getLatestUploadedPPAPackages()
    >>> for sprelease in sabdfl_spreleases:
    ...     print (sprelease.name,
    ...            sprelease.version,
    ...            sprelease.creator.name,
    ...            sprelease.maintainer.name,
    ...            sprelease.upload_archive.owner.name,
    ...            sprelease.upload_distroseries.fullseriesname)
    (u'iceweasel', u'1.0', u'sabdfl', u'sabdfl', u'sabdfl', u'Ubuntu Warty')


== Packages a Person is subscribed to ==

IPerson.getBugSubscriberPackages returns this list of packages, sorted
alphabetically by package name.

    >>> login('no-priv@canonical.com')
    >>> from canonical.launchpad.interfaces.distribution import (
    ...     IDistributionSet)
    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> pmount = ubuntu.getSourcePackage('pmount')
    >>> pmount.addBugSubscription(no_priv, no_priv)
    <StructuralSubscription at ...>
    >>> mozilla_firefox = ubuntu.getSourcePackage('mozilla-firefox')
    >>> mozilla_firefox.addBugSubscription(no_priv, no_priv)
    <StructuralSubscription at ...>

    >>> [package.name for package in no_priv.getBugSubscriberPackages()]
    [u'mozilla-firefox', u'pmount']


== Pillars owned or driven by a person or team ==

To obtain all distributions, project groups and projects owned or driven by a
person or team, we can use the getOwnedOrDrivenPillars() method of IPerson.
This method returns PillarNames ordered by distribution, project groups and
projects.

    >>> from canonical.launchpad.interfaces import (IDistribution, IProject,
    ...     IProduct)

    >>> def print_pillar(pillarname):
    ...     pillar = pillarname.pillar
    ...     if IDistribution.providedBy(pillar):
    ...         pillar_type = 'distribution'
    ...     elif IProject.providedBy(pillar):
    ...         pillar_type = 'project group'
    ...     elif IProduct.providedBy(pillar):
    ...         pillar_type = 'project'
    ...     print "%s: %s (%s)" % (
    ...         pillar_type, pillar.title, pillar.name)

    >>> for pillarname in sabdfl.getOwnedOrDrivenPillars():
    ...     print_pillar(pillarname)
    distribution: Ubuntu Linux (ubuntu)
    distribution: Redhat Advanced Server (redhat)
    distribution: Debian GNU/Linux (debian)
    distribution: The Gentoo Linux (gentoo)
    distribution: Kubuntu - Free KDE-based Linux (kubuntu)
    distribution: Ubuntu Test (ubuntutest)
    project group: Apache (apache)
    project group: The Test Project (aaa)
    project group: The GIMP Project (gimp)
    project: Tomcat (tomcat)
    project: The Gnome Panel Applets (applets)
    project: Liba52 Test Decoder (a52dec)
    project: Gnome Baker (gnomebaker)
    project: ALSA utilities (alsa-utils)
    project: Derby - Java Database (derby)

    >>> for pillarname in ubuntu_team.getOwnedOrDrivenPillars():
    ...     print_pillar(pillarname)
    distribution: Ubuntu Linux (ubuntu)
    distribution: Ubuntu Test (ubuntutest)
    project: Tomcat (tomcat)


== Project owned by a person or team ==

To obtain all projects owned by a person or team, we can use the
getOwnedProjects() method of IPerson.  This method returns
projects ordered by displayname.

    >>> for project in sabdfl.getOwnedProjects():
    ...     print project.displayname
    Derby
    Gnome Applets
    Tomcat
    a52dec
    alsa-utils
    gnomebaker

    >>> for project in ubuntu_team.getOwnedProjects():
    ...     print project.displayname
    Tomcat

David does not own any projects.

    >>> list(ddaa.getOwnedProjects())
    []

The results returned can be filtered by providing a token to refine
the search.

    >>> for project in sabdfl.getOwnedProjects(match_name='gnome'):
    ...     print project.displayname
    Gnome Applets
    gnomebaker

Searching for a non-existent project returns no matches.

    >>> list(sabdfl.getOwnedProjects(match_name='nosuchthing'))
    []

== Translations ==

Users can set their preferred languages, retrievable as Person.languages.

    >>> daf = personset.getByName('daf')
    >>> carlos = personset.getByName('carlos')

    >>> for language in carlos.languages:
    ...     print language.code, language.englishname
    ca     Catalan
    en     English
    es     Spanish

The Person.languages list is ordered alphabetically by the languages' English
names.

    >>> for language in daf.languages:
    ...     print language.code, language.englishname
    en_GB  English (United Kingdom)
    ja     Japanese
    cy     Welsh

Person.translatable_languages yields the same list, except it leaves out US
English and languages marked as non-visible such as 'zh' or 'de_DE'.

    >>> for language in daf.translatable_languages:
    ...     print language.code, language.englishname
    en_GB  English (United Kingdom)
    ja     Japanese
    cy     Welsh

    >>> for language in carlos.translatable_languages:
    ...     print language.code, language.englishname
    ca     Catalan
    es     Spanish

The IPerson interface offers a way of returning POFileTranslator records
for a Person:

    >>> for pt in carlos.translation_history:
    ...     print pt.pofile.title
    Spanish (es) translation of alsa-utils in alsa-utils trunk
    Spanish (es) translation of man in Ubuntu Hoary package "evolution"
    Spanish (es) translation of evolution-2.2 in Evolution trunk
    Japanese (ja) translation of evolution-2.2 in Ubuntu Hoary package "evolution"
    Spanish (es) translation of evolution-2.2 in Ubuntu Hoary package "evolution"

The IPersonSet component contains a few convenience methods to return
Person objects that have contributed translations.

    >>> from canonical.launchpad.database import POFile
    >>> pofile = POFile.get(12)
    >>> [p.name for p in personset.getPOFileContributors(pofile)]
    [u'carlos', u'name16', u'tsukimi']

getPOFileContributorsByDistroSeries gives the list of people that did
contributions to templates that are current in the given IDistroSeries
and ILanguage.

    >>> from canonical.launchpad.database import DistroSeries, Language
    >>> hoary = DistroSeries.selectOneBy(name="hoary")
    >>> spanish = Language.selectOneBy(code="es")
    >>> [p.name for p in personset.getPOFileContributorsByDistroSeries(hoary, spanish)]
    [u'jorge-gonzalez-gonzalez', u'carlos', u'valyag', u'danner', u'name16',
     u'name12', u'tsukimi']

    # We can see that there is another translator that doesn't appear in
    # previous list because the template he translated is not current.
    >>> non_current_pofile = POFile.get(31)
    >>> non_current_pofile.potemplate.iscurrent
    False
    >>> [p.name for p in personset.getPOFileContributors(non_current_pofile)]
    [u'jordi']
    >>> non_current_pofile.potemplate.distroseries == hoary
    True
    >>> non_current_pofile.language == spanish
    True

=== Translators for a given language ===

We can get the list of translators that did some translation in Launchpad and
expressed their interest for a concrete language.

    >>> from canonical.launchpad.interfaces import ILanguageSet

    # Sample data is not complete for this test, so we need to note that
    # another Spanish translator expressed its interest on doing Spanish
    # translations.  That other person is Foo Bar (name16).
    >>> personset = getUtility(IPersonSet)
    >>> foo_bar = personset.getByName('name16')
    >>> print foo_bar.displayname
    Foo Bar
    >>> languageset = getUtility(ILanguageSet)
    >>> spanish = languageset.getLanguageByCode('es')
    >>> foo_bar.addLanguage(spanish)
    >>> translators = personset.getTranslatorsByLanguage(spanish)
    >>> for translator in translators:
    ...     karma = 0
    ...     for karma_category_cache in translator.karma_category_caches:
    ...         if (karma_category_cache.category.name == 'translations'):
    ...             karma = karma_category_cache.karmavalue
    ...     print (translator.displayname, karma)
    (u'Foo Bar', 164)
    (u'Carlos Perell\xf3 Mar\xedn', 9)


== Specification Lists ==

We should be able to generate lists of specifications for people based on
certain criteria:

First, Carlos does not have any completed specifications assigned to him:

    >>> from canonical.launchpad.interfaces import SpecificationFilter
    >>> carlos.specifications(filter=[
    ...     SpecificationFilter.ASSIGNEE,
    ...     SpecificationFilter.COMPLETE]).count()
    0

Next, Carlos has three incomplete specs *related* to him:

    >>> filter = []
    >>> for spec in carlos.specifications(filter=filter):
    ...     print spec.name, spec.is_complete, spec.informational
    svg-support False False
    extension-manager-upgrades False True
    media-integrity-check False False

Carlos has 2 specifications assigned to him:

    >>> for spec in carlos.assigned_specs:
    ...     print spec.name
    svg-support
    extension-manager-upgrades

But from these two, only one has started.

    >>> [(spec.name, spec.is_started)
    ...  for spec in carlos.assigned_specs_in_progress]
    [(u'svg-support', True)]

Just for fun, lets check the SAB. He should have one spec for which he
is the approver.

    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> filter = [SpecificationFilter.APPROVER]
    >>> for spec in sabdfl.specifications(filter=filter):
    ...     print spec.name
    extension-manager-upgrades

The Foo Bar person has a single spec which has feedback requested:

    >>> filter = [SpecificationFilter.FEEDBACK]
    >>> for spec in foobar.specifications(filter=filter):
    ...     print spec.name
    e4x

But has registered 5 of them:

    >>> filter = [SpecificationFilter.CREATOR]
    >>> print foobar.specifications(filter=filter).count()
    5

Now Celso, on the other hand, has 2 specs related to him:

    >>> cprov = personset.getByName('cprov')
    >>> cprov.specifications().count()
    2

On one of those, he is the approver:

    >>> filter = [SpecificationFilter.APPROVER]
    >>> for spec in cprov.specifications(filter=filter):
    ...     print spec.name
    svg-support

And on another one, he is the drafter

    >>> filter = [SpecificationFilter.DRAFTER]
    >>> for spec in cprov.specifications(filter=filter):
    ...     print spec.name
    e4x

We can filter for specifications that contain specific text:

    >>> for spec in cprov.specifications(filter=['svg']):
    ...     print spec.name
    svg-support

Inactive products are excluded from the listings.

    >>> from canonical.launchpad.interfaces import IProductSet
    >>> from canonical.launchpad.ftests import login
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> login("mark@hbd.com")
    >>> firefox.active = False
    >>> flush_database_updates()
    >>> cprov.specifications(filter=['svg']).count()
    0

Reset firefox so we don't mess up later tests.

    >>> firefox.active = True
    >>> flush_database_updates()


== Branches ==

** See branch.txt for API related to branches.


== Distribution uploaders ==

We can ascertain whether a person has uploader rights to a distribution
or not.

    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> cprov.isUploader(ubuntu)
    True

'kiko' is not an uploader to Ubuntu:

    >>> kiko = getUtility(IPersonSet).getByName('kiko')
    >>> kiko.isUploader(ubuntu)
    False


== Bug contribution ==

We can check whether a person has any bugs assigned to them, either
within the context of a specific bug target, or in Launchpad in general.

A person with bugs assigned to them in a context is considered a 'Bug
Contributor'.

    >>> cprov.searchTasks(
    ...     BugTaskSearchParams(user=foobar, assignee=cprov)).count()
    0

Celso has no bug tasks assigned to him. In other words, he isn't a bug
contributor.

    >>> cprov.isBugContributor(user=foobar)
    False

We assign a bug task to Celso.

    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> search_params = BugTaskSearchParams(user=foobar)
    >>> search_params.setProduct(firefox)
    >>> firefox_bugtask = getUtility(IBugTaskSet).search(search_params)[0]
    >>> firefox_bugtask.transitionToAssignee(cprov)
    >>> flush_database_updates()

Now Celso is a bug contributor in Launchpad.

    >>> cprov.isBugContributor(user=foobar)
    True

Celso is a bug contributer in the context of the `firefox` product.

    >>> from canonical.launchpad.interfaces import IProjectSet
    >>> cprov.isBugContributorInTarget(user=foobar, target=firefox)
    True

And also in the context of the `mozilla` project, by association.

    >>> cprov.isBugContributorInTarget(user=foobar,
    ...     target=getUtility(IProjectSet).getByName('mozilla'))
    True

But not in other contexts.

    >>> cprov.isBugContributorInTarget(user=foobar,
    ...     target=getUtility(IProductSet).getByName('jokosher'))
    False
