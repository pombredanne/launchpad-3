Person
======

In Launchpad, the Person class is overloaded to represent both people
and teams. Let's log in as Robert Collins to ensure we have the
privileges to do what we're going to demonstrate.

>>> from zope.component import getUtility
>>> from zope.interface.verify import verifyObject
>>> from canonical.database.sqlbase import sqlvalues, flush_database_updates
>>> from canonical.launchpad.interfaces import (
...     IPersonSet, IPerson, IEmailAddressSet)
>>> from canonical.launchpad.ftests import login
>>> from canonical.launchpad.helpers import contactEmailAddresses

>>> login("robertc@robertcollins.net")

>>> personset = getUtility(IPersonSet)
>>> emailset = getUtility(IEmailAddressSet)


Verify that foobar (a Person object) correctly implements IPerson.

>>> foobar = personset.getByName('name16')
>>> verifyObject(IPerson, foobar)
True


Access to people (Persons or Teams) is done through the IPersonSet
utility:

You can create a new person using the createPersonAndEmail method of 
IPersonSet. All you need for that is a valid email address.
>>> p, email = personset.createPersonAndEmail('randomuser@randomhost.com')
>>> p.teamowner is None
True

>>> buttsource = personset.getByName('buttsource')
>>> buttsource.teamowner is None
False
>>> lifeless = personset.getByName('lifeless')
>>> lifeless.teamowner is None
True

An IPerson has an inTeam method to allow us to easily check if a
person is a member of a team. It accepts an object implementing 
IPerson, which is the common use case when checking permissions.

>>> ddaa = personset.getByName('ddaa')
>>> lifeless.inTeam(buttsource) and ddaa.inTeam(buttsource)
True

If a Person is not a Team then the Person object will not provide the
ITeam interface.

>>> from canonical.launchpad.interfaces import ITeam
>>> ITeam.providedBy(lifeless)
False

If a Person is a Team then the Person will provide the ITeam interface.

>>> ITeam.providedBy(buttsource)
True

If a team doesn't have a contact email address, all notifications we send to
the team will go to the preferred email of each member.

>>> contactEmailAddresses(buttsource)
set(['david.allouche@canonical.com', 'robertc@robertcollins.net',
     'foo.bar@canonical.com'])

We don't support changing a Person into a Team or a Team into a Person.

>>> buttsource.teamowner = None
>>> ITeam.providedBy(buttsource)
True


Renaming
--------

All persons have a unique name in launchpad, so to allow them to change their
names, we must make sure that name is not already in use by someone else.

>>> from canonical.launchpad.interfaces.person import (
...     PersonNameField, StrippingTextLine)
>>> field = PersonNameField(__name__='name', title=u'Unique name',
...                         description=u'', readonly=False, required=True)
>>> field = field.bind(lifeless)
>>> field.context == lifeless
True

You can always use your own name.
>>> field.validate(lifeless.name)

Or a name that is not already in use.
>>> field.validate(u'namenotinuse')

But you can't use Mark's name, of course. ;)
>>> field.validate(u'sabdfl')
Traceback (most recent call last):
  ...
LaunchpadValidationError: ...
This name is already in use by another person/team.
...

In the case of your displayname, the only constraint is that it can't contain
only spaces. To ensure that, we use a StrippingTextLine in the displayname,
which is a class that always strips the unicode string before applying any
validation or constraints.
>>> field = StrippingTextLine(__name__='displayname', title=u'Displayname',
...                           description=u'', readonly=False, required=True,
...                           missing_value=u'')
>>> field.fromUnicode(u' foo ')
u'foo'

>>> field.fromUnicode(u'  ')
Traceback (most recent call last):
...
RequiredMissing


Merging
-------

The method to perform the low level merging of two Persons
should only be used by the one true account merge workflow.

>>> foo = personset.getByName('name16')
>>> sample = personset.getByName('name12')
>>> admins = personset.getByName('admins')

We can't merge teams

>>> personset.merge(admins, foo)
Traceback (most recent call last):
...
TypeError: ...

>>> personset.merge(foo, admins)
Traceback (most recent call last):
...
TypeError: ...

Nor can we merge an account that still has email addresses attached to it

>>> nonempty, email = personset.createPersonAndEmail('empty@somehost.com')
>>> rosetta_admins = personset.getByName('rosetta-admins')
>>> rosetta_admins.addMember(nonempty)
>>> personset.merge(nonempty, sample)
Traceback (most recent call last):
...
ValueError: ...

Now we remove the only email address nonempty had.

>>> email.destroySelf()
>>> empty = nonempty

Must login as 'sabdfl' cause he's the owner of the Ubuntu Team.
>>> login('mark@hbd.com')
>>> ubuntu_team = personset.getByName('name17')
>>> ubuntu_translators = personset.getByName('ubuntu-translators')
>>> ubuntu_translators.addMember(empty)
>>> ubuntu_team.teamowner = empty
>>> foo = empty.assignKarma('bugfixed')
>>> empty.updateKarmaCache()
>>> sample.updateKarmaCache()
>>> flush_database_updates()

'Sample Person' is a deactivated member of the 'Ubuntu Translators' team,
while empty is an active member. After the merge, 'Sample Person' will be an
active member of that team.
>>> sample in ubuntu_translators.inactivemembers
True
>>> empty in ubuntu_translators.activemembers
True
>>> empty.karma
10
>>> sample.karma
161

>>> personset.merge(empty, sample)

>>> sample in ubuntu_translators.activemembers
True
>>> sample.inTeam(ubuntu_translators)
True
>>> empty.karma
0
>>> sample.karma
171

>>> from canonical.launchpad.database import Person
>>> cur = Person._connection._connection.cursor()

A merged account gets a -merged suffix on its name.
>>> empty.id
59L
>>> cur.execute("SELECT id FROM Person WHERE name='empty-merged'")
>>> cur.fetchone()[0]
59


>>> cur.execute("select person, team, status from teammembership where "
...             "person = %s and team = %s"
...             % sqlvalues(sample.id, rosetta_admins.id))
>>> cur.fetchone()
[12, 30, 2]

>>> sample.inTeam(rosetta_admins)
True

>>> cur.execute("select p1.name from person as p1, person as p2 where "
...             "p1.id = p2.teamowner and p2.name = 'name17'")
>>> cur.fetchone()[0]
u'name12'

The account that has been merged is flagged. We can use this to eliminate
merged accounts from lists etc.

>>> cur.execute("SELECT merged FROM Person WHERE name='empty-merged'")
>>> cur.fetchone()[0]
12

>>> cur.execute("SELECT merged FROM Person WHERE name='name12'")
>>> cur.fetchone()[0] is None
True

After the merging we could test the topPeople() method of the PersonSet
class. This methods returns a sliced list of 5 valid person accounts,
ordered by karma. A valid person account is any non-merged person with a
preferred email address.

>>> empty.karma = 10000
>>> flush_database_updates()
>>> [(person.name, person.karma) for person in personset.topPeople()]
[(u'name12', 171), (u'name16', 40), (u'jordi', 0), (u'marilize', 0), (u'no-priv', 0)]


People can have karma in Launchpad
----------------------------------

Depending on the action a given person performs in Launchpad, that person can
earn some karma points. This is useful to know how active a user is in
Launchpad.

Salgado wrote the karma framework. Let's give him some karma points.

>>> salgado = personset.getByName('salgado')
>>> foo = salgado.assignKarma('bugfixed')
>>> salgado.karma
0

The value that you get through IPerson.karma is a cached value that's
calculated daily. That's why it still 0. To calculate the karma of a given
person at runtime we can use the updateKarmaCache method of IPerson.

>>> from canonical.launchpad.interfaces import IKarmaSet
>>> salgado.updateKarmaCache()
>>> salgado.karma
10


Searching
---------

You can search based on a person's name/displayname/givenname/familyname or
any of the email addresses that belongs to a person using the methods provided
by IPersonSet.

While we don't have Full Text Indexes in the emailaddress table, we'll be
trying to match the text only against the beginning of an email address:

>>> results = personset.find('ubuntu')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Sigurd Gartmann', u'sigurd-ubuntu', [u'sigurd-ubuntu@brogar.org'])
(u'Ubuntu Gnome Team', u'name18', [])
(u'Ubuntu Team', u'name17', [u'support@ubuntu.com'])
(u'Ubuntu Translators', u'ubuntu-translators', [])

>>> results = personset.find('steve.alexander')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Steve Alexander', u'stevea', [u'steve.alexander@ubuntulinux.com'])


Searching only for People based on their names or email addresses:

>>> results = personset.findPerson('james.blackwell')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'James Blackwell', u'jblack', [u'james.blackwell@ubuntulinux.com'])

>>> results = personset.findPerson('dave')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Dave Miller', u'justdave', [u'dave.miller@ubuntulinux.com', u'justdave@bugzilla.org'])


Searching only for Teams based on their names or email addresses:

>>> results = personset.findTeam('support')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Ubuntu Team', u'name17', [u'support@ubuntu.com'])

>>> results = personset.findTeam('translators')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Ubuntu Translators', u'ubuntu-translators', [])


Packages related to a person
----------------------------

To obtain the packages a person is related to, we should use the
maintainedPackages() and uploadedButNotMaintainedPackages() methods of
IPersonSet. The former will return all SourcePackageReleases a person is
listed as the Maintainer, while the latter will return all
SourcePackageReleases that a person created (uploaded) but is not the
Maintainer.

>>> sabdfl = personset.getByName('sabdfl')
>>> for sprelease in sabdfl.maintainedPackages():
...     print (sprelease.name, sprelease.uploaddistrorelease.fullreleasename,
...            sprelease.version)
(u'alsa-utils', u'Ubuntu Warty', u'1.0.8-1ubuntu1')
(u'alsa-utils', u'Debian Sid', u'1.0.9a-4')
(u'evolution', u'Ubuntu Hoary', u'1.0')
(u'mozilla-firefox', u'Ubuntu Hoary', u'0.9')
(u'netapplet', u'Ubuntu Hoary', u'1.0-1')
(u'netapplet', u'Ubuntu Warty', u'0.99.6-1')
(u'pmount', u'Ubuntu Hoary', u'0.1-1')
(u'pmount', u'Ubuntu Hoary', u'0.1-2')

>>> for sprelease in sabdfl.uploadedButNotMaintainedPackages():
...     print (sprelease.name, sprelease.uploaddistrorelease.fullreleasename,
...            sprelease.version)
(u'alsa-utils', u'Ubuntu Hoary', u'1.0.9a-4ubuntu1')

