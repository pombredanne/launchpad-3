Bug Notification Email
======================

This document describes the internal workings of how bug notification
emails are generated and how said emails are formatted. It does not
cover the various rules and semantics surrounding the notifications
themselves; for that, see bugnotifications.txt.

The reference spec associated with this document is available on the
Launchpad wiki:

    https://wiki.launchpad.canonical.com/FormattingBugNotifications

You need to be logged in to edit bugs in Malone, so let's get started:

    >>> from canonical.launchpad.ftests import login
    >>> login("test@canonical.com")

To avoid having one gargantuan super function that formats any kind of
object it gets passed, the formatting logic has been cut into three
pieces: generate_bug_edit_email, generate_bug_add_email and
generate_bug_comment_email:

    >>> from canonical.launchpad.mailnotification import (
    ...     generate_bug_add_email, generate_bug_edit_email,
    ...     generate_bug_comment_email)

Let's demonstrate what the bugmails will look like, by going through
the various events that can happen that would cause a notification to
be sent. We'll start by importing some things we'll need for the
examples that follow:

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IBugDelta, IBugSet, IPersonSet, IBugMessageSet, IBugTaskSet,
    ...     ICve)
    >>> from canonical.launchpad.components.bug import BugDelta

Filing a bug
------------

generate_bug_add_email accepts one argument: the IBug that was just
added. With that, it generates an appropriately-formatted notification
message, and returns it as a (subject, body) tuple.

So, let's pretend that we filed bug 4 just now:

    >>> bug_four = getUtility(IBugSet).get(4)

Let's take a look at what the notification email looks like:

    >>> subject, body = generate_bug_add_email(bug_four)
    >>> subject
    u'[Bug 4] Reflow problems with complex page layouts'
    >>> print body
    Public bug reported:
    http://.../malone/bugs/4
    <BLANKLINE>
    Affects: firefox (upstream)
           Severity: Normal
           Priority: Medium
             Status: New
    <BLANKLINE>
    Description:
    Malone pages that use more complex layouts with portlets and fancy CSS are
    sometimes not getting properly reflowed after rendering.

Adding a bug comment
--------------------

generate_bug_comment_email accepts an object that provides
IBugMessage. Let's borrow the first comment on bug four, just to
demonstrate how the comment notification is formatted:

   >>> bugmessage = getUtility(IBugMessageSet).get(4)
   >>> subject, body = generate_bug_comment_email(bugmessage)
   >>> subject
   u'[Bug 2] Blackhole Trash folder'
   >>> print body
   Public bug report changed:
   http://.../malone/bugs/2
   <BLANKLINE>
   Comment:
   This would be a real killer feature. If there is already code to
   make it possible, why aren't there tons of press announcements
   about the secuirty possibilities. Imagine - no more embarrassing
   emails for Mr Gates... everything they delete would actually
   disappear! I'm sure Redmond will switch over as soon as they hear
   about this. It's not a bug, it's a feature!

Editing a bug
-------------

generate_bug_edit_email accepts an object that provides IBugDelta, and
returns the subject and body of the email, as a tuple.

   >>> sample_person = getUtility(IPersonSet).get(12)
   >>> edited_bug = getUtility(IBugSet).get(2)

    >>> edited_bug.title = "the new title"
    >>> edited_bug.description = """\
    ... a new description that is quite long. but the nice thing is that the edit notification email generator knows how to indent and wrap descriptions, so this will appear quite nice in the actual email that gets sent.\n\nit's also smart enough to preserve whitespace, finally!"""

    >>> bug_delta = BugDelta(
    ...     bug = edited_bug,
    ...     bugurl = "http://www.example.com/bugs/2",
    ...     user = sample_person,
    ...     title = edited_bug.title,
    ...     description = edited_bug.description)
    >>> IBugDelta.providedBy(bug_delta)
    True

    >>> subject, body = generate_bug_edit_email(bug_delta)
    >>> subject
    u'[Bug 2] the new title'
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://.../bugs/2
    <BLANKLINE>
    Summary changed to:
        the new title
    Description changed to:
        a new description that is quite long. but the nice thing is that the
        edit notification email generator knows how to indent and wrap
        descriptions, so this will appear quite nice in the actual email
        that gets sent.
    <BLANKLINE>
        it's also smart enough to preserve whitespace, finally!
    <BLANKLINE>

Another edit, this time the summary:

    >>> edited_bug.summary = "this summary isn't particularly short is it? after all, what kind of summary is so long that it needs to be wrapped?"

    >>> bug_delta = BugDelta(
    ...     bug = edited_bug,
    ...     bugurl = "http://www.example.com/bugs/2",
    ...     user = sample_person,
    ...     summary = edited_bug.summary)
    >>> subject, body = generate_bug_edit_email(bug_delta)
    >>> subject
    u'[Bug 2] the new title'
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://www.example.com/bugs/2
    <BLANKLINE>
    Short description changed to:
        this summary isn't particularly short is it? after all, what kind of
        summary is so long that it needs to be wrapped?
    <BLANKLINE>

Let's set the bug private (for demo purposes, we need to switch logins
to a user that is explicitly subscribed to this bug):

    >>> login("steve.alexander@ubuntulinux.com")

    >>> edited_bug.private = True
    >>> bug_delta = BugDelta(
    ...     bug = edited_bug,
    ...     bugurl = "http://www.example.com/bugs/2",
    ...     user = sample_person,
    ...     private = {'old' : False, 'new' : edited_bug.private})
    >>> subject, body = generate_bug_edit_email(bug_delta)
    >>> subject
    u'[Bug 2] the new title'
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Private bug report changed:
    http://.../bugs/2
    <BLANKLINE>
    Secrecy changed to:
        Private
    <BLANKLINE>

Now we set the bug public and check if the e-mail sent changed as well.

    >>> edited_bug.private = False 
    >>> bug_delta = BugDelta(
    ...     bug = edited_bug,
    ...     bugurl = "http://www.example.com/bugs/2",
    ...     user = sample_person,
    ...     private = {'old' : True, 'new' : edited_bug.private})
    >>> subject, body = generate_bug_edit_email(bug_delta)
    >>> subject
    u'[Bug 2] the new title'
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://.../bugs/2
    <BLANKLINE>
    Secrecy changed to:
        Public
    <BLANKLINE>

Adding a new bug task
---------------------

Because adding a new task is sort of like "editing" a bug,
generate_bug_edit_email handles generating the email when a new task
is added to a bug. To demonstrate what this email looks like, let's
pretend we had just added task five:

   >>> task_five = getUtility(IBugTaskSet).get(5)

   >>> bug_delta = BugDelta(
   ...     bug = edited_bug,
   ...     bugurl = "http://www.example.com/bugs/2",
   ...     user = sample_person,
   ...     added_bugtasks = task_five)
   >>> subject, body = generate_bug_edit_email(bug_delta)
   >>> subject
   u'[Bug 2] the new title'
   >>> print body
   Public bug report changed:
   http://.../bugs/2
   <BLANKLINE>
   Also affects: mozilla-firefox (debian)
          Severity: Minor
          Priority: High
          Assignee: name12 <test@canonical.com>
            Status: Accepted

Editing a bug task
------------------

As you might expect, generate_bug_edit_email handles generating the
bugmail when a bug task is edited.

    >>> from canonical.launchpad.interfaces import IBugTaskDelta, IBugTaskSet
    >>> from canonical.launchpad.components.bugtask import BugTaskDelta
    >>> from canonical.lp.dbschema import BugTaskStatus

    >>> edited_bugtask = getUtility(IBugTaskSet).get(3)
    >>> edited_bugtask.status = BugTaskStatus.ACCEPTED
    >>> edited_bugtask.assignee = sample_person.id
    >>> edited_bugtask.statusexplanation = "i'm just babbling here to ensure line wrapping works in the explanation."
    >>> bugtask_delta = BugTaskDelta(
    ...     bugtask=edited_bugtask,
    ...     status={'old' : BugTaskStatus.NEW, 'new' : edited_bugtask.status},
    ...     assignee={'old' : None, 'new' : edited_bugtask.assignee},
    ...     statusexplanation=edited_bugtask.statusexplanation)
    >>> bug_delta = BugDelta(
    ...     bug = edited_bug,
    ...     bugurl = "http://www.example.com/bugs/2",
    ...     user = sample_person,
    ...     bugtask_deltas = bugtask_delta)
    >>> subject, body = generate_bug_edit_email(bug_delta)
    >>> subject
    u'[Bug 2] the new title'
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://.../bugs/2
    <BLANKLINE>
    Changed in: Ubuntu (upstream)
           Assignee: (unassigned) => Sample Person
             Status: New => Accepted
        Explanation: i'm just babbling here to ensure line wrapping works in
                     the explanation.
    <BLANKLINE>

Adding and editing web links
----------------------------

Adding a web link can be seen as "editing" a bug.

    >>> from zope.interface import implements
    >>> from canonical.launchpad.interfaces import IBugExternalRef
    >>> class MockBugExtRef:
    ...     implements(IBugExternalRef)
    ...     def __init__(self, bug, url, title, owner):
    ...         self.bug = bug
    ...         self.url = url
    ...         self.title = title
    ...         self.owner = owner
    >>> mock_ext_ref = MockBugExtRef(
    ...     bug = edited_bug,
    ...     url = "http://www.example.com/foo/bar",
    ...     title = "some title",
    ...     owner = sample_person.id)

    >>> bug_delta = BugDelta(
    ...     bug = edited_bug,
    ...     bugurl = "http://www.example.com/bugs/2",
    ...     user = sample_person,
    ...     external_reference = {'new': mock_ext_ref})
    >>> subject, body = generate_bug_edit_email(bug_delta)
    >>> subject
    u'[Bug 2] the new title'
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://www.example.com/bugs/2
    <BLANKLINE>
    Web links changed:
        + http://www.example.com/foo/bar (some title)
    <BLANKLINE>

Editing a web link shows the previous link as "Removed" and the newly
modified link as having been "Added" (though no actual "adding" or
"deleting" is actually taking place in the database.)

    >>> mock_ext_ref_edited = MockBugExtRef(
    ...     bug = edited_bug,
    ...     url = "http://www.example.com/foo/bar",
    ...     title = "some better title",
    ...     owner = sample_person.id)

    >>> bug_delta = BugDelta(
    ...     bug = edited_bug,
    ...     bugurl = "http://www.example.com/bugs/2",
    ...     user = sample_person,
    ...     external_reference = {
    ...         'old' : mock_ext_ref, 'new': mock_ext_ref_edited})
    >>> subject, body = generate_bug_edit_email(bug_delta)
    >>> subject
    u'[Bug 2] the new title'
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://www.example.com/bugs/2
    <BLANKLINE>
    Web links changed:
        + http://www.example.com/foo/bar (some better title)
        - http://www.example.com/foo/bar (some title)
    <BLANKLINE>

Adding and editing bug watches
------------------------------

Here's an example that demonstrates the notification email that gets
generated when a bug watch is added:

    >>> from canonical.launchpad.interfaces import IBugWatch, IBugTrackerSet
    >>> bugtrackerset = getUtility(IBugTrackerSet)

    >>> class MockBugWatch:
    ...     implements(IBugWatch)
    ...     def __init__(self, bug, bugtracker, remotebug):
    ...         self.bug = bug
    ...         self.bugtracker = bugtracker
    ...         self.remotebug = remotebug
    >>> mock_bug_watch = MockBugWatch(
    ...     bug = edited_bug,
    ...     bugtracker = getUtility(IBugTrackerSet)["mozilla.org"],
    ...     remotebug = 123)

    >>> bug_delta = BugDelta(
    ...     bug = edited_bug,
    ...     bugurl = "http://www.example.com/bugs/2",
    ...     user = sample_person,
    ...     bugwatch = {'new' : mock_bug_watch})
    >>> subject, body = generate_bug_edit_email(bug_delta)
    >>> subject
    u'[Bug 2] the new title'
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://www.example.com/bugs/2
    <BLANKLINE>
    Bug watches changed:
        + Bug 123 [The Mozilla.org Bug Tracker]
    <BLANKLINE>

When edited, we display the change to a bug watch as though the
previous data was "removed" and the new, current data was "added."
Let's demonstrate with an example:

    >>> mock_bug_watch_edited = MockBugWatch(
    ...     bug = edited_bug,
    ...     bugtracker = getUtility(IBugTrackerSet)["mozilla.org"],
    ...     remotebug = 12)

    >>> bug_delta = BugDelta(
    ...     bug = edited_bug,
    ...     bugurl = "http://www.example.com/bugs/2",
    ...     user = sample_person,
    ...     bugwatch =
    ...         {'old' : mock_bug_watch, 'new' : mock_bug_watch_edited})
    >>> subject, body = generate_bug_edit_email(bug_delta)
    >>> subject
    u'[Bug 2] the new title'
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://www.example.com/bugs/2
    <BLANKLINE>
    Bug watches changed:
        + Bug 12 [The Mozilla.org Bug Tracker]
        - Bug 123 [The Mozilla.org Bug Tracker]
    <BLANKLINE>

Adding and editing CVE relationships
------------------------------------

Adding a CVE will generate a notification that looks as follows:

    >>> from canonical.launchpad.interfaces import IBugCve
    >>> from canonical.lp.dbschema import CveStatus

    >>> class MockCVE:
    ...     implements(ICve)
    ...     def __init__(self, sequence, status, description):
    ...         self.sequence = sequence
    ...         self.status = status
    ...         self.displayname = 'CVE-' + sequence
    ...         self.description = description
    ...     @property
    ...     def title(self):
    ...         return '%s (%s)' % (self.displayname, self.status.title)
    >>> mock_cve = MockCVE(
    ...     sequence = "2004-0718",
    ...     status = CveStatus.CANDIDATE,
    ...     description = "a test cve ref")

    >>> bug_delta = BugDelta(
    ...     bug = edited_bug,
    ...     bugurl = "http://www.example.com/bugs/2",
    ...     user = sample_person,
    ...     cve = {'new' : mock_cve})
    >>> subject, body = generate_bug_edit_email(bug_delta)
    >>> subject
    u'[Bug 2] the new title'
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://www.example.com/bugs/2
    <BLANKLINE>
    Added CVE-2004-0718 (Candidate)
    <BLANKLINE>

Similarly, removing a CVE ref will result in an email:

    >>> mock_cve_ref_removed = MockCVE(
    ...     sequence = "2004-0719",
    ...     status = CveStatus.CANDIDATE,
    ...     description = "a test cve ref")

    >>> bug_delta = BugDelta(
    ...     bug = edited_bug,
    ...     bugurl = "http://www.example.com/bugs/2",
    ...     user = sample_person,
    ...     cve = {'old' : mock_cve_ref_removed})
    >>> subject, body = generate_bug_edit_email(bug_delta)
    >>> subject
    u'[Bug 2] the new title'
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://www.example.com/bugs/2
    <BLANKLINE>
    Removed CVE-2004-0719 (Candidate)
    <BLANKLINE>

Adding an infestation
---------------------

   XXX: Brad Bollenbach, 2005-04-11: I'm not going to touch anything
   infestation-related for the moment, until we have these things
   better figured out (i.e. how exactly we want to use them, etc.)
