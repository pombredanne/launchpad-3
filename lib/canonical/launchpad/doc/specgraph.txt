= Specification graphs =

A SpecGraph object manages a set of SpecNodes and the edges that connect the
nodes.  It knows how to output itself in `dot` format, for use by Graphviz.

A SpecGraph has a root node, and then various other nodes.  You can make
connections between nodes using its 'link' method.  Each node is identified by
its name, which is the database name of the specification that the node
represents.

Use the SpecGraph as a factory for creating new nodes.  This allows the
SpecGraph to keep track of the nodes that have been added.


    >>> from canonical.launchpad.browser.specification import SpecGraph
    >>> g = SpecGraph()
    >>> g.url_pattern_for_testing = 'http://whatever/%s'

    >>> class Spec(object):
    ...
    ...     def __init__(self, name,
    ...             is_complete=False, title=None, assignee=None):
    ...         self.name = name
    ...         self.title = title or name
    ...         self.is_complete = is_complete
    ...         self.assignee = assignee
    ...         # Use lists here to ensure that the code converts them
    ...         # to sets explicitly, like it has to do for SelectResults.
    ...         self.dependencies = []
    ...         # This is a hack for testing: we can set up dependencies,
    ...         # and simply use their "mirror image" for blocked specs.
    ...         self.blocked_specs = self.dependencies

    >>> foo = Spec('foo', title='something with " and \n in it')
    >>> root = g.newNode(foo, root=True)

    >>> print root
    <foo>

Note that the root DOT data doesn't have a URL.  This is because we don't
want a link to the spec we're currently looking at.

    >>> print root.getDOTNodeStatement()
    "foo"
        [
        "color"="red",
        "comment"="something with \" and \n in it",
        "label"="foo",
        "tooltip"="something with \" and \n in it"
        ]

    >>> print g.root_node
    <foo>
    >>> print root.name, root.label, root.URL, root.color
    foo foo http://whatever/foo red
    >>> g.getNode('no such name') is None
    True
    >>> g.getNode('foo') is root
    True
    >>> print g.listNodes()
    Root is <foo>
    <foo>:

    >>> foo1 = Spec('foo1')
    >>> foo.dependencies.append(foo1)
    >>> foo2 = Spec('foo2')
    >>> foo.dependencies.append(foo2)
    >>> foo11 = Spec('foo11')
    >>> foo1.dependencies.append(foo11)
    >>> foo111 = Spec('foo111')
    >>> foo11.dependencies.append(foo111)

    >>> def make_graph(dependency, blocked):
    ...     g = SpecGraph()
    ...     g.url_pattern_for_testing = 'http://whatever/%s'
    ...     root = g.newNode(foo, root=True)
    ...     if dependency:
    ...         g.addDependencyNodes(foo)
    ...     if blocked:
    ...         g.addBlockedNodes(foo)
    ...     return g

    >>> def print_graph(dependency=True, blocked=False):
    ...     print make_graph(dependency, blocked).listNodes()

    >>> def print_graph_dot(dependency=True, blocked=False):
    ...     print make_graph(dependency, blocked).getDOTGraphStatement()

    >>> print_graph()
    Root is <foo>
    <foo>:
    <foo1>:
        foo
    <foo11>:
        foo1
    <foo111>:
        foo11
    <foo2>:
        foo

   >>> print_graph_dot()
   digraph "deptree" {
   graph
       [
       "bgcolor"="#ffffff",
       "mode"="hier",
       "nodesep"="0.25",
       "ranksep"="0.25",
       "ratio"="auto",
       "size"="5.2,9"
       ]
   node
       [
       "fillcolor"="white",
       "fontname"="Sans",
       "fontsize"="11",
       "style"="filled"
       ]
   edge
       [
       "arrowhead"="normal"
       ]
   "foo"
       [
       "color"="red",
       "comment"="something with \" and \n in it",
       "label"="foo",
       "tooltip"="something with \" and \n in it"
       ]
   "foo1"
       [
       "URL"="http://whatever/foo1",
       "color"="black",
       "comment"="foo1",
       "label"="foo1",
       "tooltip"="foo1"
       ]
   "foo11"
       [
       "URL"="http://whatever/foo11",
       "color"="black",
       "comment"="foo11",
       "label"="foo11",
       "tooltip"="foo11"
       ]
   "foo111"
       [
       "URL"="http://whatever/foo111",
       "color"="black",
       "comment"="foo111",
       "label"="foo111",
       "tooltip"="foo111"
       ]
   "foo2"
       [
       "URL"="http://whatever/foo2",
       "color"="black",
       "comment"="foo2",
       "label"="foo2",
       "tooltip"="foo2"
       ]
   "foo1" -> "foo"
   "foo11" -> "foo1"
   "foo111" -> "foo11"
   "foo2" -> "foo"
   }


Now, add a circle at the top.

    >>> foo1.dependencies.append(foo)
    >>> print_graph()
    Root is <foo>
    <foo>:
        foo1
    <foo1>:
        foo
    <foo11>:
        foo1
    <foo111>:
        foo11
    <foo2>:
        foo


Now add another circle at the bottom.

    >>> foo111.dependencies.append(foo1)
    >>> print_graph()
    Root is <foo>
    <foo>:
        foo1
    <foo1>:
        foo
        foo111
    <foo11>:
        foo1
    <foo111>:
        foo11
    <foo2>:
        foo

Now make it even more convoluted, for fun.

    >>> foo111.dependencies.append(foo)
    >>> foo2.dependencies.append(foo1)
    >>> foo1.dependencies.append(foo2)
    >>> print_graph()
    Root is <foo>
    <foo>:
        foo1
        foo111
    <foo1>:
        foo
        foo111
        foo2
    <foo11>:
        foo1
    <foo111>:
        foo11
    <foo2>:
        foo
        foo1


And finally, try checking out the blocked specs too.  Because of the hack
earlier, we have a "mirror image" of the dependencies in the blocked speces.

    >>> print_graph(dependency=False, blocked=True)
    Root is <foo>
    <foo>:
        foo1
        foo2
    <foo1>:
        foo
        foo11
        foo2
    <foo11>:
        foo111
    <foo111>:
        foo
        foo1
    <foo2>:
        foo1


== SpecificationTreeImageTag and SpecificationView ==

The SpecificationTreeImageTag subclass will generate a HTML image map
tag when the render() method is called.

    >>> from zope.component import getMultiAdapter
    >>> from canonical.launchpad.browser.specification import (
    ...     SpecificationTreeImageTag)
    >>> from canonical.launchpad.interfaces import IProductSet
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> svg_support = firefox.getSpecification('svg-support')
    >>> request = LaunchpadTestRequest(form={})
    >>> graph_view = getMultiAdapter(
    ...     (svg_support, request), name="+deptreeimgtag")
    >>> graph_view.initialize()
    >>> isinstance(graph_view, SpecificationTreeImageTag)
    True

    >>> print graph_view.render()
    <img src="deptree.png" usemap="#deptree" />
    <map id="deptree" name="deptree"> ...

The real work of converting the graph data into an image map is done by
the renderGraphvizGraph() method from the view's parent class. The
method will make an image map when 'cmapx' is passed as an argument; It
also makes PNG images when it is passed 'png' as an argument.

    >>> graph_view.renderGraphvizGraph('cmapx')
    '<map id="deptree" name="deptree">...'

The SpecificationTreeImageTag view is indirectly called when the spec's
+index template calls render().

    >>> login('no-priv@canonical.com', request)
    >>> page_view = getMultiAdapter((svg_support, request), name="+index")
    >>> page_view.initialize()
    >>> content = page_view.render()
    >>> image_start = content.find('<map id="deptree"')
    >>> content[image_start:image_start + 33]
    u'<map id="deptree" name="deptree">'


== renderGraphvizGraph() error handling ==

The renderGraphvizGraph() method may raise a ProblemRenderingGraph error
running the subprocess. The error could be caused because the
data sent to the command is bad:

    # Replace getDotFileText() with a fake function that will return
    # bad data.
    >>> from canonical.launchpad.browser import specification
    >>> graph_view_class = specification.SpecificationTreeGraphView
    >>> original_getDotFileText = graph_view_class.getDotFileText
    >>> def fake_getDotFileText(format):
    ...     return 'bad data'
    >>> graph_view_class.getDotFileText = fake_getDotFileText

    >>> graph_view = getMultiAdapter(
    ...     (svg_support, request), name="+deptreeimgtag")
    >>> graph_view.initialize()
    >>> graph_view.renderGraphvizGraph('cmapx')
    Traceback (most recent call last):
     ...
    ProblemRenderingGraph: ("<stdin>:1: syntax error in line 1 near 'bad'...)

The SpecificationTreeImageTag.render() method captures the raised
error and directly converts it into an oops report. The markup contains
a message explaining that the image was not linked.

    >>> print graph_view.render()
    <img src="deptree.png" usemap="#deptree" />
    <p class="error message">There was an error linking the dependency tree
    to its specs.</p>

    >>> from zope.app.error.interfaces import IErrorReportingUtility
    >>> globalErrorUtility = getUtility(IErrorReportingUtility)
    >>> oops_report = globalErrorUtility.getLastOopsReport()
    >>> print oops_report.type, oops_report.value
    ProblemRenderingGraph ("<stdin>:1: syntax error in line 1 near 'bad'...)

    # Restore the getDotFileText() method.
    >>> graph_view_class.getDotFileText = original_getDotFileText

The renderGraphvizGraph() pipes data to a subprocess. That subprocess
can raise errors like OSError.

    # Replace the Popen object with a fake function that will raise
    # an OSError.
    >>> original_popen = specification.Popen
    >>> def fake_popen(*args, **kwargs):
    ...     raise OSError(12, 'Cannot allocate memory')
    >>> specification.Popen = fake_popen

    >>> graph_view = getMultiAdapter(
    ...     (svg_support, request), name="+deptreeimgtag")
    >>> graph_view.initialize()
    >>> graph_view.renderGraphvizGraph('cmapx')
    Traceback (most recent call last):
     ...
    OSError: [Errno 12] Cannot allocate memory

The OSError raised creating the image map does not break the spec index
page. Again, the image map was replaced with an suggestion to reload
the page to link the image.

    >>> print graph_view.render()
    <img src="deptree.png" usemap="#deptree" />
    <p class="error message">There was an error linking the dependency tree
    to its specs. Reload the page to link the image.</p>

    >>> oops_report = globalErrorUtility.getLastOopsReport()
    >>> print oops_report.type, oops_report.value
    OSError [Errno 12] Cannot allocate memory

If an error occurs during the render of the PNG image, the fail
over image (icing/blueprints-deptree-error.png) is returned. It's size
is 3092 bytes.

    >>> graph_view = getMultiAdapter(
    ...     (svg_support, request), name="deptree.png")
    >>> graph_view.initialize()
    >>> graph_view.renderGraphvizGraph('png')
    Traceback (most recent call last):
     ...
    OSError: [Errno 12] Cannot allocate memory

    >>> image = graph_view.render()
    >>> image.startswith('\x89PNG')
    True

    >>> fail_over_image_length = len(image)
    >>> fail_over_image_length
    3092

The dependency graph image is rendered correctly when Popen is
restored.

    # Restore the Popen object.
    >>> specification.Popen = original_popen

    >>> graph_view = getMultiAdapter(
    ...     (svg_support, request), name="deptree.png")
    >>> graph_view.initialize()
    >>> image = graph_view.render()
    >>> image.startswith('\x89PNG')
    True

    >>> len(image) != fail_over_image_length
    True
