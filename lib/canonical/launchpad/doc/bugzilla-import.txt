Bugzilla Import
===============

The bugzilla import process makes use of a direct connection to the
database.  In order to aid in testing, all the database accesses are
performed through a single class that can be replaced.

We will start by defining a fake backend and some fake information for
it to return:

  >>> from datetime import datetime
  >>> import pytz
  >>> UTC = pytz.timezone('UTC')

  >>> users = [
  ...     ('test@canonical.com', 'Sample User'),
  ...     ('foo.bar@canonical.com', 'Foo Bar'),
  ...     ('new.user@canonical.com', 'New User')  # <- not in Launchpad
  ...     ]

  >>> buginfo = [
  ...         (1,                 # bug_id
  ...          1,                 # assigned_to
  ...          '',                # bug_file_loc
  ...          'normal',          # bug_severity
  ...          'NEW',             # status
  ...          datetime(2005, 4, 1, tzinfo=UTC), # creation
  ...          'Test bug 1',      # short_desc,
  ...          'Linux',           # op_sys
  ...          'P2',              # priority
  ...          'Ubuntu',          # product
  ...          'AMD64',           # rep_platform
  ...          1,                 # reporter
  ...          '---',             # version
  ...          'mozilla-firefox', # component
  ...          '',                # resolution
  ...          'Ubuntu 5.10',     # milestone
  ...          0,                 # qa_contact
  ...          'status',          # status_whiteboard
  ...          '',                # keywords
  ...          ''),               # alias
  ...         # A WONTFIX bug on a non-existant distro package
  ...         (2, 1, 'http://www.ubuntu.com', 'enhancement', 'RESOLVED',
  ...          datetime(2005, 4, 2, tzinfo=UTC), 'Test bug 2',
  ...          'Linux', 'P1', 'Ubuntu', 'i386', 2, '---', 'unknown',
  ...          'WONTFIX', '---', 0, '', '', ''),
  ...         # An accepted bug:
  ...         (3, 2, 'http://www.ubuntu.com', 'blocker', 'ASSIGNED',
  ...          datetime(2005, 4, 3, tzinfo=UTC), 'Test bug 3',
  ...          'Linux', 'P1', 'Ubuntu', 'i386', 1, '---', 'netapplet',
  ...          '', '---', 0, '', '', 'xyz'),
  ...         # A fixed bug
  ...         (4, 1, 'http://www.ubuntu.com', 'blocker', 'CLOSED',
  ...          datetime(2005, 4, 4, tzinfo=UTC), 'Test bug 4',
  ...          'Linux', 'P1', 'Ubuntu', 'i386', 1, '---', 'mozilla-firefox',
  ...          'FIXED', '---', 0, '', '', 'FooBar'),
  ...         # An UPSTREAM bug
  ...         (5, 1, 'http://bugzilla.gnome.org/show_bug.cgi?id=273041',
  ...          'blocker', 'UPSTREAM',
  ...          datetime(2005, 4, 4, tzinfo=UTC), 'Test bug 5',
  ...          'Linux', 'P1', 'Ubuntu', 'i386', 1, '---', 'evolution',
  ...          '', '---', 0, '', '', 'deb1234'),
  ...     ]

  >>> ccs = [[], [3], [], [], []]

  >>> comments = [
  ...     [(1, datetime(2005, 4, 1, tzinfo=UTC), 'First comment'),
  ...      (2, datetime(2005, 4, 1, 1, tzinfo=UTC), 'Second comment')],
  ...     [(1, datetime(2005, 4, 2, tzinfo=UTC), 'First comment'),
  ...      (2, datetime(2005, 4, 2, 1, tzinfo=UTC), 'Second comment')],
  ...     [(2, datetime(2005, 4, 3, tzinfo=UTC), 'First comment'),
  ...      (1, datetime(2005, 4, 3, 1, tzinfo=UTC),
  ...       'This is related to CVE-2005-1234'),
  ...      (2, datetime(2005, 4, 3, 2, tzinfo=UTC),
  ...       'Created an attachment (id=1)')],
  ...     [(1, datetime(2005, 4, 4, tzinfo=UTC), 'First comment')],
  ...     [(1, datetime(2005, 4, 5, tzinfo=UTC), 'First comment')],
  ...     ]

  >>> attachments = [
  ...     [], [],
  ...     [(1, datetime(2005, 4, 3, 2, tzinfo=UTC), 'An attachment',
  ...       'text/x-patch', True, 'foo.patch', 'the data', 2)],
  ...     [], []
  ...     ]

  >>> duplicates = [
  ...     (1, 2),
  ...     (2, 3),
  ...     (2, 4),
  ...     ]

  >>> class FakeBackend:
  ...     def lookupUser(self, user_id):
  ...         return users[user_id - 1]
  ...     def getBugInfo(self, bug_id):
  ...         return buginfo[bug_id - 1]
  ...     def getBugCcs(self, bug_id):
  ...         return ccs[bug_id - 1]
  ...     def getBugComments(self, bug_id):
  ...         return comments[bug_id - 1]
  ...     def getBugAttachments(self, bug_id):
  ...         return attachments[bug_id - 1]
  ...     def getDuplicates(self):
  ...         return duplicates

  >>> from zope.component import getUtility
  >>> from canonical.launchpad.ftests import login, ANONYMOUS
  >>> from canonical.launchpad.interfaces import (
  ...     BugTrackerType, IPersonSet, IBugSet, IBugTrackerSet,
  ...     ILaunchpadCelebrities)
  >>> from canonical.launchpad.scripts import bugzilla

Get a reference to the Ubuntu bug tracker, and log in:

  >>> login('bug-importer@launchpad.net')
  >>> bugtracker = getUtility(ILaunchpadCelebrities).ubuntu_bugzilla

Now we create a bugzilla.Bugzilla instance to handle the import, using
our fake backend data:

  >>> bz = bugzilla.Bugzilla(None)
  >>> bz.backend = FakeBackend()

In order to verify that things get imported correctly, the following
function will be used:

  >>> def bugInfo(bug):
  ...     print 'Title:', bug.title
  ...     print 'Reporter:', bug.owner.displayname
  ...     print 'Created:', bug.datecreated
  ...     if bug.name:
  ...         print 'Nick: %s' % bug.name
  ...     print 'Subscribers:'
  ...     subscriber_names = sorted(
  ...         p.displayname for p in (bug.getDirectSubscribers() +
  ...                                 bug.getIndirectSubscribers()))
  ...     for subscriber_name in subscriber_names:
  ...         print '    %s' % subscriber_name
  ...     for task in bug.bugtasks:
  ...         print 'Task:', task.bugtargetdisplayname
  ...         print '    Status:', task.status.name
  ...         if task.product:
  ...             print '    Product:', task.product.name
  ...         if task.distribution:
  ...             print '    Distro:', task.distribution.name
  ...         if task.sourcepackagename:
  ...             print '    Source package:', task.sourcepackagename.name
  ...         if task.assignee:
  ...             print '    Assignee:', task.assignee.displayname
  ...         if task.importance:
  ...             print '    Importance:', task.importance.name
  ...         if task.statusexplanation:
  ...             print '    Explanation:', task.statusexplanation
  ...         if task.milestone:
  ...             print '    Milestone:', task.milestone.name
  ...         if task.bugwatch:
  ...             print '    Watch:', task.bugwatch.url
  ...     if bug.cves:
  ...         print 'CVEs:'
  ...     for cve in bug.cves:
  ...         print '    %s' % cve.displayname
  ...     print 'Messages:'
  ...     for message in bug.messages:
  ...         print '    Author:', message.owner.displayname
  ...         print '    Date:', message.datecreated
  ...         print '    Subject:', message.subject
  ...         print '    %s' % message.text_contents
  ...         print
  ...     if bug.attachments:
  ...         print 'Attachments:'
  ...     for attachment in bug.attachments:
  ...         print '    Title:', attachment.title
  ...         print '    Type:', attachment.type.name
  ...         print '    Name:', attachment.libraryfile.filename
  ...         print '    Mime type:', attachment.libraryfile.mimetype


Now we import bug #1 and check the results:

  >>> bug = bz.handleBug(1)
  >>> bugInfo(bug)
  Title: Test bug 1
  Reporter: Sample Person
  Created: 2005-04-01 00:00:00+00:00
  Subscribers:
      Foo Bar
      Sample Person
  Task: mozilla-firefox (Ubuntu)
      Status: NEW
      Distro: ubuntu
      Source package: mozilla-firefox
      Assignee: Sample Person
      Importance: MEDIUM
      Explanation: status (Bugzilla status=NEW, product=Ubuntu, component=mozilla-firefox)
      Milestone: ubuntu-5.10
  Messages:
      Author: Sample Person
      Date: 2005-04-01 00:00:00+00:00
      Subject: Test bug 1
      First comment
  <BLANKLINE>
      Author: Foo Bar
      Date: 2005-04-01 01:00:00+00:00
      Subject: Re: Test bug 1
      Second comment
  <BLANKLINE>

As well as importing the bug, a bug watch is created, linking the new
Launchpad bug to the original Bugzilla bug:

  >>> linked_bug = getUtility(IBugSet).queryByRemoteBug(bugtracker, 1)
  >>> linked_bug == bug
  True

This bug watch link is used to prevent multiple imports of the same
bug.

  >>> second_import = bz.handleBug(1)
  >>> bug == second_import
  True


Next we try bug #2, which is assigned to a non-existant source
package, so gets filed directly against the distribution.  Some things
to notice:

 * A Launchpad account is created for new.user@canonical.com as a side
   effect of the import, because they are subscribed to the bug.
 * The "RESOLVED WONTFIX" status is converted to a status of INVALID.
 * The fact that the "unknown" package does not exist in Ubuntu has
   been logged, along with the exception raised by guessPackageNames().

  >>> print getUtility(IPersonSet).getByEmail('new.user@canonical.com')
  None
  >>> bug = bz.handleBug(2)
  WARNING:canonical.launchpad.scripts.bugzilla:could not find package name for "unknown": 'Unknown package: unknown'

  >>> bugInfo(bug)
  Title: Test bug 2
  Reporter: Foo Bar
  Created: 2005-04-02 00:00:00+00:00
  Subscribers:
      Foo Bar
      New User
      Sample Person
  Task: Ubuntu
      Status: INVALID
      Distro: ubuntu
      Assignee: Sample Person
      Importance: WISHLIST
      Explanation: Bugzilla status=RESOLVED WONTFIX, product=Ubuntu, component=unknown
  Messages:
      Author: Sample Person
      Date: 2005-04-02 00:00:00+00:00
      Subject: Test bug 2
      First comment
  <BLANKLINE>
      http://www.ubuntu.com
  <BLANKLINE>
      Author: Foo Bar
      Date: 2005-04-02 01:00:00+00:00
      Subject: Re: Test bug 2
      Second comment
  <BLANKLINE>
  >>> getUtility(IPersonSet).getByEmail('new.user@canonical.com')
  <Person at ...>


Now import an ASSIGNED bug.  Things to note about this import:

 * the second comment mentions a CVE, causing a link between the bug
   and CVE to be established.
 * The attachment on this bug is imported

  >>> bug = bz.handleBug(3)
  >>> bugInfo(bug)
  Title: Test bug 3
  Reporter: Sample Person
  Created: 2005-04-03 00:00:00+00:00
  Nick: xyz
  Subscribers:
      Foo Bar
      Sample Person
  Task: netapplet (Ubuntu)
      Status: CONFIRMED
      Distro: ubuntu
      Source package: netapplet
      Assignee: Foo Bar
      Importance: CRITICAL
      Explanation: Bugzilla status=ASSIGNED, product=Ubuntu, component=netapplet
  CVEs:
      CVE-2005-1234
  Messages:
      Author: Foo Bar
      Date: 2005-04-03 00:00:00+00:00
      Subject: Test bug 3
      First comment
  <BLANKLINE>
      http://www.ubuntu.com
  <BLANKLINE>
      Author: Sample Person
      Date: 2005-04-03 01:00:00+00:00
      Subject: Re: Test bug 3
      This is related to CVE-2005-1234
  <BLANKLINE>
      Author: Foo Bar
      Date: 2005-04-03 02:00:00+00:00
      Subject: Re: Test bug 3
      Created an attachment (id=1)
  <BLANKLINE>
  Attachments:
      Title: An attachment
      Type: PATCH
      Name: foo.patch
      Mime type: text/plain


Next we import a fixed bug:

  >>> bug = bz.handleBug(4)
  >>> bugInfo(bug)
  Title: Test bug 4
  Reporter: Sample Person
  Created: 2005-04-04 00:00:00+00:00
  Nick: foobar
  Subscribers:
      Foo Bar
      Sample Person
  Task: mozilla-firefox (Ubuntu)
      Status: FIXRELEASED
      Distro: ubuntu
      Source package: mozilla-firefox
      Assignee: Sample Person
      Importance: CRITICAL
      Explanation: Bugzilla status=CLOSED FIXED, product=Ubuntu, component=mozilla-firefox
  Messages:
      Author: Sample Person
      Date: 2005-04-04 00:00:00+00:00
      Subject: Test bug 4
      First comment
  <BLANKLINE>
      http://www.ubuntu.com
  <BLANKLINE>


The Ubuntu bugzilla uses the UPSTREAM state to categorise bugs that
have been forwarded on to the upstream developers.  Usually the
upstream bug tracker URL is included in the URL field of the bug.

The Malone equivalent of this is to create a second task on the bug,
and attach a watch to the upstream bug tracker:

  >>> bug = bz.handleBug(5)
  >>> bugInfo(bug)
  Title: Test bug 5
  Reporter: Sample Person
  Created: 2005-04-04 00:00:00+00:00
  Subscribers:
      Sample Person
  Task: Evolution
      Status: NEW
      Product: evolution
      Importance: UNDECIDED
      Watch: http://bugzilla.gnome.org/show_bug.cgi?id=273041
  Task: evolution (Ubuntu)
      Status: NEW
      Distro: ubuntu
      Source package: evolution
      Assignee: Sample Person
      Importance: CRITICAL
      Explanation: Bugzilla status=UPSTREAM, product=Ubuntu, component=evolution
  Task: evolution (Debian)
      Status: NEW
      Distro: debian
      Source package: evolution
      Importance: UNDECIDED
      Watch: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1234
  Messages:
      Author: Sample Person
      Date: 2005-04-05 00:00:00+00:00
      Subject: Test bug 5
      First comment
  <BLANKLINE>
      http://bugzilla.gnome.org/show_bug.cgi?id=273041
  <BLANKLINE>

XXX mpt 20060404: In sampledata Evolution uses Malone officially, so adding
a watch to its external bug tracker is a bad example.


Severity Mapping
----------------

Bugzilla severities are mapped to the equivalent Launchpad importance values:

  >>> bug = bugzilla.Bug(bz.backend, 1)
  >>> class FakeBugTask:
  ...     def transitionToStatus(self, status, user):
  ...         self.status = status
  >>> bugtask = FakeBugTask()
  >>> for severity in ['blocker', 'critical', 'major', 'normal',
  ...                  'minor', 'trivial', 'enhancement']:
  ...     bug.bug_severity = severity
  ...     bug.mapSeverity(bugtask)
  ...     print '%-11s  %s' % (severity, bugtask.importance.name)
  blocker      CRITICAL
  critical     CRITICAL
  major        HIGH
  normal       MEDIUM
  minor        LOW
  trivial      LOW
  enhancement  WISHLIST


Status Mapping
--------------

  >>> for status in ['UNCONFIRMED', 'NEW', 'ASSIGNED', 'REOPENED',
  ...                'NEEDINFO', 'UPSTREAM', 'PENDINGUPLOAD',
  ...                'RESOLVED', 'VERIFIED', 'CLOSED']:
  ...     bug.bug_status = status
  ...     bugtask.statusexplanation = ''
  ...     bug.mapStatus(bugtask)
  ...     print '%-13s  %s' % (status, bugtask.status.name)
  UNCONFIRMED    NEW
  NEW            NEW
  ASSIGNED       CONFIRMED
  REOPENED       NEW
  NEEDINFO       INCOMPLETE
  UPSTREAM       NEW
  PENDINGUPLOAD  FIXCOMMITTED
  RESOLVED       INVALID
  VERIFIED       INVALID
  CLOSED         INVALID

(note that RESOLVED, VERIFIED and CLOSED have been mapped to INVALID
here because the Bugzilla resolution is set to WONTFIX).


If the bug has been resolved, the resolution will affect the status:

  >>> bug.priority = 'P2'
  >>> bug.bug_status = 'RESOLVED'
  >>> for resolution in ['FIXED', 'INVALID', 'WONTFIX', 'NOTABUG',
  ...                    'NOTWARTY', 'UNIVERSE', 'LATER', 'REMIND',
  ...                    'DUPLICATE', 'WORKSFORME', 'MOVED']:
  ...     bug.resolution = resolution
  ...     bugtask.statusexplanation = ''
  ...     bug.mapStatus(bugtask)
  ...     print '%-10s  %s' % (resolution, bugtask.status.name)
  FIXED       FIXRELEASED
  INVALID     INVALID
  WONTFIX     INVALID
  NOTABUG     INVALID
  NOTWARTY    INVALID
  UNIVERSE    INVALID
  LATER       INVALID
  REMIND      INVALID
  DUPLICATE   INVALID
  WORKSFORME  INVALID
  MOVED       INVALID


Bug Target Mapping
------------------

The Bugzilla.getLaunchpadTarget() method is used to map bugzilla bugs
to Launchpad bug targets.  This is not general purpose logic: it only
applies to the Ubuntu bugzilla.

The current mapping only handles bugs filed under the "Ubuntu"
product.  If the component the bug is filed under is a known package
name, the bug is targeted at that package in ubuntu.  If it isn't,
then the bug is filed directly against the distribution.

  >>> def showMapping(product, component):
  ...     bug.product = product
  ...     bug.component = component
  ...     target = bz.getLaunchpadBugTarget(bug)
  ...     distribution = target.get('distribution')
  ...     if distribution:
  ...         print 'Distribution:', distribution.name
  ...     spn = target.get('sourcepackagename')
  ...     if spn:
  ...         print 'Source package:', spn.name
  ...     product = target.get('product')
  ...     if product:
  ...         print 'Product:', product.name

  >>> showMapping('Ubuntu', 'mozilla-firefox')
  Distribution: ubuntu
  Source package: mozilla-firefox

  >>> showMapping('Ubuntu', 'netapplet')
  Distribution: ubuntu
  Source package: netapplet

  >>> showMapping('Ubuntu', 'unknown-package-name')
  WARNING:canonical.launchpad.scripts.bugzilla:could not find package name for "unknown-package-name": 'Unknown package: unknown-package-name'
  Distribution: ubuntu

  >>> showMapping('not-Ubuntu', 'general')
  Traceback (most recent call last):
    ...
  AssertionError: product must be Ubuntu


Duplicate Bug Handling
----------------------

The Bugzilla duplicate bugs table can be used to mark the
corresponding Launchpad bugs as duplicates too:

  >>> class FakeTransactionManager:
  ...     def begin(self):
  ...         pass
  ...     abort = commit = begin
  ...
  >>> bz.processDuplicates(FakeTransactionManager())

Now check that the bugs have been marked duplicate:

  >>> bug1 = getUtility(IBugSet).queryByRemoteBug(bugtracker, 1)
  >>> bug2 = getUtility(IBugSet).queryByRemoteBug(bugtracker, 2)
  >>> bug3 = getUtility(IBugSet).queryByRemoteBug(bugtracker, 3)
  >>> bug4 = getUtility(IBugSet).queryByRemoteBug(bugtracker, 4)

  >>> print bug1.duplicateof
  None
  >>> bug2.duplicateof == bug1
  True
  >>> bug3.duplicateof == bug2
  True
  >>> bug4.duplicateof == bug2
  True


