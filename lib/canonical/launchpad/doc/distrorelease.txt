Distro Releases
===============

From the DerivationOverview spec
<https://launchpad.canonical.com/DerivationOverview>:

    A distribution of GNU/Linux comprises a set of packages, an installer,
    possibly a live-CD, some amount of metadata associated with the arrangement
    of those elements and also a lot of information on managing it.

A distro release is a given version of a distribution. So, for Ubuntu, there
are releases (or planned releases) like "warty", "hoary" and "bendy".

Distro releases are retrieved with the IDistroReleaseSet utility, much like
people are retrieved with the IPersonSet utility, or bug tasks are retrieved
with the IBugTaskSet utility.

The IDistroReleaseSet utility is accessed in the usual fashion:

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IDistroReleaseSet, IDistributionSet)
    >>> distroreleaseset = getUtility(IDistroReleaseSet)

To retrieve a specific release of a distribution, use IDistroReleaseSet.get:

    >>> warty = distroreleaseset.get(1)
    >>> print warty.name
    warty
    >>> print warty.fullreleasename
    Ubuntu Warty

Or IDistroReleaseSet.findByName:

    >>> for distrorelease in distroreleaseset.findByName("warty"):
    ...     print distrorelease.name
    warty

To get one specific release by name, use queryByName:

    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")

    >>> warty = distroreleaseset.queryByName(ubuntu, "warty")
    >>> warty.name
    u'warty'

If the release by that name doesn't exist, None will be returned:

    >>> foobar = distroreleaseset.queryByName(ubuntu, "foobar")
    >>> print foobar
    None

Or IDistroReleaseSet.findByVersion:

    >>> for distrorelease in distroreleaseset.findByVersion("5.04"):
    ...     print distrorelease.name
    hoary

To search the set of IDistroReleases, use IDistroReleaseSet.search:

    >>> ubuntu_releases = distroreleaseset.search(
    ...     distribution=ubuntu, isreleased=True, orderBy="-datereleased")
    >>> [release.name for release in ubuntu_releases]
    [u'warty']

    >>> all_ubuntu_releases = distroreleaseset.search(distribution=ubuntu)
    >>> all_ubuntu_releases.count()
    4

DistroRelease.getPublishedReleases:

    >>> from canonical.launchpad.database import SourcePackageName, DistroRelease
    >>> warty2 = DistroRelease.get(1)

Passing a ISourcePackageName as argument:

    >>> prs = warty2.getPublishedReleases(
    ...       SourcePackageName.byName('mozilla-firefox'))
    >>> print len(prs)
    1
    >>> print prs[0].sourcepackagerelease.sourcepackagename.name
    mozilla-firefox

Passing a string name:

    >>> print len(warty2.getPublishedReleases('mozilla-firefox'))
    1

Including pending publication records in the result:

    >>> print len(warty2.getPublishedReleases('mozilla-firefox',
    ...           include_pending=True))
    2

Not found as empty list:

    >>> print len(warty2.getPublishedReleases('nosuchpackage'))
    0

canUploadToPocket method helps us to decide if an upload is allowed or
not, according the distrorelease status and the upload target pocket.

   >>> from canonical.launchpad.interfaces import IDistributionSet
   >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
   >>> breezy_autotest = ubuntu['breezy-autotest']

   >>> from canonical.lp.dbschema import PackagePublishingPocket

   >>> warty.releasestatus.name
   'CURRENT'
   >>> warty.canUploadToPocket(PackagePublishingPocket.RELEASE)
   False
   >>> warty.canUploadToPocket(PackagePublishingPocket.SECURITY)
   True

   >>> breezy_autotest.releasestatus.name
   'EXPERIMENTAL'
   >>> breezy_autotest.canUploadToPocket(PackagePublishingPocket.RELEASE)
   True
   >>> breezy_autotest.canUploadToPocket(PackagePublishingPocket.SECURITY)
   False

DistroRelease.getBinaryPackagePublishing will return
BinaryPackagePublishing objects for the DistroRelease:

    >>> from canonical.launchpad.database import DistroRelease
    >>> warty = DistroRelease.get(1)
    >>> bpp = warty.getBinaryPackagePublishing()
    >>> print bpp.count()
    5
    >>> print list(bpp)[0].binarypackagerelease.binarypackagename.name
    mozilla-firefox
    >>> bpp = warty.getBinaryPackagePublishing(name="nosuchpackage")
    >>> print bpp.count()
    0
    >>> bpp = warty.getBinaryPackagePublishing(version="nosuchversion")
    >>> print bpp.count()
    0
    >>> bpp = warty.getBinaryPackagePublishing(archtag="nosucharch")
    >>> print bpp.count()
    0
    >>> bpp = warty.getBinaryPackagePublishing(sourcename="nosuchsource")
    >>> print bpp.count()
    0

Package searching
-----------------

You can search through binary packages publishing in a distribution
release by using the searchPackages method, which uses magical fti:

    >>> len(warty.searchPackages("pmount"))
    1

This also works for small or weirdly named packages that don't work
through fti, and even for substrings:

    >>> len(warty.searchPackages("linux-2.6.12"))
    1
    >>> len(warty.searchPackages("at"))
    1
    >>> len(warty.searchPackages("inux-2"))
    1

CVE BugTasks on a Distro Release
--------------------------------

A distro release should know what CVE-related bug tasks exist on it, and
what state they are in. We should be able to find open, and closed,
bugtasks, using this API. Based on the sample data we know the following
about Debian:

    >>> woody = distroreleaseset.get(6)
    >>> tasks = woody.open_cve_bugtasks
    >>> for task in tasks:
    ...     print task.id
    20

There should be NO resolved CVE tasks:

    >>> tasks = woody.resolved_cve_bugtasks
    >>> print len(tasks)
    0

DistroReleases have components and sections
-------------------------------------------

A distrorelease has some number of components and/or sections which
are valid for that distrorelease. These selections are used by (among
other things) the uploader for validating incoming uploads.

   >>> hoary = distroreleaseset.get(3)
   >>> for c in hoary.components:
   ...     print c.name
   main
   restricted
   >>> for s in hoary.sections:
   ...     print s.name
   base
   web
   editors
   admin

   >>> from canonical.launchpad.interfaces import (
   ...    IComponentSet, ISectionSet)
   >>> univ = getUtility(IComponentSet).ensure('universe')
   >>> python = getUtility(ISectionSet).ensure('python')

   >>> hoary.addComponent(univ)
   >>> hoary.addSection(python)

   >>> for c in hoary.components:
   ...     print c.name
   main
   restricted
   universe

   >>> for s in hoary.sections:
   ...     print s.name
   base
   web
   editors
   admin
   python


DistroReleases can be initialised from their parents
----------------------------------------------------

When a distrorelease is derived from another distrorelease (be it a
derivative distribution, or simply the next release in a sequence from
Ubuntu) we need to initialise the new release with quite a lot of
information. Not least of which is the section and component
selections and the publishing information for the distrorelease.

DistroRelease provides us with a method for doing this which carefully
goes behind the back of sqlobject to copy potentially tens of
thousands of rows around in order to set up a distrorelease.

IDistroRelease lists a series of preconditions for performing an
initialisation. In particular the initialiser won't overwrite
publishing records etc. Essentially this is a "Do not push this button
again" type set of assertions.

   >>> login("foo.bar@canonical.com")
   >>> humpy = distroreleaseset.new(ubuntu, 'humpy', 'Humpy Hippo',
   ...                              'The Humpy Hippo', 'Fat', 'Yo Momma',
   ...                              '99.2',hoary, hoary.owner)
   >>> humpy_i386 = humpy.newArch('i386', hoary['i386'].processorfamily,
   ...                            True, humpy.owner)
   >>> humpy.nominatedarchindep = humpy_i386
   >>> humpy.initialiseFromParent()
   >>> len(hoary.getPublishedReleases('pmount'))
   1
   >>> len(humpy.getPublishedReleases('pmount'))
   1
   >>> len(hoary['i386'].getReleasedPackages('pmount'))
   1
   >>> len(humpy_i386.getReleasedPackages('pmount'))
   1
   >>> len(hoary.potemplates)
   3
   >>> len(humpy.potemplates)
   3

Let's compare what we have in our parent distro release and the new one just
created.

   >>> hoary_templates = sorted(
   ...     hoary.potemplates, key=lambda x: x.potemplatename.name)
   >>> humpy_templates = sorted(
   ...     humpy.potemplates, key=lambda x: x.potemplatename.name)

Check one by one and compare the exported text.

   >>> from difflib import unified_diff
   >>> for i in range(3):
   ...     old_template = hoary_templates[i]
   ...     new_template = humpy_templates[i]
   ...     output = '\n'.join(list(unified_diff(
   ...         old_template.export().split('\n'),
   ...         new_template.export().split('\n'))))
   ...     output = output.decode('UTF-8')
   ...     if output != u'':
   ...        print '%s is different than its parent %s:\n%s' % (
   ...            new_template.title, old_template.title, output)
   ...     for old_pofile in old_template.pofiles:
   ...         new_pofile = new_template.getPOFileByLang(
   ...             old_pofile.language.code, old_pofile.variant)
   ...         output = '\n'.join(list(unified_diff(
   ...             old_pofile.uncachedExport(
   ...                 included_obsolete=False, force_utf8=True).split('\n'),
   ...             new_pofile.uncachedExport(
   ...                 included_obsolete=False, force_utf8=True).split('\n'))))
   ...         output = output.decode('UTF-8')
   ...     if output != u'':
   ...        print u'%s is different than its parent %s:\n%s' % (
   ...            new_pofile.title, old_pofile.title, output)



Translatable Packages and Packaging
-----------------------------------

You can easily find out what packages are translatable in a
distribution release:

   >>> translatables = hoary.getTranslatableSourcePackages()
   >>> for translatable in translatables:
   ...    print translatable.name
   evolution
   mozilla
   pmount

Packages can be linked to upstream productseries in specific
distribution releases. IDistroRelease offers a way to query translatable
packages that are linked to upstream productseries.

   >>> unlinked_translatables = hoary.getUnlinkedTranslatableSourcePackages()
   >>> for translatable in unlinked_translatables:
   ...    print translatable.name
   pmount
   mozilla

The links to upstream product series can be verified using the
packagings property:

    >>> packagings = hoary.packagings
    >>> for packaging in packagings:
    ...     print packaging.sourcepackagename.name, \
    ...           packaging.productseries.product.displayname
    evolution Evolution
    mozilla-firefox Mozilla Firefox
    netapplet NetApplet

From the results above you can notice that neither mozilla-firefox nor
netapplet are translatable in Hoary.


DistroRelease can build meta objects for packages
-------------------------------------------------

   >>> from zope.interface.verify import verifyObject
   >>> from canonical.launchpad.interfaces import (
   ...     ISourcePackage,
   ...     IDistroReleaseBinaryPackage,
   ...     IDistroReleaseSourcePackageRelease,
   ...     ISourcePackagePublishingHistory)


   >>> pmount_src_name =  SourcePackageName.byName('pmount')
   >>> pmount_source = hoary.getSourcePackage(pmount_src_name)
   >>> ISourcePackage.providedBy(pmount_source)
   True

   >>> from canonical.launchpad.database.binarypackagename import (
   ...                                       BinaryPackageName)
   >>> pmount_bin_name =  BinaryPackageName.byName('pmount')
   >>> pmount_binary = hoary.getBinaryPackage(pmount_bin_name)
   >>> IDistroReleaseBinaryPackage.providedBy(pmount_binary)
   True

   >>> from canonical.launchpad.database.sourcepackagerelease import (
   ...                                           SourcePackageRelease)
   >>> pmount_rel = SourcePackageRelease.selectOneBy(
   ...     sourcepackagenameID=pmount_src_name.id, version='0.1-1')
   >>> pmount_rel.sourcepackagename.name
   u'pmount'

   >>> pmount_srcrel = hoary.getSourcePackageRelease(pmount_rel)
   >>> IDistroReleaseSourcePackageRelease.providedBy(pmount_srcrel)
   True

Check some properties of DRSPR meta class

Entire publishing history:

   >>> pmount_srcrel.publishing_history.count()
   1

Most recent published history row:

   >>> spph = pmount_srcrel.current_published
   Traceback (most recent call last):
   ...
   NotFoundError: u'Source package pmount not published in hoary'

   >>> netapplet_srcrel =  hoary.getSourcePackage('netapplet').currentrelease
   >>> spph = netapplet_srcrel.current_published
   >>> verifyObject(ISourcePackagePublishingHistory, spph)
   True

   >>> spph.section.name
   u'web'

Perform `post publication` override:

   >>> new_section = getUtility(ISectionSet)['base']

   >>> netapplet_srcrel.changeOverride(new_section=new_section)
   >>> pub_hist = netapplet_srcrel.publishing_history
   >>> pub_hist.count()
   2

Override information about 'pmount' is pending publication:

   >>> pub_hist[0].status.name, pub_hist[0].section.name
   ('PENDING', u'base')

Supersede current publication:

   >>> superseded_netapplet = netapplet_srcrel.supersede()
   >>> netapplet_srcrel.publishing_history.count()
   2

   XXX cprov 20060322: Misteriously we cannot direct access attributes
   of a SSPPH objects within the tests, but we do this for SBPPH in
   distroarchrelease.txt. wth ?

   >>> superseded_netapplet.status.name, superseded_netapplet.datesuperseded
   Traceback (most recent call last):
   ...
   ForbiddenAttribute: ('status', <SecureSourcePackagePublishingHistory...)

   >>> from zope.security.proxy import removeSecurityProxy
   >>> naked_hist = removeSecurityProxy(superseded_netapplet)

   >>> naked_hist.status.name, naked_hist.datesuperseded
   ('SUPERSEDED', CURRENT_TIMESTAMP AT TIME ZONE 'UTC')


DistroRelease Translations migration
------------------------------------

We have several ways to copy translations between distro releases.

The main one is to clone what we have in its parent distribution.

We are going to use Breezy as the distro release that will get the
translations.

 >>> distroset = getUtility(IDistributionSet)
 >>> ubuntu = distroset.getByName('ubuntu')
 >>> breezy = ubuntu.getRelease('breezy-autotest')

As we can see, there are no templates to translate.

 >>> len(breezy.potemplates)
 0

But its parent release has them.

 >>> len(breezy.parentrelease.potemplates)
 3


Specification Listings
======================

We should be able to get lists of specifications in different states
related to a distrorelease.

Basically, we can filter by completeness, and by whether or not the spec is
informational.

 >>> distroset = getUtility(IDistributionSet)
 >>> kubuntu = distroset.getByName("kubuntu")
 >>> krunch = kubuntu.getRelease("krunch")
 >>> from canonical.lp.dbschema import SpecificationFilter

First, there should be one informational specs for krunch:

 >>> filter = [SpecificationFilter.INFORMATIONAL]
 >>> krunch.specifications(filter=filter).count()
 1


There are 2 completed specs for Krunch:

 >>> filter = [SpecificationFilter.COMPLETE]
 >>> for spec in kubuntu.specifications(filter=filter):
 ...    print spec.name, spec.is_complete
 thinclient-local-devices True
 usplash-on-hibernation True


And there are 2 incomplete specs:

 >>> filter = [SpecificationFilter.INCOMPLETE]
 >>> for spec in krunch.specifications(filter=filter):
 ...     print spec.name, spec.is_complete
 cluster-installation False
 revu False


If we ask for all specs, we get them in the order of priority.

 >>> filter = [SpecificationFilter.ALL]
 >>> for spec in krunch.specifications(filter=filter):
 ...    print spec.priority.title, spec.name
 Essential cluster-installation
 High revu
 Medium thinclient-local-devices
 Low usplash-on-hibernation
 Undefined kde-desktopfile-langpacks
 Not krunch-desktop-plan


With a distrorelease, we can ask for ACCEPTED, PROPOSED and DECLINED specs:

 >>> filter=[SpecificationFilter.ACCEPTED]
 >>> for spec in krunch.specifications(filter=filter):
 ...     print spec.name, spec.goalstatus.title
 cluster-installation Accepted
 revu Accepted
 thinclient-local-devices Accepted
 usplash-on-hibernation Accepted

 >>> filter=[SpecificationFilter.PROPOSED]
 >>> for spec in krunch.specifications(filter=filter):
 ...     print spec.name, spec.goalstatus.title
 kde-desktopfile-langpacks Proposed
 
 >>> filter=[SpecificationFilter.DECLINED]
 >>> for spec in krunch.specifications(filter=filter):
 ...     print spec.name, spec.goalstatus.title
 krunch-desktop-plan Declined
 

And if we ask just for specs, we get BOTH the incomplete and the complete
ones that have been accepted.

 >>> for spec in krunch.specifications():
 ...     print spec.name, spec.is_complete, spec.goalstatus.title
 cluster-installation False Accepted
 revu False Accepted
 thinclient-local-devices True Accepted
 usplash-on-hibernation True Accepted

We can filter for specifications that contain specific text:

 >>> for spec in krunch.specifications(filter=['usb']):
 ...     print spec.name
 thinclient-local-devices


Drivers
=======

Distributions have drivers, who are people that have permission to approve
bugs and features for specific releases. The rules are that:

 1. a "driver" can be set on either Distribution or DistroRelease
 2. drivers are only actually relevant on a DistroRelease, because thats the
    granularity at which we track spec/bug targeting
 3. the important attribute is ".drivers" on a distrorelease, it is
    calculated based on the combination of owners and drivers in the
    distribution and the distrorelease. It is a LIST of drivers, which might
    be empty, or have one or two people/teams in it.
 4. If the release has a driver, then that driver is in the list.
 5. If the distribution has a driver then that is in the list too, otherwise
 6. If neither the release nor the distribution has a driver, then the
    distribution registrant is the driver.

We test these rules below.


First, we look at a release where both the distribution and release have
drivers. Kubuntu should be a good example.

 >>> kubuntu.driver.name
 u'jblack'
 >>> krunch.driver.name
 u'edgar'
 >>> for d in krunch.drivers:
 ...     print d.name
 edgar
 jblack


Now, we look at a release where there is a driver on the release but not on
the distribution.

 >>> debian = distroset.getByName('debian')
 >>> print debian.driver
 None
 >>> print debian.owner.name
 sabdfl
 >>> sarge = debian.getRelease('sarge')
 >>> print sarge.driver.name
 jdub
 >>> for d in sarge.drivers:
 ...     print d.name
 jdub
 sabdfl


Now, a release where there is no driver on the release but there is a driver
on the distribution.

 >>> redhat = distroset.getByName('redhat')
 >>> print redhat.driver.name
 jblack
 >>> six = redhat.getRelease('six')
 >>> print six.driver
 None
 >>> for d in six.drivers:
 ...     print d.name
 jblack


Finally, on a release where neither the distribution nor the release have a
driver. Here, we expect the driver to be the owner of the distribution
(because this is the "commonest fallback").

 >>> sid = debian.getRelease('sid')
 >>> print debian.driver
 None
 >>> print debian.owner.name
 sabdfl
 >>> print sid.driver
 None
 >>> print sid.owner.name
 jdub

 >>> for d in sid.drivers:
 ...     print d.name
 sabdfl


