= Bug tags =

In order to arbitrary group bugs together a bug can be associated with
one or more tags. A tag is a simple text string, not contain a space
character. The tags are available as a list of strings on the bug:

    >>> from canonical.launchpad.interfaces import IBugSet
    >>> bug_one = getUtility(IBugSet).get(1)

There are no tags currently, so let's add some. It doesn't matter which
order the tags are in, the result will be ordered alphabetically:

    >>> bug_one.tags
    []

    >>> login('test@canonical.com')
    >>> bug_one.tags = [u'svg', u'sco']
    >>> bug_one.tags
    [u'sco', u'svg']

Under the hood the tags are stored in a different table. If we take a
look at it we can see that the added tags are there.

    >>> from canonical.launchpad.database.bug import BugTag
    >>> bugtags = BugTag.selectBy(bugID=bug_one.id, orderBy='tag')
    >>> for bugtag in bugtags:
    ...     print bugtag.tag
    sco
    svg

So if we add another tag by setting the 'tags' attribute to a new list.
The tag will be added in the table.

    >>> bug_one.tags = [u'svg', u'sco', u'installl']
    >>> bug_one.tags
    [u'installl', u'sco', u'svg']

    >>> bugtags = BugTag.selectBy(bugID=bug_one.id, orderBy='tag')
    >>> for bugtag in bugtags:
    ...     print bugtag.tag
    installl
    sco
    svg

We allow adding the same tag twice, but it won't be stored twice in the
db:

    >>> bug_one.tags = [u'svg', u'svg', u'sco', u'installl']
    >>> bug_one.tags
    [u'installl', u'sco', u'svg']

Let's correct the spelling mistake we did and delete one of the tags:

    >>> bug_one.tags = [u'sco', u'install']
    >>> bug_one.tags
    [u'install', u'sco']

    >>> bugtags = BugTag.selectBy(bugID=bug_one.id, orderBy='tag')
    >>> for bugtag in bugtags:
    ...     print bugtag.tag
    install
    sco


== Widgets ==

To make it easy editing the tags as a space separated text string, we
use BugTagsWidget.

    >>> from canonical.launchpad.interfaces import IBug
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest
    >>> from canonical.widgets.bug import BugTagsWidget
    >>> bug_tags_field = IBug['tags'].bind(bug_one)
    >>> tag_field = bug_tags_field.value_type
    >>> request = LaunchpadTestRequest()
    >>> tags_widget = BugTagsWidget(bug_tags_field, tag_field, request)

Since we didn't provided a value in the request, the form value will be
empty:

    >>> tags_widget._getFormValue()
    u''

If we set the value to bug one's tags, it will be a space separated
string:

    >>> tags_widget.setRenderedValue(bug_one.tags)
    >>> tags_widget._getFormValue()
    u'install sco'

If we pass in a value via the request, we'll be able to get the tags as
a sorted list from getInputValue():

    >>> request = LaunchpadTestRequest(form={'field.tags': u'svg sco'})
    >>> tags_widget = BugTagsWidget(bug_tags_field, tag_field, request)
    >>> tags_widget._getFormValue()
    u'sco svg'
    >>> tags_widget.getInputValue()
    [u'sco', u'svg']

When we have an input value, the widget can edit the bug tags.

    >>> bug_one.tags
    [u'install', u'sco']
    >>> tags_widget.applyChanges(bug_one)
    True
    >>> bug_one.tags
    [u'sco', u'svg']

If a user enters an invalid tag, we get an error explaining what's
wrong.

    >>> request = LaunchpadTestRequest(form={'field.tags': u'!!!! foo $$$$'})
    >>> tags_widget = BugTagsWidget(bug_tags_field, tag_field, request)
    >>> tags_widget.getInputValue()
    Traceback (most recent call last):
    ...
    WidgetInputError...

    >>> print tags_widget._error.doc()
    '!!!!' isn't a valid tag name. Only alphanumeric characters may be used.


Let's take a closer look at _toFormValue() to ensure that it works
properly:

    >>> tags_widget._toFormValue([])
    u''
    >>> tags_widget._toFormValue(['foo'])
    u'foo'
    >>> tags_widget._toFormValue(['foo', 'bar'])
    u'foo bar'

And _toFieldValue():

    >>> tags_widget._toFieldValue(u'')
    []
    >>> tags_widget._toFieldValue(u'foo')
    [u'foo']
    >>> tags_widget._toFieldValue(u'FOO bar')
    [u'bar', u'foo']
    >>> tags_widget._toFieldValue(u'foo   \t          bar')
    [u'bar', u'foo']

A comma isn't valid in a tag name and sometimes users use commas to
separate the tags, so we accept that as well.

    >>> tags_widget._toFieldValue(u'foo, bar')
    [u'bar', u'foo']

    >>> tags_widget._toFieldValue(u'foo,bar')
    [u'bar', u'foo']

Duplicate tags are converted to a single instance.

    >>> tags_widget._toFieldValue(u'FOO, , , , bar bar, bar, bar foo')
    [u'bar', u'foo']


== Searching ==

We can search for bugs with some specific tag.

    >>> from canonical.launchpad.interfaces import (
    ...     BugTaskSearchParams, IDistributionSet)
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> svg_tasks = ubuntu.searchTasks(
    ...     BugTaskSearchParams(tag=u'svg', user=None))
    >>> for bugtask in svg_tasks:
    ...     print bugtask.bug.id, bugtask.bug.tags
    1 [u'sco', u'svg']

    >>> from canonical.launchpad.searchbuilder import any
    >>> crash_dataloss_tasks = ubuntu.searchTasks(BugTaskSearchParams(
    ...     tag=any(u'crash', u'dataloss'), orderby='id', user=None))
    >>> for bugtask in crash_dataloss_tasks:
    ...     print bugtask.bug.id, bugtask.bug.tags
    2 [u'dataloss', u'pebcak']
    9 [u'crash']
    10 [u'crash']

Tags are also searched when searching for some text in general. For
example, if we search for 'some-tag', we find nothing at the moment:

    >>> some_tag_tasks = ubuntu.searchTasks(
    ...     BugTaskSearchParams(searchtext=u'some-tag', user=None))
    >>> some_tag_tasks.count()
    0

# XXX: Bjorn Tillenius 2006-07-14
#      The tests below don't pass yet. It's desirable functionality, but
#      it's better to get this branch landed and spend time on it later.

If we now set bug one's tag to 'some-tag', it will be found.

    XXX from canonical.database.sqlbase import flush_database_updates
    XXX bug_one.tags = [u'some-tag']
    XXX flush_database_updates()

    XXX some_tag_tasks = ubuntu.searchTasks(
    ...     BugTaskSearchParams(searchtext=u'some-tag', user=None))
    XXX for bugtask in some_tag_tasks:
    ...     print bugtask.id, bugtask.bug.id, bugtask.bug.tags
    1 [u'some-tag']

== Tags for a context ==

When viewing a bug listing for a context we want to display all the tags
that are used in that context. For this we have a method on each bug
target to return all the used tags. For source packages we return the
tags used in its distribution/distroseries, since it's good to see
which tags can be used. The tags are ordered alphabetically.  All tags
are shown, no matter if they are used in open bugs or closed ones.

    >>> from canonical.launchpad.interfaces import IProductSet, BugTaskStatus
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> login('test@canonical.com')
    >>> for bugtask in firefox.searchTasks(BugTaskSearchParams(
    ...     tag=u'layout-test', user=None)):
    ...     bugtask.transitionToStatus(
    ...         BugTaskStatus.FIXRELEASED, getUtility(ILaunchBag).user)
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()

    >>> firefox.getUsedBugTags()
    [u'doc', u'layout-test', u'sco', u'svg']

    >>> from canonical.launchpad.interfaces import IProjectSet
    >>> mozilla = getUtility(IProjectSet).getByName('mozilla')
    >>> mozilla.getUsedBugTags()
    [u'crash', u'doc', u'layout-test', u'sco', u'svg']

    >>> ubuntu.getUsedBugTags()
    [u'crash', u'dataloss', u'pebcak', u'sco', u'svg']

    >>> ubuntu_thunderbird = ubuntu.getSourcePackage('thunderbird')
    >>> ubuntu_thunderbird.getUsedBugTags()
    [u'crash', u'dataloss', u'pebcak', u'sco', u'svg']

    >>> debian = getUtility(IDistributionSet).getByName('debian')
    >>> debian_woody = debian.getSeries('woody')
    >>> debian_woody.getUsedBugTags()
    [u'dataloss', u'layout-test', u'pebcak']

    >>> debian_woody_firefox = debian_woody.getSourcePackage('mozilla-firefox')
    >>> debian_woody_firefox.getUsedBugTags()
    [u'dataloss', u'layout-test', u'pebcak']

We can also get all the used tags, together with the number of open
bugs each tag has.

    >>> firefox.getUsedBugTagsWithOpenCounts(None)
    [(u'doc', 1L), (u'layout-test', 0L), (u'sco', 1L), (u'svg', 1L)]

    >>> mozilla.getUsedBugTagsWithOpenCounts(None)
    [(u'crash', 0L), (u'doc', 1L), (u'layout-test', 0L),
     (u'sco', 1L), (u'svg', 1L)]

    >>> ubuntu.getUsedBugTagsWithOpenCounts(None)
    [(u'crash', 2L), (u'dataloss', 1L), (u'pebcak', 1L),
     (u'sco', 1L), (u'svg', 1L)]


Source packages are a bit special, they return all the tags that are
used in the whole distribution, while the bug count includes only bugs
in the specific package.

    >>> ubuntu_thunderbird.getUsedBugTagsWithOpenCounts(None)
    [(u'crash', 1L), (u'dataloss', 0L), (u'pebcak', 0L),
     (u'sco', 0L), (u'svg', 0L)]

    >>> debian_woody.getUsedBugTagsWithOpenCounts(None)
    [(u'dataloss', 1L), (u'layout-test', 1L), (u'pebcak', 1L)]

    >>> debian_woody_firefox.getUsedBugTagsWithOpenCounts(None)
    [(u'dataloss', 1L), (u'layout-test', 1L), (u'pebcak', 1L)]

Only bugs that the supplied user has access to will be counted:

    >>> bug_nine = getUtility(IBugSet).get(9)
    >>> bug_nine.setPrivate(True, getUtility(ILaunchBag).user)
    True
    >>> flush_database_updates()

    >>> ubuntu_thunderbird.getUsedBugTagsWithOpenCounts(None)
    [(u'crash', 0L), (u'dataloss', 0L), (u'pebcak', 0L),
     (u'sco', 0L), (u'svg', 0L)]

    >>> sample_person = getUtility(ILaunchBag).user
    >>> bug_nine.isSubscribed(sample_person)
    True
    >>> ubuntu_thunderbird.getUsedBugTagsWithOpenCounts(sample_person)
    [(u'crash', 1L), (u'dataloss', 0L), (u'pebcak', 0L),
     (u'sco', 0L), (u'svg', 0L)]

When context doesn't have any tags getUsedBugTags() returns a empty list.

    >>> gimp = getUtility(IProjectSet).getByName('gimp')
    >>> gimp.getUsedBugTags()
    []

    >>> alsa = getUtility(IProductSet).getByName('alsa-utils')
    >>> alsa.getUsedBugTags()
    []

    >>> gentoo = getUtility(IDistributionSet).getByName('gentoo')
    >>> gentoo.getUsedBugTags()
    []
