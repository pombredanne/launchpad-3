= POTMsgSet tests =

POTMsgSet represents messages to translate that a POTemplate file has.

We need to get a POTMsgSet object to performe this test.

    >>> from zope.component import getUtility
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.database import POTemplate, TranslationMessage
    >>> from canonical.launchpad.interfaces import (
    ...     ILanguageSet, IPersonSet, IPOTMsgSet, IProductSet)

    >>> potemplate = factory.makePOTemplate()
    >>> potmsgset = factory.makePOTMsgSet(potemplate=potemplate, singular="bla")

Verify interface.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> verifyObject(IPOTMsgSet, potmsgset)
    True

We also need some time and date functions to do translation updates.

    >>> from datetime import datetime
    >>> import pytz
    >>> UTC = pytz.timezone('UTC')


== POTMsgSet.normalizeWhitespaces ==

This function copies the leading and trailing whitespaces from
POTMsgSet's msgid into the 'text' argument.

As this test is too specific, we are going to change a msgid as we need for
every test.

    >>> potmsgset = factory.makePOTMsgSet(potemplate,
    ...                                   singular=u'normal string')
    >>> text = u'another normal string'

In this case, it should not change.

    >>> potmsgset.normalizeWhitespaces(text)
    u'another normal string'

Let's try with a 'text' that has some leading and trailing whitespaces,
they will disappear as the msgid does not have them.

    >>> text = u' a string with \n whitespaces \n'
    >>> potmsgset.normalizeWhitespaces(text)
    u'a string with \n whitespaces'

Now, the msgid will have a leading whitespace. That means that 'text'
should have it too.

    >>> potmsgset = factory.makePOTMsgSet(
    ...     potemplate, singular=u'\nnormal string with leading newline')
    >>> potmsgset.normalizeWhitespaces(text)
    u'\na string with \n whitespaces'

If 'text' has only whitespaces and nothing else, we should get the empty
string.

    >>> text = u'\n'
    >>> potmsgset.normalizeWhitespaces(text)
    ''

And if 'text' is None, we get 'text' unchanged.

    >>> potmsgset.normalizeWhitespaces(None) is None
    True


== POTMsgSet.convertDotToSpace ==

This method changes the u'\u2022' char by the normal white space.

As this test is too specific, we are going to change a msgid as we need for
every test.

    >>> potmsgset = factory.makePOTMsgSet(
    ...     potemplate, singular=u'normal string without the point')
    >>> text = u'another normal string'

In this case, it should not change.

    >>> potmsgset.convertDotToSpace(text)
    u'another normal string'

Let's try with a 'text' that has the char.

    >>> text = u'a string with the char \u2022'
    >>> potmsgset.convertDotToSpace(text)
    u'a string with the char  '

Now, msgid will have also that char, so 'text' should not change.

    >>> potmsgset = factory.makePOTMsgSet(
    ...     potemplate, singular=u'normal string with the char \u2022')
    >>> potmsgset.convertDotToSpace(text)
    u'a string with the char \u2022'


== POTMsgSet.normalizeNewLines ==

This method syncs the new line chars to use the same as the associated msgid.

As this test is too specific, we are going to change a msgid as we need for
every test.

    >>> potmsgset_windows = factory.makePOTMsgSet(potemplate, singular=u'\r\n')
    >>> potmsgset_unix = factory.makePOTMsgSet(potemplate, singular=u'\n')
    >>> potmsgset_mac = factory.makePOTMsgSet(potemplate, singular=u'\r')
    >>> text_windows = u'\r\n'
    >>> text_unix = u'\n'
    >>> text_mac = u'\r'

If both are the same, the text should not change.

    >>> potmsgset_windows.normalizeNewLines(text_windows) == text_windows
    True
    >>> potmsgset_mac.normalizeNewLines(text_mac) == text_mac
    True
    >>> potmsgset_unix.normalizeNewLines(text_unix) == text_unix
    True

Let's mix some of them and see how they became always as the potmsgset.

    >>> potmsgset_windows.normalizeNewLines(text_mac) == text_windows
    True
    >>> potmsgset_windows.normalizeNewLines(text_unix) == text_windows
    True
    >>> potmsgset_mac.normalizeNewLines(text_windows) == text_mac
    True
    >>> potmsgset_mac.normalizeNewLines(text_unix) == text_mac
    True
    >>> potmsgset_unix.normalizeNewLines(text_mac) == text_unix
    True
    >>> potmsgset_unix.normalizeNewLines(text_windows) == text_unix
    True

And finally, check to be sure that the broken options are detected.

    >>> potmsgset_windows.normalizeNewLines(text_mac+text_windows)
    Traceback (most recent call last):
    ...
    BrokenTextError: ...
    >>> potmsgset_windows.normalizeNewLines(text_unix+text_windows)
    Traceback (most recent call last):
    ...
    BrokenTextError: ...
    >>> potmsgset_windows.normalizeNewLines(text_unix+text_mac)
    Traceback (most recent call last):
    ...
    BrokenTextError: ...


== POTMsgSet.applySanityFixes ==

This function applies all checks we know to fix broken input

As this test is very, we wil create a msgid just for this test. We are going
to use a msgid with a leading and a trailing newline.

    >>> potmsgset = factory.makePOTMsgSet(
    ...     potemplate,
    ...     singular=u'\nnormal string with\nleading and trailing newline\n')

And the text we are going to check will have them too, but we are going to
use '\r\n' like when we get a form submission.

    >>> text = u'\r\nTranslation\r\nto test\r\n'
    >>> potmsgset.applySanityFixes(text)
    u'\nTranslation\nto test\n'


== POTMsgSet.updateTranslation ==

This method is the core piece of Translations infrastructure: it
updates a single language translation for a POTMsgSet, and modifies a
lot of metadata depending on many different conditions.  It is used
from both web UI and from import code.

We are going to work with Evolution.

    >>> evolution = getUtility(IProductSet).getByName('evolution')
    >>> evolution_trunk = evolution.getSeries('trunk')
    >>> evolution_potemplate = evolution_trunk.getPOTemplate('evolution-2.2')

Carlos is a privileged translator that will do the updates.

    >>> carlos = getUtility(IPersonSet).getByName('carlos')
    >>> login('carlos@canonical.com')

We will be working with Catalan (ca) translations, with the new PO file.

    >>> upstream_pofile = evolution_potemplate.newPOFile('ca')
    >>> catalan = upstream_pofile.language

And, any changes we'd do will be in 'evolution addressbook' message.

    >>> upstream_potmsgset = evolution_potemplate.getPOTMsgSetByMsgIDText(
    ...     u'evolution addressbook')

At this time, there is no current or imported translation and no suggestions.

    >>> print upstream_potmsgset.getCurrentTranslationMessage(
    ...     evolution_potemplate, catalan)
    None
    >>> print upstream_potmsgset.getImportedTranslationMessage(
    ...     evolution_potemplate, catalan)
    None
    >>> list(upstream_potmsgset.getLocalTranslationMessages(
    ...          evolution_potemplate, catalan))
    []

To add a suggestion, we set the force_suggestion parameter.

    >>> new_translation = upstream_potmsgset.updateTranslation(upstream_pofile,
    ...     carlos, {0: u'foo'}, is_imported=False, force_suggestion=True,
    ...     lock_timestamp=datetime.now(UTC))

Since this message is just a suggestion, it doesn't have a reviewer, but
it does note a person which last changed it.

    >>> print new_translation.reviewer
    None
    >>> print new_translation.date_reviewed
    None
    >>> new_translation.submitter.displayname
    u'Carlos Perell\xf3 Mar\xedn'
    >>> new_translation.date_created is None
    False

Since this is a suggestion, it is not counted as a translation.
The updateStatistics method returns four values:
 - The number of translations 'imported' that are being used.
 - The number of translations 'imported' that were updated in Launchpad.
 - The number of new translations added in Launchpad.
 - The number of messages that have suggestions to be reviewed.

    >>> upstream_pofile.updateStatistics()
    (0, 0, 0, 1)

We are adding a translation from the import.

    >>> upstream_potmsgset = evolution_potemplate.getPOTMsgSetByMsgIDText(
    ...     u'%d contact', u'%d contacts')

At this time, there is no current or imported translation and no suggestions.

    >>> print upstream_potmsgset.getCurrentTranslationMessage(
    ...     evolution_potemplate, catalan)
    None
    >>> print upstream_potmsgset.getImportedTranslationMessage(
    ...     evolution_potemplate, catalan)
    None
    >>> list(upstream_potmsgset.getLocalTranslationMessages(
    ...     evolution_potemplate, catalan))
    []

To add an imported translation, we need to set is_imported parameter.

    >>> new_translation = upstream_potmsgset.updateTranslation(
    ...     upstream_pofile, carlos, {0: u'foo %d', 1: u'foos %d'},
    ...     is_imported=True, lock_timestamp=datetime.now(UTC))

The new translation is reflected in the POFile statistics.

    >>> upstream_pofile.updateStatistics()
    (1, 0, 0, 1)

Since this message came from the import, it doesn't have a reviewer, but
it does note a person which last changed it.

    >>> current = upstream_potmsgset.getCurrentTranslationMessage(
    ...     evolution_potemplate, catalan)
    >>> print current.reviewer
    None
    >>> print current.date_reviewed
    None
    >>> current.submitter.displayname
    u'Carlos Perell\xf3 Mar\xedn'
    >>> current.date_created is None
    False

=== Unsetting a translation from the import ===

A translation can be removed from the import by being set to an empty string.

    >>> upstream_potmsgset = evolution_potemplate.getPOTMsgSetByMsgIDText(
    ...     u'have ')
    >>> new_translation = upstream_potmsgset.updateTranslation(
    ...     upstream_pofile, carlos, {0: u''},
    ...     is_imported=True, lock_timestamp=datetime.now(UTC))

Current translation is now unset, as is imported.

    >>> current = upstream_potmsgset.getCurrentTranslationMessage(
    ...     evolution_potemplate, catalan)
    >>> print current
    None
    >>> imported = upstream_potmsgset.getImportedTranslationMessage(
    ...     evolution_potemplate, catalan)
    >>> print imported
    None

Given that we unset an imported translation, statistics remain unchanged.

    >>> upstream_pofile.updateStatistics()
    (1, 0, 0, 1)

To unset an imported plural translation, we can add an empty translation.

    >>> upstream_potmsgset = evolution_potemplate.getPOTMsgSetByMsgIDText(
    ...     u'%d contact', u'%d contacts')
    >>> new_translation = upstream_potmsgset.updateTranslation(
    ...     upstream_pofile, carlos, {0: u'', 1: u''},
    ...     is_imported=True, lock_timestamp=datetime.now(UTC))

The statistics change to reflect that the message is not available
in upstream anymore, so it's now noted as newly translated in Launchpad.

    >>> upstream_pofile.updateStatistics()
    (0, 0, 0, 2)

=== Activating an existing suggestion ===

Foo Bar is a privileged translator who can do reviews and submit translations
directly, while No Privileges user can only submit suggestions.

    >>> foobar = getUtility(IPersonSet).getByName('name16')
    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')

We'll be working with Spanish PO file for Evolution, again handling
'evolution addressbook' message.

    >>> pofile_es = evolution_potemplate.getPOFileByLang('es')
    >>> spanish = pofile_es.language
    >>> potmsgset = evolution_potemplate.getPOTMsgSetByMsgIDText(
    ...     u'evolution addressbook')

At the moment, there are no suggestions for this message.

    >>> suggested = potmsgset.getLocalTranslationMessages(
    ...     evolution_potemplate, spanish)
    >>> len(list(suggested))
    0

A No Privileges user updates a translation.

    >>> new_message = potmsgset.updateTranslation(
    ...     pofile_es, no_priv, {0: u'test string'},
    ...     is_imported=False, lock_timestamp=datetime.now(UTC))

This message is not made current or marked as imported.

    >>> new_message.is_current
    False
    >>> new_message.is_imported
    False

Now, we should have one extra suggestion.

    >>> suggested = potmsgset.getLocalTranslationMessages(
    ...     evolution_potemplate, spanish)
    >>> len(list(suggested))
    1

That is the one that no_priv submitted.

    >>> suggested[0].translations
    [u'test string']

And the active translation is not the one we suggested.

    >>> current = potmsgset.getCurrentTranslationMessage(
    ...     potmsgset.potemplate, spanish)
    >>> current.translations
    [u'libreta de direcciones de Evolution']

And the reviewer for that message was Carlos:

    >>> current.reviewer.name
    u'carlos'

Now, Foo Bar, a translator with permissions, is going to approve that
new suggestion.

    >>> new_message = potmsgset.updateTranslation(
    ...     pofile_es, foobar, {0: u'test string'},
    ...     is_imported=False, lock_timestamp=datetime.now(UTC))

We don't have any suggestion newer than the new active translation

    >>> suggested = potmsgset.getLocalTranslationMessages(
    ...     evolution_potemplate, spanish)
    >>> len(list(suggested))
    0

And the active translation is now the one from no-priv user.

    >>> current = potmsgset.getCurrentTranslationMessage(
    ...     evolution_potemplate, spanish)
    >>> current.submitter.name
    u'no-priv'
    >>> current.translations
    [u'test string']

Also, we should have Foo Bar as the reviewer of that translation.

    >>> current.reviewer.displayname
    u'Foo Bar'


== Plural forms ==

Let's focus on handling of messages with plural forms.

An empty translation does not need to exist in the database.  If not,
a DummyPOFile is used instead.

    >>> pt_BR_dummypofile = evolution_potemplate.getDummyPOFile('pt_BR')

We get a POTMsgSet and verify it's a singular form:

    >>> potmsgset = pt_BR_dummypofile.potemplate.getPOTMsgSetByMsgIDText(
    ...     u'evolution addressbook')
    >>> potmsgset.msgid_plural is None
    True

    >>> current = potmsgset.getCurrentTranslationMessage(
    ...     evolution_potemplate, pt_BR_dummypofile.language)
    >>> print current
    None
    >>> pt_BR_dummy_current = potmsgset.getCurrentDummyTranslationMessage(
    ...     evolution_potemplate, pt_BR_dummypofile.language)
    >>> pt_BR_dummy_current.plural_forms
    1
    >>> pt_BR_dummy_current.translations
    [None]
    >>> pt_BR_dummy_current.is_imported
    False

A TranslationMessage knows what language it is in.

    >>> print pt_BR_dummy_current.pofile.language.code
    pt_BR

Using another dummy pofile we'll get a POTMsgset that's not a singular
form:

    >>> apa_dummypofile = evolution_potemplate.getDummyPOFile('apa')
    >>> plural_potmsgset = apa_dummypofile.potemplate.getPOTMsgSetByMsgIDText(
    ...     u'%d contact', u'%d contacts')
    >>> print apa_dummypofile.language.code
    apa

We don't know anything about pluralforms for this language, so we fall
back to the most common case:

    >>> print apa_dummypofile.language.pluralforms
    None
    >>> apa_dummy_current = (
    ...     plural_potmsgset.getCurrentDummyTranslationMessage(
    ...         evolution_potemplate, apa_dummypofile.language))
    >>> apa_dummy_current.plural_forms
    2
    >>> apa_dummy_current.translations
    [None, None]

We can guess the pluralforms for this language through ILanguage.pluralforms:

    >>> ru_dummypofile = evolution_potemplate.getDummyPOFile('ru')
    >>> ru_dummy_current = plural_potmsgset.getCurrentDummyTranslationMessage(
    ...     evolution_potemplate, ru_dummypofile.language)

    >>> print ru_dummypofile.language.pluralforms
    3
    >>> ru_dummy_current.plural_forms
    3
    >>> ru_dummy_current.translations
    [None, None, None]


=== Missing forms ===

Even when a message has a singular and a plural in English, a
translation does not have to cover all plural forms available in the
target language.

We call such a message incomplete, and undesirable as it is, it is still
gracefully accepted.

    >>> plural_potmsgset = pofile_es.potemplate.getPOTMsgSetByMsgIDText(
    ...     u'%d contact', u'%d contacts')
    >>> pofile_es.plural_forms
    2
    >>> message = plural_potmsgset.updateTranslation(pofile_es, foobar,
    ...     {0: u'foo %d', 1: None}, is_imported=False,
    ...     lock_timestamp=datetime.now(UTC))
    >>> message.is_complete
    False
    >>> message = plural_potmsgset.updateTranslation(pofile_es, foobar,
    ...     {0: None}, is_imported=False,
    ...     lock_timestamp=datetime.now(UTC))
    >>> message.is_complete
    False


=== Extraneous forms ===

It's not normally possible to input more plural forms for a translated
message than the language has.  But that number is configurable, and can
change (particularly when it is first defined).

As an example, let's look at the Zapotec translation for PowerMonger.

    >>> pm_translation = factory.makePOFile('zap')
    >>> zap = pm_translation.language

The number of plural forms in the Zapotec language is not configured,
so for now, the system guesses that it has two.

    >>> print zap.pluralforms
    None
    >>> print pm_translation.plural_forms
    2

    >>> pm_template = pm_translation.potemplate
    >>> pm_potmsgset = factory.makePOTMsgSet(
    ...     pm_template, singular='%d keyboard', plural='%d keyboards')

The message we're looking at is translated to two plural forms.

    >>> message_with_two_forms = pm_potmsgset.updateTranslation(
    ...     pm_translation, pm_template.owner, ['%d fu', '%d fuitl'],
    ...     is_imported=False, lock_timestamp=datetime.now(UTC))

When an otherwise identical translation with three comes along, the
third form is ignored because it falls outside the current 2 forms.
The "new" translation message is the same one we already had.

    >>> message_with_three_forms = pm_potmsgset.updateTranslation(
    ...     pm_translation, pm_template.owner,
    ...     ['%d fu', '%d fuitl', '%d fuitlx'], is_imported=False,
    ...     lock_timestamp=datetime.now(UTC))
    >>> message_with_three_forms == message_with_two_forms
    True

Based on the latest research, it is now decided that Zapotec has three
plural forms.  This time, uploading a three-form translation produces a
new translation message.

    >>> zap.pluralforms = 3
    >>> zap.pluralexpression = 'n % 3'

    >>> message_with_three_forms = pm_potmsgset.updateTranslation(
    ...     pm_translation, pm_template.owner,
    ...     ['%d fu', '%d fuitl', '%d fuitlx'], is_imported=False,
    ...     lock_timestamp=datetime.now(UTC))
    >>> message_with_three_forms == message_with_two_forms
    False

Now it is discovered that the very controversial Zapotec really only has
a single form.

    >>> zap.pluralforms = 1

When a new translation is submitted, again identical in the first form,
no new message is created.  Instead, the closest existing match (the
one with two forms) is updated.

    >>> message_with_one_form = pm_potmsgset.updateTranslation(
    ...     pm_translation, pm_template.owner, ['%d fu'],
    ...     is_imported=False, lock_timestamp=datetime.now(UTC))
    WARNING:...Translation for POTMsgSet ... into 'zap' matches
    2 existing translations.

    >>> message_with_one_form == message_with_two_forms
    True

This avoids the creation of redundant translation messages where
possible.


== isTranslationNewerThan ==

This method tells us whether the active translation was reviewed after
the given timestamp.

    >>> from pytz import UTC
    >>> translationmessage = TranslationMessage.get(2)
    >>> potmsgset = translationmessage.potmsgset
    >>> pofile = translationmessage.pofile
    >>> translationmessage.date_reviewed.isoformat()
    '2005-04-07T13:19:17.601068+00:00'
    >>> potmsgset.isTranslationNewerThan(pofile,
    ...     datetime(2004, 11, 30, 7, 0, 0, tzinfo=UTC))
    True
    >>> potmsgset.isTranslationNewerThan(pofile,
    ...     datetime(2006, 11, 30, 7, 0, 0, tzinfo=UTC))
    False


== External translation suggestions ==

External translation suggestions are current, imported or suggested
translation for exactly the same English string, but in a different
translation template.

    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, IPOTemplateSet, IProductSet)

Suggestions between modules depend also on whether the other translation
template is available to all users or should be ignored because
either the product or distribution where it's attached is not using
translations anymore or the translation template is not current anymore.

We will use this helper function to print all suggestions found:

    >>> def print_suggestions(suggestions):
    ...     """Print IPOFile title, translation and where is it used."""
    ...     lines = []
    ...     for suggestion in suggestions:
    ...         usage = []
    ...         if suggestion.is_current:
    ...             usage.append('Launchpad')
    ...         if suggestion.is_imported:
    ...             usage.append('Upstream')
    ...         if not usage:
    ...             usage.append('None')
    ...         lines.append('%s: %s (%s)' % (
    ...             suggestion.pofile.title,
    ...             suggestion.translations[0],
    ...             ' & '.join(usage)))
    ...     for line in sorted(lines):
    ...         print line


== POTMsgSet.getExternallyUsedTranslationMessages ==

 On one side, we have a translation template for the evolution product.

    >>> evo_product_template = evolution_potemplate
    >>> print evo_product_template.title
    Template "evolution-2.2" in Evolution trunk

On the other, we have a translation template for the evolution package in
Ubuntu Hoary distribution.

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> ubuntu_hoary = ubuntu.getSeries('hoary')
    >>> evo_hoary_package = ubuntu_hoary.getSourcePackage('evolution')
    >>> evo_distro_template = getUtility(IPOTemplateSet).getSubset(
    ...     sourcepackagename=evo_hoary_package.sourcepackagename,
    ...     distroseries=ubuntu_hoary).getPOTemplateByName('evolution-2.2')
    >>> print evo_distro_template.title
    Template "evolution-2.2" in Ubuntu Hoary package "evolution"

Both, product and distribution use Launchpad Translations.

    >>> evolution.official_rosetta
    True
    >>> ubuntu.official_rosetta
    True

And both translation templates are current

    >>> evo_product_template.iscurrent
    True
    >>> evo_distro_template.iscurrent
    True

We have the same message in both templates but with different
translations in Spanish:

    >>> evo_product_message = evo_product_template.getPOTMsgSetByMsgIDText(
    ...     ' cards')
    >>> evo_product_translation = (
    ...     evo_product_message.getCurrentTranslationMessage(
    ...         evo_product_template, spanish))
    >>> evo_product_translation.translations
    [u' tarjetas']
    >>> evo_distro_message = evo_distro_template.getPOTMsgSetByMsgIDText(
    ...     ' cards')
    >>> evo_distro_translation = (
    ...     evo_distro_message.getCurrentTranslationMessage(
    ...         evo_distro_template, spanish))
    >>> evo_distro_translation.translations
    [u' caratas']

    >>> suggestions = (
    ...     evo_product_message.getExternallyUsedTranslationMessages(spanish))
    >>> print_suggestions(suggestions)
    Spanish (es) translation of evolution-2.2 in Ubuntu Hoary package
    "evolution":  caratas (Launchpad)
    Spanish (es) translation of evolution-2.2 in Ubuntu Hoary package
    "evolution":  tarjetas (Upstream)

    >>> suggestions = evo_distro_message.getExternallyUsedTranslationMessages(
    ...    spanish)
    >>> print_suggestions(suggestions)
    Spanish (es) translation of evolution-2.2 in Evolution trunk:
    tarjetas (Launchpad & Upstream)

We need to be logged in as an admin to do some special attribute
changes:

    >>> login('carlos@canonical.com')

When a translation template is set as not current, those translations
are not available as suggestions anymore:

    >>> evo_distro_template.iscurrent = False
    >>> flush_database_updates()
    >>> suggestions = (
    ...     evo_product_message.getExternallyUsedTranslationMessages(spanish))
    >>> len(suggestions)
    0

The same happens if the distribution is not officially using
translations.

    >>> ubuntu.official_rosetta = False

    # We set the template as current again so we are sure that we don't show
    # suggestions just due to the change to the official_rosetta flag.
    >>> evo_distro_template.iscurrent = True
    >>> flush_database_updates()
    >>> suggestions = (
    ...     evo_product_message.getExternallyUsedTranslationMessages(spanish))
    >>> len(suggestions)
    0

And products not using translations officially have the same behaviour.

    >>> evolution.official_rosetta = False
    >>> flush_database_updates()
    >>> suggestions = evo_distro_message.getExternallyUsedTranslationMessages(
    ...    spanish)
    >>> len(suggestions)
    0

Let's restore the flags for next section.

    >>> ubuntu.official_rosetta = True
    >>> evolution.official_rosetta = True
    >>> flush_database_updates()


== POTMsgSet.getExternallySuggestedTranslationMessages ==

This method returns a set of submissions that have suggested translations
for the same msgid as the given POTMsgSet across the whole system.

We are going to work with the 'man' template in evolution package for
Ubuntu Hoary distribution.

    >>> evo_man_template = getUtility(IPOTemplateSet).getSubset(
    ...     sourcepackagename=evo_hoary_package.sourcepackagename,
    ...     distroseries=ubuntu_hoary).getPOTemplateByName('man')

Let's take a message 'test man page' that is translated into Spanish.

    >>> potmsgset_translated = evo_man_template.getPOTMsgSetByMsgIDText(
    ...     'test man page')
    >>> pofile = evo_man_template.getPOFileByLang('es')
    >>> print pofile.title
    Spanish (es) translation of man in Ubuntu Hoary package "evolution"
    >>> current = potmsgset_translated.getCurrentTranslationMessage(
    ...     evo_man_template, pofile.language)
    >>> print current.translations
    [u'just a translation']

It doesn't return other submissions done in the given IPOMsgSet because
the 'wiki' space is for any submission done outside that IPOMsgSet.

    # There is no other message with the same msgid in our system that has a
    # non active submission.
    >>> wiki_submissions = (
    ...     potmsgset_translated.getExternallySuggestedTranslationMessages(
    ...         pofile.language))
    >>> len(wiki_submissions)
    0

Now, we get a dummy message that has the same msgid as the previous one.
A dummy message is one that is not yet stored in our database, we use
them to be able to render those messages in our UI, once we get a
submission with a value for it, it's created in our database so it's not
dummy anymore.

    >>> pmount_hoary_package = ubuntu_hoary.getSourcePackage('pmount')
    >>> pmount_man_template = getUtility(IPOTemplateSet).getSubset(
    ...     sourcepackagename=pmount_hoary_package.sourcepackagename,
    ...     distroseries=ubuntu_hoary).getPOTemplateByName('man')
    >>> potmsgset_untranslated = pmount_man_template.getPOTMsgSetByMsgIDText(
    ...     'test man page')
    >>> pofile = pmount_man_template.getDummyPOFile('es')
    >>> print pofile.title
    Spanish (es) translation of man in Ubuntu Hoary package "pmount"

Given that it doesn't exist in our database, is impossible to have a
submission already for it.

    >>> current = potmsgset_untranslated.getCurrentTranslationMessage(
    ...     pmount_man_template, pofile.language)
    >>> print current
    None
    >>> imported = potmsgset_untranslated.getImportedTranslationMessage(
    ...     pmount_man_template, pofile.language)
    >>> print imported
    None

This other dummy IPOMsgSet though, will get all submissions done in
pomsgset_translated (except ones with the same translation that is already
active) as it's another context.

    >>> wiki_submissions = (
    ...     potmsgset_untranslated.getExternallySuggestedTranslationMessages(
    ...         pofile.language))
    >>> print_suggestions(wiki_submissions)
    Spanish (es) translation of man in Ubuntu Hoary package "evolution":
    blah, blah, blah (None)
    Spanish (es) translation of man in Ubuntu Hoary package "evolution":
    lalalala (None)

However, if the hoary template version is not current and thus hidden,
we get no suggestions.

    >>> potmsgset_translated.potemplate.iscurrent = False
    >>> flush_database_updates()

    >>> wiki_submissions = (
    ...     potmsgset_untranslated.getExternallyUsedTranslationMessages(
    ...         pofile.language))
    >>> len(wiki_submissions)
    0

Nor do we get any suggestions if the Ubuntu distribution is not using
Launchpad for translations.

    # We set the template as current again so we are sure that we don't show
    # suggestions just due to the change to the official_rosetta flag.
    >>> potmsgset_translated.potemplate.iscurrent = True
    >>> ubuntu.official_rosetta = False
    >>> flush_database_updates()

    >>> wiki_submissions = (
    ...     potmsgset_untranslated.getExternallyUsedTranslationMessages(
    ...         pofile.language))
    >>> len(wiki_submissions)
    0


== POTMsgSet.getCurrentDummyTranslationMessage ==

Sometimes, there are POTMsgSet objects with no translations to a language,
and we need to get dummy objects which emulate them to do read operations.
This method give us such dummy objects.

    >>> spanish_in_mexico = getUtility(ILanguageSet).getLanguageByCode(
    ...     'es_MX')
    >>> potmsgset.getCurrentDummyTranslationMessage(
    ...     evolution_potemplate, spanish_in_mexico) is None
    False

But, if we already have a TranslationMessage for a POTMsgSet in our database,
and we request a dummy one, that's broken and we detect it.

    >>> potmsgset.getCurrentDummyTranslationMessage(
    ...     evolution_potemplate, spanish)
    Traceback (most recent call last):
    ...
    AssertionError: There is already a translation message ...


== Variant translation ==

updateTranslation() is a core method of Translations, and it is used for
both importing translations or saving them through web UI.  At the
moment, we have some infrastructure to support "variant" languages,
differentiated by having '@something' in the locale name (examples are
sr@Latn for Serbian Latin translations, and sr@ijek for Serbian Jekavian
translations).

Language variants are differentiated by having a special variant field
in the PO files, and are currently only supported for imports (you can't
edit them through web UI).  For imports to work correctly,
updateTranslation needs to differentiate between TranslationMessages in
POFile without a variant set, and POFile with a variant set.

In our sample data, we already have a PO file for 'pmount' in Spanish
(es), and a PO file for 'pmount' in Spanish 'test' variant (es@test).

    >>> pmount_package = ubuntu_hoary.getSourcePackage('pmount')
    >>> pmount_template = getUtility(IPOTemplateSet).getSubset(
    ...     sourcepackagename=pmount_package.sourcepackagename,
    ...     distroseries=ubuntu_hoary).getPOTemplateByName('pmount')

This template in pmount package has a translation to es@test:

    >>> pofile_es_variant = pmount_template.getPOFileByLang(
    ...     'es', variant=u'test')
    >>> print pofile_es_variant.title
    Spanish (es) translation of pmount in Ubuntu Hoary package "pmount"
    >>> pofile_es_variant.variant
    u'test'

And a PO file in "basic" Spanish (no variant):

    >>> pofile_es = pmount_template.getPOFileByLang('es')
    >>> print pofile_es.title
    Spanish (es) translation of pmount in Ubuntu Hoary package "pmount"
    >>> print pofile_es.variant
    None

We can get a single POT message from pmount PO template:

    >>> potmsgset = pmount_template.getPOTMsgSetByMsgIDText(
    ...     u'Error: label too long\n')

And get translations for Spanish non-variant PO file when we specify
no variant in getCurrentTranslationMessage call:

    >>> current_es = potmsgset.getCurrentTranslationMessage(
    ...     pmount_template, pofile_es.language)
    >>> print current_es.translations
    [u'Error: etiqueta es demasiado larga\n']

And variant is indeed not set for this TranslationMessage:

    >>> print current_es.pofile.variant
    None

If we specify a variant from the Spanish 'test' PO file, we'll get a
TranslationMessage corresponding to that translation.

    >>> current_es_variant = potmsgset.getCurrentTranslationMessage(
    ...     pmount_template, pofile_es_variant.language,
    ...     variant=pofile_es_variant.variant)
    >>> print current_es_variant.translations
    [u'Error: etiqueta es demasiado larga\n']
    >>> print current_es_variant.pofile.variant
    test

We can update a translation for es@test using updateTranslation call:

    >>> new_translation = potmsgset.updateTranslation(pofile_es_variant,
    ...     carlos, {0: u'test variant translation\n'},
    ...     is_imported=True, lock_timestamp=datetime.now(UTC))

A new translation is saved in the PO file.

    >>> print new_translation.pofile.title
    Spanish (es) translation of pmount in Ubuntu Hoary package "pmount"
    >>> new_translation.pofile.variant
    u'test'
    >>> new_translation.is_current
    True
    >>> new_translation.is_imported
    True
    >>> current_es_variant = potmsgset.getCurrentTranslationMessage(
    ...     pmount_template, pofile_es_variant.language,
    ...     variant=pofile_es_variant.variant)
    >>> print current_es_variant.translations
    [u'test variant translation\n']

Translation in the Spanish PO file with no variant (pofile_es) will
stay the same as it was before the change to translation in
pofile_es_variant:

    >>> current_es = potmsgset.getCurrentTranslationMessage(
    ...     pmount_template, pofile_es.language)
    >>> print current_es.translations
    [u'Error: etiqueta es demasiado larga\n']

Trying to get a translation for non-existing variant returns None
from getCurrentTranslationMessage().

    >>> current_non_existing = potmsgset.getCurrentTranslationMessage(
    ...     pmount_template, pofile_es.language,
    ...     variant='not-existing-variant')
    >>> print current_non_existing
    None


== Suggestions for translator credits ==

Messages with translator credits are translated automatically by
Launchpad, so we should not get any suggestions for them.

To put 'external' suggestions in database, let's translate the
'translation-credits' message in alsa-utils template to Spanish.

    >>> alsa = getUtility(IProductSet).getByName('alsa-utils')
    >>> alsa_trunk = alsa.getSeries('trunk')
    >>> alsa_potemplate = alsa_trunk.getPOTemplate('alsa-utils')
    >>> translator_credits = alsa_potemplate.getPOTMsgSetByMsgIDText(
    ...     u'translation-credits')

    >>> spanish_pofile = alsa_potemplate.getPOFileByLang('es')
    >>> spanish = spanish_pofile.language

    >>> new_translation = translator_credits.updateTranslation(spanish_pofile,
    ...     carlos, {0: u'Some Translator'}, is_imported=True,
    ...     lock_timestamp=datetime.now(UTC))

    >>> current = translator_credits.getCurrentTranslationMessage(
    ...     alsa_potemplate, spanish)
    >>> current.translations
    [u'Some Translator']

Now, let's add 'translation-credits' message to a different POTemplate:

     >>> new_credits = evolution_potemplate.createMessageSetFromText(
     ...     singular_text=u'translation-credits', plural_text=None)

However, this one doesn't show up as external suggestion for Spanish.

    >>> new_credits.getExternallyUsedTranslationMessages(spanish)
    []
    >>> new_credits.getExternallySuggestedTranslationMessages(spanish)
    []

== POTMsgSet.setSequence ==

Finally, the new `IPOTMsgSet` should have an entry in the
`TranslationTemplateItem` table once we assign a sequence number.

    >>> from canonical.launchpad.database import TranslationTemplateItem

First, we need a helper function to check whether the potmsgset exists
in the table or not.


    >>> def is_potmsgset_in_potemplate(potmsgset, potemplate):
    ...     items = [
    ...         item.potmsgset.id
    ...         for item in TranslationTemplateItem.selectBy(
    ...             potemplate=potemplate, potmsgset=potmsgset)
    ...         if item.sequence > 0
    ...         ]
    ...     return potmsgset.id in items

Let's create a new potmsgset object.

    >>> potmsgset = potemplate.createMessageSetFromText(
    ...     u'This is just a test', None)

If we assign the sequence == 0, the POTMsgSet object doesn't have an
entry in the TranslationTemplateItems:

    >>> potmsgset.setSequence(potemplate, 0)
    >>> is_potmsgset_in_potemplate(potmsgset, potemplate)
    False
    >>> potmsgset.getSequence(potemplate)
    0

The used number doesn't matter as long as it's higher than zero.

    >>> potmsgset.setSequence(potemplate, 99)
    >>> is_potmsgset_in_potemplate(potmsgset, potemplate)
    True
    >>> potmsgset.getSequence(potemplate)
    99

If we change it back to zero, it's removed from the table:

    >>> potmsgset.setSequence(potemplate, 0)
    >>> is_potmsgset_in_potemplate(potmsgset, potemplate)
    False
    >>> potmsgset.getSequence(potemplate)
    0


== POTMsgSet.flags ==

The gettext format can associate flags with a POTMsgSet, such as "this
is a fuzzily matched message" or "this message follows C format-string
rules."  These flags are set in a comment starting with a comma, and
flags are separated by further commas.

    >>> from canonical.launchpad.database.potmsgset import POTMsgSet
    >>> flagged_potmsgset = POTMsgSet(flagscomment=", fuzzy, c-format")

The flags property produces these as a neat list of flags.

    >>> def print_flags(potmsgset):
    ...     for flag in sorted(potmsgset.flags):
    ...         print '"%s"' % flag
    ...     print '.'

    >>> print_flags(flagged_potmsgset)
    "c-format"
    "fuzzy"
    .

If the message has no flags, that list is empty.

    >>> print_flags(POTMsgSet())
    .

