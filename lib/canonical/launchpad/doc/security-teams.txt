Security Teams
==============

Responsibility for security-related bugs, whether undisclosed or public,
are modelled in Launchpad with a "security contact" on a Distribution or
a Product.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, IProductSet, IPersonSet, IHasSecurityContact)
    >>> personset = getUtility(IPersonSet)
    >>> productset = getUtility(IProductSet)
    >>> ubuntu = getUtility(IDistributionSet).get(1)
    >>> firefox = productset.get(4)

    >>> IHasSecurityContact.providedBy(ubuntu)
    True
    >>> IHasSecurityContact.providedBy(firefox)
    True

    >>> sabdfl = personset.get(1)
    >>> ubuntu_team = personset.get(17)

Security contacts are set with properties.

    >>> login("foo.bar@canonical.com")

    >>> ubuntu.security_contact = sabdfl
    >>> firefox.security_contact = ubuntu_team

    >>> print ubuntu.security_contact.name
    sabdfl

    >>> print firefox.security_contact.name
    ubuntu-team

When creating a bug, use the security_related flag to indicate that the
bug should be flagged as security-related, and the security contact
subscribed to the bug. Note that the security setting of a bug is
completely independent of the visibility of the bug, and no relationship
should be assumed between them.

    >>> from canonical.launchpad.interfaces import ILaunchBag

    >>> ubuntu_firefox = ubuntu.getSourcePackage("mozilla-firefox")
    >>> bug = ubuntu.createBug(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="a security bug",
    ...     comment="this is an example security bug",
    ...     security_related=True)

    >>> bug.security_related
    True

The reporter, Foo Bar, and the Ubuntu security contact, Mark
Shuttleworth are both subscribed to the bug.

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16', u'sabdfl']

If the bug were not reported as security-related, only Foo Bar would
have been subscribed:

    >>> from canonical.launchpad.interfaces import ILaunchBag

    >>> ubuntu_firefox = ubuntu.getSourcePackage("mozilla-firefox")
    >>> bug = ubuntu.createBug(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="a security bug",
    ...     comment="this is an example security bug",
    ...     security_related=False)

    >>> bug.security_related
    False

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16']

Likewise, filing a security-related bug on Firefox will subscribe the
security contact, the Ubuntu team, to the bug.

    >>> bug = firefox.createBug(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="another security bug",
    ...     comment="this is another security bug",
    ...     security_related=True)

    >>> bug.security_related
    True

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16', u'ubuntu-team']

Again, if the bug were not reported as security-related, the security
contact, the Ubuntu Team, would not have been subscribed:

    >>> bug = firefox.createBug(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="another security bug",
    ...     comment="this is another security bug",
    ...     security_related=False)

    >>> bug.security_related
    False

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16']

If the bug filed is as private and security_related, the security
contact will still get subscribed. The product registrant, Sample
Person, does not get subscribed to private bugs:

    >>> bug = firefox.createBug(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="another security bug",
    ...     comment="this is private security bug",
    ...     private=True, security_related=True)

    >>> bug.security_related
    True

    >>> bug.private
    True

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16', u'ubuntu-team']

When no security contact exists, only the reporter and product
registrant get subscribed.

    >>> firefox.security_contact = None

    >>> bug = firefox.createBug(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="another security bug",
    ...     comment="this is another security bug",
    ...     security_related=True)

    >>> bug.security_related
    True

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16']

When a bug is reported in another package or upstream, the security
contact for that package or upstream is automatically subscribed to the
bug, but *only* if the bug is public. Malone never auto-subscribes
anyone to private bugs, except if the user chooses that option when
filing a private security bug.

Let's first demonstrate adding a task to a public bug causing the
security contact of the new product to be subscribed.

    >>> from canonical.launchpad.interfaces import IBugTaskSet

    >>> bugtaskset = getUtility(IBugTaskSet)
    >>> evolution = productset.get(5)

We'll set lifeless as the security_contact for evolution.

    >>> lifeless = personset.get(2)
    >>> print lifeless.name
    lifeless

    >>> evolution.security_contact = lifeless

    >>> foobar = personset.get(16)
    >>> print foobar.name
    name16

    >>> bug_in_evolution = bugtaskset.createTask(
    ...     bug=bug, product=evolution, owner=foobar)

lifeless is subscribed to the public security bug when a task is added
for evolution.

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'lifeless', u'name16']

But if we repeat the process, using a private bug, he won't be subscribed:

    >>> bug = firefox.createBug(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="another security bug",
    ...     comment="this is private security bug",
    ...     private=True, security_related=True)

    >>> bug.security_related
    True

    >>> bug.private
    True

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16']

    >>> bug_in_evolution = bugtaskset.createTask(
    ...     bug=bug, product=evolution, owner=foobar)

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16']

Finally, reassigning a public bug to a different product will subscribe
the new security contact, if present. Let's set stub to the security
contact for thunderbird to see how this works.

    >>> thunderbird = productset.get(8)
    >>> print thunderbird.name
    thunderbird

    >>> stub = personset.get(22)
    >>> print stub.name
    stub

    >>> thunderbird.security_contact = stub

    >>> from zope.event import notify
    >>> from canonical.launchpad.event.sqlobjectevent import (
    ...     SQLObjectModifiedEvent)
    >>> from canonical.launchpad.webapp.snapshot import Snapshot
    >>> from canonical.launchpad.interfaces import IUpstreamBugTask

    >>> old_state = Snapshot(bug_in_evolution, providing=IUpstreamBugTask)
    >>> bug_in_evolution.product = thunderbird
    >>> bug_product_changed = SQLObjectModifiedEvent(
    ...     bug_in_evolution, old_state, ["product"])

First, let's publish the change event with the bug still marked private,
and notice that the subscription list doesn't change:

    >>> notify(bug_product_changed)

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16']

But publish the same event again, when the bug is marked public, and
stub will be added to the subscriber list:

    >>> bug.private = False

    >>> notify(bug_product_changed)

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16', u'stub']
