IBranchSetAPI
-------------

    >>> import xmlrpclib
    >>> from canonical.functional import XMLRPCTestTransport
    >>> branchset_api = xmlrpclib.ServerProxy(
    ...     'http://foo.bar@canonical.com:test@xmlrpc.launchpad.dev/bazaar/',
    ...     transport=XMLRPCTestTransport())

register_branch(branch_url, branch_name, branch_title,
                branch_description, author_email, product_name)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's register a branch using register_branch(). First we make sure that
there is no branch with the URL we are going to register.

    >>> from canonical.launchpad.interfaces import IBranchSet
    >>> branch_url = 'http://foo.com/branch'
    >>> getUtility(IBranchSet).getByUrl(branch_url) is None
    True

The only thing that we have to supply is the branch url. The rest is
optional, so we pass '' for the rest of the parameters. The reason we
pass '' is that XMLRPC doesn't allow optional parameters, and None is an
extension to XMLRPC which we don't want to rely on. We use the currently
authenticated user as the owner of the branch.

    >>> branchset_api.register_branch(
    ...      'http://foo.com/branch', '', '', '', '', '')
    'http://code.launchpad.dev/~name16/+junk/branch'

Now we can see that a branch got registered:

    >>> new_branch = getUtility(IBranchSet).getByUrl(branch_url)

The author and owner got set to the authenticated person; Foo Bar.

    >>> print new_branch.author.displayname
    Foo Bar
    >>> print new_branch.owner.displayname
    Foo Bar

The name got set to the last component of the URL since it wasn't
specified:

    >>> print new_branch.name
    branch

Since we didn't specify product, title or description, they are None:

    >>> new_branch.product is None
    True
    >>> new_branch.title is None
    True
    >>> new_branch.summary is None
    True


Let's register a branch specifying the name, description and product as
well:

    >>> other_branch_url = 'http://foo.com/other_branch'
    >>> branchset_api.register_branch(
    ...      other_branch_url, 'branch_name', 'branch_title',
    ...      'branch description', 'test@canonical.com', 'evolution')
    'http://code.launchpad.dev/~name16/evolution/branch_name'

    >>> new_branch = getUtility(IBranchSet).getByUrl(other_branch_url)
    >>> print new_branch.owner.displayname
    Foo Bar
    >>> print new_branch.author.displayname
    Sample Person

    >>> print new_branch.name
    branch_name
    >>> print new_branch.title
    branch_title
    >>> print new_branch.product.displayname
    Evolution

If we give a product name that doesn't exist, we get an error:

    >>> new_branch_url = 'http://foo.com/new_branch'
    >>> branchset_api.register_branch(
    ...      new_branch_url, 'branch_name', 'branch_title',
    ...      'branch description', 'test@canonical.com', 'non-existing')
    Traceback (most recent call last):
    ...
    Fault: <Fault 10: 'No such product: non-existing'>

If we give an email address which isn't registered in Launchpad:

    >>> branchset_api.register_branch(
    ...      new_branch_url, 'branch_name', 'branch_title',
    ...      'branch description', 'non-existing@canonical.com', 'evolution')
    Traceback (most recent call last):
    ...
    Fault: <Fault 20: 'Invalid author: No user with the email address
                      "non-existing@canonical.com" was found'>


Registering a branch name that ends in a slash works, but the slash
gets removed from the stored URL:

    >>> branchset_api.register_branch(
    ...     new_branch_url + '/', 'new_branch', 'branch_title',
    ...     'branch_description', 'test@canonical.com', 'evolution')
    'http://code.launchpad.dev/~name16/evolution/new_branch'

    >>> new_branch = getUtility(IBranchSet).getByUrl(new_branch_url)
    >>> print new_branch.url
    http://foo.com/new_branch
    >>> print new_branch.owner.name
    name16
    >>> print new_branch.product.name
    evolution
    >>> print new_branch.name
    new_branch


If we try to register a branch which is already registered in Launchpad:

    >>> getUtility(IBranchSet).getByUrl(other_branch_url) is not None
    True
    >>> branchset_api.register_branch(
    ...      other_branch_url, 'branch_name', 'branch_title',
    ...      'branch description', 'test@canonical.com', 'evolution')
    Traceback (most recent call last):
    ...
    Fault: <Fault 50: 'http://foo.com/other_branch is already registered.'>


We get the same error if we try to register the branch with a slash appended:
    >>> branchset_api.register_branch(
    ...      other_branch_url + '/', 'branch_name', 'branch_title',
    ...      'branch description', 'test@canonical.com', 'evolution')
    Traceback (most recent call last):
    ...
    Fault: <Fault 50: 'http://foo.com/other_branch is already registered.'>


link_branch_to_bug(branch_url, bug_id, whiteboard)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

link_branch_to_bug() associates a branch with a bug. Let's associate
the branch we registered with bug 1. If the link is successful, the bug
URL is returned.

    >>> branchset_api.link_branch_to_bug(other_branch_url, '1', '')
    'http://launchpad.dev/bugs/1'

Let's take a look to see that the branch actually got linked to the bug:

    >>> from canonical.launchpad.interfaces import IBugSet
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> for bug_branch in bug_one.bug_branches:
    ...     print "%s, %s, %s" % (
    ...         bug_branch.branch.url, bug_branch.status.title,
    ...         bug_branch.whiteboard)
    http://foo.com/other_branch, Fix In Progress, None

We can set the whiteboard:

    >>> branchset_api.link_branch_to_bug(
    ...     branch_url, 1, "i'm working on it today.")
    'http://launchpad.dev/bugs/1'
    >>> for bug_branch in bug_one.bug_branches:
    ...     print "%s, %s, %s" % (
    ...         bug_branch.branch.url, bug_branch.status.title,
    ...         bug_branch.whiteboard)
    http://foo.com/other_branch, Fix In Progress, None
    http://foo.com/branch, Fix In Progress, i'm working on it today.

We get an error if we try to specify a non-existant branch or bug:

    >>> branchset_api.link_branch_to_bug('http://foo.com/unknown', '1', '')
    Traceback (most recent call last):
    ...
    Fault: <Fault 30: 'No such branch: http://foo.com/unknown'>
    >>> branchset_api.link_branch_to_bug(branch_url, '99', '')
    Traceback (most recent call last):
    ...
    Fault: <Fault 40: 'No such bug: 99'>
