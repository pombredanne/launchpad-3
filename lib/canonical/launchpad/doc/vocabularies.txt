= Vocabularies =

== Introduction ==

Vocabularies are lists of terms. In Launchpad's Component Architecture
(CA), a vocabulary is a list of terms that a widget (normally a selection
style widget) "speaks", i.e., its allowed values.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.ftests import login
    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet, IOpenLaunchBag, IProductSet, IProjectSet)
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> login('foo.bar@canonical.com')
    >>> launchbag = getUtility(IOpenLaunchBag)
    >>> launchbag.clear()


=== Values, Tokens, and Titles ===

In Launchpad, we generally use "tokenized vocabularies." Each term in
a vocabulary has a value, token and title. A term is rendered in a
select widget like this:

<option value="$token">$title</option>

The $token is probably the data you would store in your DB. The Token is
used to uniquely identify a Term, and the Title is the thing you display
to the user.


== Launchpad Vocabularies ==

There are two kinds of vocabularies in Launchpad: enumerable and
non-enumerable. Enumerable vocabularies are short enough to render in a
select widget. Non-enumerable vocabularies require a query interface to make
it easy to choose just one or a couple of options from several hundred,
several thousand, or more.

Vocabularies should not be imported - they can be retrieved from the
vocabulary registry.

    >>> from zope.schema.vocabulary import getVocabularyRegistry
    >>> vocabulary_registry = getVocabularyRegistry()
    >>> product_vocabulary = vocabulary_registry.get(None, "Product")
    >>> product_vocabulary.displayname
    'Select a project'


== Enumerable Vocabularies ==

== ActiveMailingList ==

The active mailing lists vocabulary matches and returns only those mailing
lists which are active.

    >>> list_vocabulary = vocabulary_registry.get(None, 'ActiveMailingList')
    >>> list_vocabulary.displayname
    'Select an active mailing list.'

At first, there are no active mailing lists.

    >>> list(list_vocabulary)
    []
    >>> len(list_vocabulary)
    0
    >>> list(list_vocabulary.search())
    []

Mailing lists are not active when they are first registered.

    >>> # These are the convoluted steps to create some mailing lists.  We
    >>> # can't use the shortcuts in other tests because those leave the list
    >>> # in the ACTIVE state and we want to check things before they get to
    >>> # that state.
    >>> personset = getUtility(IPersonSet)
    >>> ddaa = personset.getByName('ddaa')
    >>> carlos = personset.getByName('carlos')
    >>> from canonical.launchpad.interfaces import (
    ...     IMailingListSet, MailingListStatus, TeamSubscriptionPolicy)
    >>> team_one = personset.newTeam(
    ...     ddaa, 'bass-players', 'Bass Players',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> team_two = personset.newTeam(
    ...     ddaa, 'guitar-players', 'Guitar Players',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> team_three = personset.newTeam(
    ...     ddaa, 'drummers', 'Drummers',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> listset = getUtility(IMailingListSet)
    >>> list_one = listset.new(team_one)
    >>> list_two = listset.new(team_two)
    >>> list_three = listset.new(team_three)
    >>> list(list_vocabulary)
    []
    >>> len(list_vocabulary)
    0
    >>> list(list_vocabulary.search())
    []

Even when the mailing lists are approved, they are not yet active.

    >>> list_one.review(carlos, MailingListStatus.APPROVED)
    >>> list_two.review(carlos, MailingListStatus.APPROVED)
    >>> list_three.review(carlos, MailingListStatus.APPROVED)
    >>> list(list_vocabulary)
    []
    >>> len(list_vocabulary)
    0
    >>> list(list_vocabulary.search())
    []

Mailing lists become active once they have been constructed by Mailman (which
indicates so by transitioning the state to ACTIVE).

    >>> list_one.startConstructing()
    >>> list_two.startConstructing()
    >>> list_three.startConstructing()
    >>> list_one.transitionToStatus(MailingListStatus.ACTIVE)
    >>> list_two.transitionToStatus(MailingListStatus.ACTIVE)
    >>> list_three.transitionToStatus(MailingListStatus.ACTIVE)
    >>> flush_database_updates()
    >>> sorted(mailing_list.team.displayname
    ...        for mailing_list in list_vocabulary)
    [u'Bass Players', u'Drummers', u'Guitar Players']
    >>> len(list_vocabulary)
    3

Searching for active lists is done through the vocabulary as well.  With a
search term of None, all active lists are returned.

    >>> sorted(mailing_list.team.displayname
    ...        for mailing_list in list_vocabulary.search(None))
    [u'Bass Players', u'Drummers', u'Guitar Players']

If given, the search term matches the team name.

    >>> sorted(mailing_list.team.displayname
    ...        for mailing_list in list_vocabulary.search('player'))
    [u'Bass Players', u'Guitar Players']

The vocabulary supports accessing mailing lists by 'term', where the term can
be either a team or a mailing list.  The returned term's value is the mailing
list object, the token is the team name and the title is the team's display
name.

    >>> term_1 = list_vocabulary.getTerm(team_one)
    >>> term_1.value.team.displayname
    u'Bass Players'
    >>> term_1.token
    'bass-players'
    >>> term_1.title
    u'Bass Players'

We can also get a term by mailing list.

    >>> term_2 = list_vocabulary.getTerm(list_two)
    >>> term_2.value.team.displayname
    u'Guitar Players'
    >>> term_2.token
    'guitar-players'
    >>> term_2.title
    u'Guitar Players'

Given a token, we can get back the term.

    >>> term_3 = list_vocabulary.getTermByToken(term_1.token)
    >>> term_3.value.team.displayname
    u'Bass Players'
    >>> term_4 = list_vocabulary.getTermByToken(term_2.token)
    >>> term_4.value.team.displayname
    u'Guitar Players'

You can also ask whether a team or mailing list is contained in the
vocabulary.

    >>> team_three in list_vocabulary
    True
    >>> list_three in list_vocabulary
    True

But non-ACTIVE mailing lists (and their teams) are not in the vocabulary.

    >>> team_four = personset.newTeam(
    ...     ddaa, 'flautists', 'Flautists',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> list_four = listset.new(team_four)
    >>> team_four in list_vocabulary
    False
    >>> list_four in list_vocabulary
    False

Sometimes, the vocabulary search doesn't return any active lists.

    >>> list(list_vocabulary.search('flautists'))
    []
    >>> list(list_vocabulary.search('cellists'))
    []


=== DistroSeriesVocabulary ===

Reflects the available distribution serieses.  Results are ordered by
`name`

    >>> distroseries_vocabulary = vocabulary_registry.get(
    ...     None,"DistroSeries")
    >>> for term in distroseries_vocabulary:
    ...     print "%30s %s" % (term.token, term.title)
            ubuntu/breezy-autotest Ubuntu: Breezy Badger Autotest
                     ubuntu/grumpy Ubuntu: The Grumpy Groundhog Release
                      ubuntu/hoary Ubuntu: The Hoary Hedgehog Release
                      ubuntu/warty Ubuntu: The Warty Warthog Release
                      debian/sarge Debian: Sarge
                        debian/sid Debian: Sid
                      debian/woody Debian: WOODY
                    guadalinex/2k5 GuadaLinex: Guada 2005
                    kubuntu/krunch Kubuntu: The Krunchy Kangaroo
                        redhat/7.0 Red Hat: Seven
                        redhat/six Red Hat: Six Six Six
        ubuntutest/breezy-autotest ubuntutest: Breezy Badger Autotest
             ubuntutest/hoary-test ubuntutest: Mock Hoary

    >>> distroseries_vocabulary.getTermByToken('ubuntu/hoary').value.title
    u'The Hoary Hedgehog Release'

    >>> def getTerms(vocab, search_text):
    ...     [vocab.toTerm(item) for item in vocab.search(search_text)]

    >>> getTerms(distroseries_vocabulary, 'woody')
    >>> getTerms(distroseries_vocabulary, 'debian')
    >>> getTerms(distroseries_vocabulary, 'invalid')
    >>> getTerms(distroseries_vocabulary, '')

    >> [term.token for term in distroseries_vocabulary.search('woody')]
    ['debian/woody']
    >> [term.token for term in distroseries_vocabulary.search('debian')]
    ['debian/sarge', 'debian/sid', 'debian/woody']
    >> [term.token for term in distroseries_vocabulary.search('invalid')]
    []
    >> [term.token for term in distroseries_vocabulary.search('')]
    []


=== DistributionUsingMaloneVocabulary ===

All the distributions that use Malone as their main bug tracker.

    >>> using_malone_vocabulary = vocabulary_registry.get(
    ...     None, 'DistributionUsingMalone')
    >>> len(using_malone_vocabulary)
    2
    >>> for term in using_malone_vocabulary:
    ...     print term.token, term.value.displayname, term.title
    gentoo Gentoo Gentoo
    ubuntu Ubuntu Ubuntu

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> ubuntu = getUtility(ILaunchpadCelebrities).ubuntu
    >>> ubuntu in using_malone_vocabulary
    True
    >>> debian = getUtility(ILaunchpadCelebrities).debian
    >>> debian in using_malone_vocabulary
    False

    >>> using_malone_vocabulary.getQuery() is None
    True

    >>> term = using_malone_vocabulary.getTerm(ubuntu)
    >>> print term.token, term.value.displayname, term.title
    ubuntu Ubuntu Ubuntu

    >>> term = using_malone_vocabulary.getTerm(debian)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> term = using_malone_vocabulary.getTermByToken('ubuntu')
    >>> print term.token, term.value.displayname, term.title
    ubuntu Ubuntu Ubuntu

    >>> term = using_malone_vocabulary.getTermByToken('debian')
    Traceback (most recent call last):
    ...
    LookupError:...


=== PersonActiveMembership ===

All the teams the person is an active member of.

    >>> foo_bar = getUtility(IPersonSet).getByEmail('foo.bar@canonical.com')
    >>> person_active_membership = vocabulary_registry.get(
    ...     foo_bar, 'PersonActiveMembership')
    >>> len(person_active_membership)
    8
    >>> for term in person_active_membership:
    ...     print term.token, term.value.displayname, term.title
    guadamen GuadaMen GuadaMen
    admins Launchpad Administrators Launchpad Administrators
    launchpad-buildd-admins Launchpad Buildd Admins Launchpad Buildd Admins
    launchpad Launchpad Developers Launchpad Developers
    testing-spanish-team testing Spanish team testing Spanish team
    name18 Ubuntu Gnome Team Ubuntu Gnome Team
    ubuntu-team Ubuntu Team Ubuntu Team
    vcs-imports VCS imports VCS imports

    >>> launchpad_team = getUtility(IPersonSet).getByName('launchpad')
    >>> launchpad_team in person_active_membership
    True
    >>> mirrors_admins = getUtility(IPersonSet).getByName('mirrors-admins')
    >>> mirrors_admins in person_active_membership
    False

    >>> person_active_membership.getQuery() is None
    True

    >>> term = person_active_membership.getTerm(launchpad_team)
    >>> print term.token, term.value.displayname, term.title
    launchpad Launchpad Developers Launchpad Developers

    >>> term = person_active_membership.getTerm(mirrors_admins)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> term = person_active_membership.getTermByToken('launchpad')
    >>> print term.token, term.value.displayname, term.title
    launchpad Launchpad Developers Launchpad Developers

    >>> term = person_active_membership.getTermByToken('mirrors-admins')
    Traceback (most recent call last):
    ...
    LookupError:...


=== PersonTeamParticipations ===

This vocabulary contains all the teams a person participates in. Either
through direct or indirect participations.

    >>> sample_person = getUtility(IPersonSet).getByName('name12')
    >>> [membership.team.name
    ...  for membership in sample_person.myactivememberships]
    [u'landscape-developers', u'name20']
    >>> [team.name for team in sample_person.teams_participated_in]
    [u'landscape-developers', u'name18', u'name20']

    >>> sample_person_teams_vocabulary = vocabulary_registry.get(
    ...     sample_person, 'PersonTeamParticipations')

    >>> for term in sample_person_teams_vocabulary:
    ...     print "%s: %s (%s)" % (term.token, term.title, term.value.name)
    landscape-developers: Landscape Developers (landscape-developers)
    name18: Ubuntu Gnome Team (name18)
    name20: Warty  Security Team (name20)


=== Milestone ===

All the milestone in a context.

If no context is given, all milestones in the database are in the
vocabulary.

    >>> all_milestones = vocabulary_registry.get(None, 'Milestone')
    >>> len(all_milestones)
    3
    >>> for term in all_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    debian: 3.1
    debian: 3.1-rc1
    firefox: 1.0

If the context is a product, only the product's milestones are in the
vocabulary.

    >>> from canonical.launchpad.interfaces import IProductSet
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> firefox_milestones = vocabulary_registry.get(firefox, 'Milestone')
    >>> for term in firefox_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    firefox: 1.0

If the context is a bugtask, only the bugtask's target's milestones are
in the vocabulary.

    >>> from canonical.launchpad.interfaces import IBugSet
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> firefox_task = bug_one.bugtasks[0]
    >>> firefox_task.bugtargetdisplayname
    u'Mozilla Firefox'
    >>> firefox_task_milestones = vocabulary_registry.get(
    ...     firefox_task, 'Milestone')
    >>> for term in firefox_task_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    firefox: 1.0

    >>> bug_two = getUtility(IBugSet).get(2)
    >>> debian_woody_task = bug_two.bugtasks[-1]
    >>> debian_woody_task.bugtargetdisplayname
    u'mozilla-firefox (Debian Woody)'
    >>> debian_woody_milestones = vocabulary_registry.get(
    ...     debian_woody_task, 'Milestone')
    >>> debian_woody = debian_woody_task.distroseries
    >>> len(debian_woody_milestones)
    2

If one of the milestones is disabled, it won't be included in the vocabulary
anymore.

    >>> milestone = debian_woody.milestones[0]
    >>> milestone.visible = False
    >>> flush_database_updates()
    >>> len(vocabulary_registry.get(debian_woody_task, 'Milestone'))
    1

If the milestone was used in a bugtask before it was marked invisible, though,
it'll still show up on the vocabulary so that users can change it.

    >>> debian_woody_task.milestone = milestone
    >>> flush_database_updates()
    >>> len(vocabulary_registry.get(debian_woody_task, 'Milestone'))
    2

If the context is a specification, only milestones from that specification
target are in the vocabulary.

    >>> from canonical.launchpad.interfaces import ISpecificationSet
    >>> canvas_spec = firefox.getSpecification('canvas')
    >>> spec_target_milestones = vocabulary_registry.get(
    ...     canvas_spec, 'Milestone')
    >>> for term in spec_target_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    firefox: 1.0


The vocabulary contains only visible milestones.

    >>> one_dot_o = firefox.milestones[0]
    >>> one_dot_o.name
    u'1.0'
    >>> one_dot_o.visible = False

    >>> for term in all_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    debian: 3.1
    >>> len(firefox_milestones)
    0
    >>> len(firefox_task_milestones)
    0

There's one exception, though; if a bugtask is assigned to a
non-visible milestone, that milestone will be in the vocabulary.

    >>> firefox_task.milestone = one_dot_o
    >>> for term in firefox_task_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    firefox: 1.0


=== BugNominatableSeriesVocabulary ===

All the serieses that can be nominated for fixing.

This vocabulary needs either a product or distribution in the launchbag
to get the available series. It also needs a bug, since it list only
series that haven't already been nominated.

Let's start with putting a product in the launchbag.

    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(firefox)

Firefox has the following series:

    >>> for series in firefox.serieses:
    ...     print series.name
    1.0
    trunk

Now, if we look at bug one, we can see that it hasn't been targeted
for any Firefox series yet:

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> for bugtask in bug_one.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Mozilla Firefox
    mozilla-firefox (Ubuntu)
    mozilla-firefox (Debian)

It has however been nominated for 1.0:

    >>> for nomination in bug_one.getNominations(firefox):
    ...     print nomination.target.name
    1.0

This means that if we iterate through the vocabulary with bug one, only
the trunk will be nominatable:

    >>> firefox_bug_one = bug_one.bugtasks[0]
    >>> firefox_bug_one.target.name
    u'firefox'
    >>> series_vocabulary = vocabulary_registry.get(
    ...     firefox_bug_one, 'BugNominatableSerieses')
    >>> for term in series_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    trunk: Trunk

No series is targeted or nominated on bug 4:

    >>> bug_four = getUtility(IBugSet).get(4)
    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Mozilla Firefox

    >>> for nomination in bug_four.getNominations(firefox):
    ...     print nomination.target.name

So if we give bug four to the vocabulary, all serieses will be returned:

    >>> firefox_bug_four = bug_four.bugtasks[0]
    >>> firefox_bug_four.target.name
    u'firefox'
    >>> series_vocabulary = vocabulary_registry.get(
    ...     firefox_bug_four, 'BugNominatableSerieses')
    >>> for term in series_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    1.0: 1.0
    trunk: Trunk

The same works for distributions:

    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(ubuntu)

Bug one is nominated for Ubuntu Hoary:

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> for bugtask in bug_one.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Mozilla Firefox
    mozilla-firefox (Ubuntu)
    mozilla-firefox (Debian)

    >>> for nomination in bug_one.getNominations(ubuntu):
    ...     print nomination.target.name
    hoary

So Hoary isn't included in the vocabulary:

    >>> ubuntu_bug_one = bug_one.bugtasks[1]
    >>> ubuntu_bug_one.distribution.name
    u'ubuntu'
    >>> serieses_vocabulary = vocabulary_registry.get(
    ...     ubuntu_bug_one, 'BugNominatableSerieses')
    >>> for term in serieses_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    breezy-autotest: Breezy-autotest
    grumpy: Grumpy
    warty: Warty

The same is true for bug two, where the bug is targeted to Hoary.

    >>> bug_two = getUtility(IBugSet).get(2)
    >>> for bugtask in bug_two.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Tomcat
    Ubuntu
    Ubuntu Hoary
    mozilla-firefox (Debian)
    mozilla-firefox (Debian Woody)

    >>> for nomination in bug_two.getNominations(ubuntu):
    ...     print nomination.target.name
    hoary

    >>> ubuntu_bug_two = bug_two.bugtasks[1]
    >>> ubuntu_bug_two.distribution.name
    u'ubuntu'
    >>> serieses_vocabulary = vocabulary_registry.get(
    ...     ubuntu_bug_two, 'BugNominatableSerieses')
    >>> for term in serieses_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    breezy-autotest: Breezy-autotest
    grumpy: Grumpy
    warty: Warty

We can get a specific term by using the release name:

    >>> term = serieses_vocabulary.getTermByToken('warty')
    >>> term.value == ubuntu.getSeries('warty')
    True

Trying to get a non-existant release will result in a LookupError:

    >>> series_vocabulary.getTermByToken('non-such-release')
    Traceback (most recent call last):
    ...
    LookupError...


=== ProjectProductsVocabulary ===

All the products in a project.

    >>> mozilla_project = getUtility(IProjectSet).getByName('mozilla')
    >>> mozilla_products_vocabulary = vocabulary_registry.get(
    ...     mozilla_project,'ProjectProducts')

    >>> for term in mozilla_products_vocabulary:
    ...     print "%s: %s" %(term.token, term.title)
    firefox: Mozilla Firefox
    thunderbird: Mozilla Thunderbird


=== ProjectProductsVocabularyUsingMalone ===

All the products in a project using Malone.


    >>> mozilla_project = getUtility(IProjectSet).getByName('mozilla')
    >>> for product in mozilla_project.products:
    ...     print "%s: %s" % (product.name, product.official_malone)
    firefox: True
    thunderbird: False

    >>> mozilla_products_vocabulary = vocabulary_registry.get(
    ...     mozilla_project,'ProjectProductsUsingMalone')
    >>> for term in mozilla_products_vocabulary:
    ...     print "%s: %s" %(term.token, term.title)
    firefox: Mozilla Firefox


== Non-Enumerable Vocabularies ==

Iterating over non-enumerable vocabularies, while possible, will
probably kill the database. Instead, these vocabularies are
search-driven.


=== BinaryAndSourcePackageNameVocabulary ===

The list of binary and source package names, ordered by name.

    >>> package_name_vocabulary = vocabulary_registry.get(
    ...     None, "BinaryAndSourcePackageName")
    >>> package_name_vocabulary.displayname
    'Select a Package'

When a package name matches both a binary package name and a source
package of the exact same name, the binary package name is
returned. This allows us, in bug reporting for example, to collect the
most specific information possible.

Let's demonstrate by searching for "mozilla-firefox", for which there is
both a source and binary package of that name.

    >>> from canonical.launchpad.interfaces import (
    ...     ISourcePackageName, IBinaryPackageName)

    >>> package_name_terms = package_name_vocabulary.searchForTerms("mozilla-firefox")
    >>> package_name_terms.count()
    2
    >>> [(term.token, term.title) for term in package_name_terms]
    [('mozilla-firefox', u'iceweasel huh ?'),
     ('mozilla-firefox-data', u'Mozilla Firefox Data is .....')]

Searching for "mozilla" should return the binary package name above, and
the source package named "mozilla".

    >>> package_name_terms = package_name_vocabulary.searchForTerms("mozilla")
    >>> package_name_terms.count()
    3
    >>> [(term.token, term.title) for term in package_name_terms]
    [('mozilla', 'Not uploaded'),
     ('mozilla-firefox', u'iceweasel huh ?'),
     ('mozilla-firefox-data', u'Mozilla Firefox Data is .....')]

The search does a case-insensitive, substring match.

    >>> package_name_terms = package_name_vocabulary.searchForTerms("lInuX")
    >>> package_name_terms.count()
    2
    >>> [(term.token, term.title) for term in package_name_terms]
    [('linux-2.6.12', u'this kernel is like the crystal method: a temple o...'),
     ('linux-source-2.6.15', u'Source of: linux-2.6.12')]


=== BinaryPackageNameVocabulary ===

All the binary packages in Launchpad.

    >>> bpn_vocabulary = vocabulary_registry.get(None, 'BinaryPackageName')
    >>> len(bpn_vocabulary)
    8

    >>> bpn_terms = bpn_vocabulary.searchForTerms("mozilla")
    >>> len(bpn_terms)
    2
    >>> [(term.token, term.title) for term in bpn_terms]
    [('mozilla-firefox', u'iceweasel huh ?'),
     ('mozilla-firefox-data', u'Mozilla Firefox Data is .....')]


=== SourcePackageNameVocabulary ===

All the source packages in Launchpad.

    >>> spn_vocabulary = vocabulary_registry.get(None, 'SourcePackageName')
    >>> len(spn_vocabulary)
    17

    >>> spn_terms = spn_vocabulary.searchForTerms("mozilla")
    >>> len(spn_terms)
    2
    >>> [(term.token, term.title) for term in spn_terms]
    [('mozilla', 'Not yet built'),
     ('mozilla-firefox', u'Source of: mozilla-firefox, mozilla-firefox-data')]

    >>> spn_terms = spn_vocabulary.searchForTerms("pmount")
    >>> len(spn_terms)
    1
    >>> [(term.token, term.title) for term in spn_terms]
    [('pmount', u'Source of: pmount')]


=== LanguageVocabulary ===

All the languages known by Launchpad.

    >>> from canonical.launchpad.interfaces import ILanguageSet
    >>> language_set = getUtility(ILanguageSet)

    >>> language_vocabulary = vocabulary_registry.get(
    ...     None, 'Language')
    >>> len(language_vocabulary)
    559

    >>> es = language_set['es']
    >>> term = language_vocabulary.getTerm(es)
    >>> print term.token, term.value.displayname, term.title
    es Spanish (es) Spanish (es)

    >>> pt_BR = language_set['pt_BR']
    >>> term = language_vocabulary.getTerm(pt_BR)
    >>> print term.token, term.value.displayname, term.title
    pt_BR Portuguese (Brazil) (pt_BR) Portuguese (Brazil) (pt_BR)

    >>> term = language_vocabulary.getTermByToken('es')
    >>> print term.token, term.value.displayname, term.title
    es Spanish (es) Spanish (es)

    >>> term = language_vocabulary.getTermByToken('pt_BR')
    >>> print term.token, term.value.displayname, term.title
    pt_BR Portuguese (Brazil) (pt_BR) Portuguese (Brazil) (pt_BR)

A language token/code may not be used with 'in' tests.

    >>> u'es' in language_vocabulary
    Traceback (most recent call last):
    ...
    AssertionError: 'in LanguageVocabulary' requires ILanguage
    as left operand, got <type 'unicode'> instead.

A LookupError is raised when a term is requested by token that does
not exist.

    >>> language_vocabulary.getTermByToken('foo')
    Traceback (most recent call last):
    ...
    LookupError:...


=== TranslatableLanguageVocabulary ===

All the translatable languages known by Launchpad. English is not
a translatable language, nor are Languages that are not visible.

The vocabulary will behave identically to LanguageVocabulary in tests
when the language is not English and is visible.

    >>> translatable_language_vocabulary = vocabulary_registry.get(
    ...     None, 'TranslatableLanguage')

    >>> es = language_set['es']
    >>> term = translatable_language_vocabulary.getTerm(es)
    >>> print term.token, term.value.displayname, term.title
    es Spanish (es) Spanish (es)

    >>> pt_BR = language_set['pt_BR']
    >>> term = translatable_language_vocabulary.getTerm(pt_BR)
    >>> print term.token, term.value.displayname, term.title
    pt_BR Portuguese (Brazil) (pt_BR) Portuguese (Brazil) (pt_BR)

    >>> term = translatable_language_vocabulary.getTermByToken('es')
    >>> print term.token, term.value.displayname, term.title
    es Spanish (es) Spanish (es)

    >>> term = translatable_language_vocabulary.getTermByToken('pt_BR')
    >>> print term.token, term.value.displayname, term.title
    pt_BR Portuguese (Brazil) (pt_BR) Portuguese (Brazil) (pt_BR)

    >>> es in translatable_language_vocabulary
    True

A language token/code may not be used with 'in' tests.

    >>> u'es' in translatable_language_vocabulary
    Traceback (most recent call last):
    ...
    AssertionError: 'in TranslatableLanguageVocabulary' requires
    ILanguage as left operand, got <type 'unicode'> instead.

A LookupError is raised when a term is requested by token that does
not exist.

    >>> translatable_language_vocabulary.getTermByToken('foo')
    Traceback (most recent call last):
    ...
    LookupError:...

English and non-visible languages are not in the
TranslatableLanguageVocabulary. English is the only visible language
excluded from the vocabulary.

    >>> translatable_languages = set(
    ...     t.value for t in translatable_language_vocabulary)
    >>> all_languages = set(l.value for l in language_vocabulary)
    >>> difference = list(all_languages - translatable_languages)
    >>> len(difference)
    89

    >>> hidden_languages = [lang for lang in difference if not lang.visible]
    >>> len(hidden_languages)
    88

    >>> [lang.displayname for lang in difference if lang.visible]
    [u'English (en)']

The vocabulary will raise a LookupError if asked to return English.

    >>> english = language_set['en']
    >>> english in difference
    True
    >>> english in hidden_languages
    False
    >>> english.visible
    True

    >>> english in translatable_language_vocabulary
    False

    >>> translatable_language_vocabulary.getTerm(english)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> translatable_language_vocabulary.getTermByToken('en')
    Traceback (most recent call last):
    ...
    LookupError:...

The vocabulary will raise a LookupError if asked to return a
non-visible language. Chinese (zh) is one such language.

    >>> chinese = language_set['zh']
    >>> chinese in difference
    True
    >>> chinese in hidden_languages
    True
    >>> chinese.visible
    False

    >>> chinese in translatable_language_vocabulary
    False

    >>> translatable_language_vocabulary.getTerm(chinese)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> translatable_language_vocabulary.getTermByToken('zh')
    Traceback (most recent call last):
    ...
    LookupError:...


=== BranchVocabulary ===

The list of bzr branches registered in Launchpad.

Searchable by branch name or URL, and searched within the context of a
product.

    >>> from canonical.launchpad.interfaces import IBranchSet

    >>> firefox = getUtility(IProductSet)["firefox"]
    >>> gnome_terminal = getUtility(IProductSet)["gnome-terminal"]

    >>> branch_vocabulary = vocabulary_registry.get(firefox, "Branch")

    >>> branches = branch_vocabulary.search(
    ...     "http://bazaar.example.com/mozilla@arch.ubuntu.com/"
    ...     "mozilla--release--0.9.2")

    >>> [branch.unique_name for branch in branches]
    [u'~sabdfl/firefox/release-0.9.2']

    >>> branches = branch_vocabulary.search(
    ...     "release-0.9.2")

    >>> [branch.unique_name for branch in branches]
    [u'~sabdfl/firefox/release-0.9.2']

The search will not match branches in another product:

    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch for branch in branches]
    []

Now, when we search in gnome-terminal, we'll find the "slowness"
branch:

    >>> branch_vocabulary = vocabulary_registry.get(
    ...     gnome_terminal, "Branch")
    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch.name for branch in branches]
    [u'slowness']

If the context is None or not a product, then the LaunchBag is checked
for a product.

    >>> launchbag.add(firefox)
    >>> branch_vocabulary = vocabulary_registry.get(None, "Branch")
    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch for branch in branches]
    []

If the context is not a product and the launchbag has no product, the
search covers all branches:

    >>> launchbag.clear()
    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch.name for branch in branches]
    [u'slowness']

    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> bugtask = getUtility(IBugTaskSet).get(2)
    >>> branch_vocabulary = vocabulary_registry.get(bugtask, "Branch")
    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch.name for branch in branches]
    [u'slowness']

The tokens used by terms retrieved from BranchVocabulary use the
branch unique name as an ID:

    >>> branch = getUtility(IBranchSet).get(15)
    >>> print branch.unique_name
    ~name12/gnome-terminal/main
    >>> term = branch_vocabulary.toTerm(branch)
    >>> print term.token
    ~name12/gnome-terminal/main

The BranchVocabulary recognises both unique names and URLs as tokens:

    >>> term = branch_vocabulary.getTermByToken('~name12/gnome-terminal/main')
    >>> term.value == branch
    True
    >>> term = branch_vocabulary.getTermByToken(
    ...     'http://bazaar.launchpad.dev/~name12/gnome-terminal/main/')
    >>> term.value == branch
    True
    >>> term = branch_vocabulary.getTermByToken(
    ...     'http://example.com/gnome-terminal/main')
    >>> term.value == branch
    True

The searches that the BranchVocabulary does are private branch aware.
The results are effectively filtered on what the logged in user is
able to see.

    >>> branches = branch_vocabulary.search("trunk")
    >>> for name in sorted([branch.unique_name for branch in branches]):
    ...     print name
    ~landscape-developers/landscape/trunk
    ~limi/+junk/trunk
    ~spiv/+junk/trunk

    >>> login('no-priv@canonical.com')
    >>> branches = branch_vocabulary.search("trunk")
    >>> for name in sorted([branch.unique_name for branch in branches]):
    ...     print name
    ~limi/+junk/trunk
    ~spiv/+junk/trunk

    >>> login('foo.bar@canonical.com')


=== ProjectVocabulary ===

The list of selectable projects. The results are ordered by displayname.

    >>> project_vocabulary = vocabulary_registry.get(None, "Project")
    >>> project_vocabulary.displayname
    'Select a project group'

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    [u'The Mozilla Project']
    >>> mozilla = project_vocabulary.getTermByToken('mozilla')
    >>> mozilla.title
    u'The Mozilla Project'

  The ProjectVocabulary does not list inactive projects.

    >>> from canonical.launchpad.interfaces import IProjectSet
    >>> moz_project = getUtility(IProjectSet)['mozilla']
    >>> moz_project in project_vocabulary
    True

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    [u'The Mozilla Project']
    >>> moz_project.active = False
    >>> flush_database_updates()
    >>> moz_project in project_vocabulary
    False

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    []
    >>> moz_project.active = True
    >>> flush_database_updates()


=== ProductVocabulary ===

The list of selectable products. Results are ordered by displayname.

    >>> product_vocabulary = vocabulary_registry.get(None, "Product")
    >>> product_vocabulary.displayname
    'Select a project'

    >>> list(product_vocabulary.search(None))
    []
    >>> gnome_products = product_vocabulary.search("gnome")
    >>> l = [product_term.title for product_term in gnome_products]
    >>> l[:2]
    [u'The Evolution Groupware Application', u'The GNOME Terminal Emulator']
    >>> l[2:]
    [u'The Gnome Panel Applets', u'Gnome Baker']
    >>> arch = product_vocabulary.getTermByToken("arch-mirrors")
    >>> arch.title
    u'Arch archive mirrors'

The ProductVocabulary does not list inactive products.

    >>> arch.value in product_vocabulary
    True

    >>> arch_product = getUtility(IProductSet)['arch-mirrors']
    >>> arch_product in product_vocabulary
    True

    >>> [t.title for t in product_vocabulary.search('arch and archive')]
    [u'Arch archive mirrors']
    >>> arch_product.active = False
    >>> flush_database_updates()
    >>> arch_product in product_vocabulary
    False
    >>> [t.title for t in product_vocabulary.search('arch and archive')]
    []
    >>> arch_product.active = True
    >>> flush_database_updates()


=== ProductReleaseVocabulary ===

The list of selectable products releases.

    >>> productrelease_vocabulary = vocabulary_registry.get(None,
    ...                                                     "ProductRelease")
    >>> productrelease_vocabulary.displayname
    'Select a Product Release'

    >>> list(productrelease_vocabulary.search(None))
    []
    >>> evolution_releases = productrelease_vocabulary.search("evolution")
    >>> l = [release_term.title for release_term in evolution_releases]
    >>> release = productrelease_vocabulary.getTermByToken(
    ...     "evolution/trunk/2.1.6")
    >>> release.title
    u'evolution trunk 2.1.6'


=== PersonAccountToMergeVocabulary ===

All non-merged people. This vocabulary is meant to be used only in the
people merge form.

    >>> vocab = vocabulary_registry.get(None, "PersonAccountToMerge")
    >>> vocab.displayname
    'Select a Person to Merge'

Searching for None returns an empty list.

    >>> list(vocab.search(None))
    []

Searching for 'Launchpad Administrators' will return an empty list, because
teams are not part of this vocabulary.

    >>> [item.name for item in list(vocab.search('Launchpad Administrators'))]
    []

A search using part of the email address of a team will also return an
empty list.

    >>> list(vocab.search('rosetta'))
    []

Searching for a person without a preferred email will return that
person's name.

    >>> [person.name for person in vocab.search('salgado')]
    [u'salgado']

A search using the beginning of a person's preferred email will return
that person that owns that email.

    >>> [(person.name, person.preferredemail.email)
    ...  for person in vocab.search('foo.bar')]
    [(u'name16', u'foo.bar@canonical.com')]

A search using part of the host of an email address will not return
anything, as we only match against the beginning of an email address.

    >>> list(vocab.search('canonical'))
    []

A person with a single and unvalidated email address can be merged.

    >>> from canonical.launchpad.interfaces import PersonCreationRationale
    >>> fooperson, email = getUtility(IPersonSet).createPersonAndEmail(
    ...     'foobaz@bar.com', PersonCreationRationale.UNKNOWN,
    ...     name='foobaz', displayname='foo baz')
    >>> fooperson in vocab
    True

But any person without a single email address can't.

    >>> email.destroySelf()
    >>> fooperson in vocab
    False

Any person that's already merged is not part of this vocabulary:

    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> cprov in vocab
    True

    # Here we cheat because IPerson.merged is a readonly attribute.
    >>> from zope.security.proxy import removeSecurityProxy
    >>> naked_cprov = removeSecurityProxy(cprov)
    >>> naked_cprov.merged = 1
    >>> naked_cprov.syncUpdate()
    >>> cprov in vocab
    False

A person whose account_status is any of the statuses of
INACTIVE_ACCOUNT_STATUSES is part of the vocabulary, though.

    >>> from canonical.launchpad.interfaces import INACTIVE_ACCOUNT_STATUSES
    >>> naked_cprov.merged = None
    >>> checked_count = 0
    >>> for status in INACTIVE_ACCOUNT_STATUSES:
    ...     naked_cprov.account_status = status
    ...     naked_cprov.syncUpdate()
    ...     checked_count += int(cprov in vocab)
    >>> checked_count == len(INACTIVE_ACCOUNT_STATUSES)
    True

=== NonMergedPeopleAndTeams ===

All non-merged people and teams.

    >>> vocab = vocabulary_registry.get(None, "NonMergedPeopleAndTeams")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> list(vocab.search(None))
    []

This vocabulary includes both validated and unvalidated profiles, as well
as teams:

    >>> [(p.name, p.is_valid_person) for p in vocab.search('limi@plone.org')]
    [(u'limi', False)]

    >>> [(p.name, p.is_valid_person) for p in vocab.search('mark@hbd.com')]
    [(u'sabdfl', True)]

    >>> [(p.name, p.teamowner.name) for p in vocab.search('ubuntu-team')]
    [(u'name18', u'sabdfl'), (u'ubuntu-team', u'sabdfl')]

But it doesn't include merged accounts:

    >>> fooperson in vocab
    False


=== ValidPersonOrTeam ===

All 'valid' persons or teams. This is currently defined as people with a
password, a preferred email address and not merged (Person.merged is
None) or any team.

    >>> vocab = vocabulary_registry.get(None, "ValidPersonOrTeam")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> list(vocab.search(None))
    []

We can do token lookups using either a person's name or a person's email
address.

    >>> vocab.getTermByToken('name16').value.displayname
    u'Foo Bar'
    >>> vocab.getTermByToken('foo.bar@canonical.com').value.displayname
    u'Foo Bar'

Almost all teams have the word 'team' as part of their names, so a search
for 'team' should give us some of them.

    >>> sorted(person.name for person in vocab.search('team'))
    [u'name18', u'name19', u'name20', u'name21', u'no-team-memberships', u'simple-team', u'testing-spanish-team', u'ubuntu-team']

A search for 'support' will give us only the persons which have support
as part of their name or displayname, or the beginning of
one of its email addresses.

    >>> sorted(person.name for person in vocab.search('support'))
    [u'ubuntu-team']

Dave hasn't validated his email address; he's not a valid Person.

    >>> sorted(person.name for person in vocab.search('dave.miller'))
    []

'foo.bar@canonical.com' is a valid Person.

    >>> [person.name for person in vocab.search('foo.bar')]
    [u'name16']

The vocabulary also allows us to search by IRC nickname.

    >>> [cjwatson] = vocab.search('cjwatson')
    >>> cjwatson.name, cjwatson.preferredemail.email
    (u'kamion', u'colin.watson@ubuntulinux.com')
    >>> [ircid.nickname for ircid in cjwatson.ircnicknames]
    [u'cjwatson']


=== ValidOwner ===

All valid persons and teams are also valid owners.

    >>> vocab = vocabulary_registry.get(None, "ValidOwner")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> list(vocab.search(None))
    []

Almost all teams have the word 'team' as part of their names, so a
search for 'team' should give us some of them:

    >>> sorted(person.name for person in vocab.search('team'))
    [u'name18', u'name19', u'name20', u'name21', u'no-team-memberships', u'simple-team', u'testing-spanish-team', u'ubuntu-team']


=== ValidTeam ===

The valid team vocabulary is just like the ValidPersonOrTeam vocabulary,
except that its terms are limited only to teams.  No non-team Persons will be
returned.

    >>> vocab = vocabulary_registry.get(None, 'ValidTeam')
    >>> vocab.displayname
    'Select a Team'
    >>> sorted((team.displayname, team.teamowner.displayname)
    ...        for team in vocab.search(None))
    [(u'Bass Players', u'David Allouche'),
     (u'Drummers', u'David Allouche'),
     (u'Flautists', u'David Allouche'),
     (u'GuadaMen', u'Foo Bar'),
     (u'Guitar Players', u'David Allouche'),
     (u'Hoary Gnome Team', u'Mark Shuttleworth'),
     (u'Landscape Developers', u'Sample Person'),
     (u'Launchpad Administrators', u'Mark Shuttleworth'),
     (u'Launchpad Beta Testers', u'Launchpad Beta Testers Owner'),
     (u'Launchpad Buildd Admins', u'Foo Bar'),
     (u'Launchpad Developers', u'Foo Bar'),
     (u'Mirror Administrators', u'Mark Shuttleworth'),
     (u'Registry Administrators', u'Mark Shuttleworth'),
     (u'Rosetta Administrators', u'Launchpad Administrators'),
     (u'ShipIt Administrators', u'Mark Shuttleworth'),
     (u'Simple Team', u'One Membership'),
     (u'Ubuntu Gnome Team', u'Mark Shuttleworth'),
     (u'Ubuntu Team', u'Mark Shuttleworth'),
     (u'Ubuntu Translators', u'Rosetta Administrators'),
     (u'VCS imports', u'Robert Collins'),
     (u'Warty Gnome Team', u'Mark Shuttleworth'),
     (u'Warty Security Team', u'Mark Shuttleworth'),
     (u'testing Spanish team', u'Carlos Perell\xf3 Mar\xedn')]

Like with ValidPersonOrTeam, you can narrow your search down by providing some
text to match against the team name.  Still, you only get teams back.

    >>> sorted((team.displayname, team.teamowner.displayname)
    ...         for team in vocab.search('spanish'))
    [(u'testing Spanish team', u'Carlos Perell\xf3 Mar\xedn')]
    >>> sorted((team.displayname, team.teamowner.displayname)
    ...        for team in vocab.search('spanish | ubuntu'))
    [(u'Mirror Administrators', u'Mark Shuttleworth'),
     (u'Ubuntu Gnome Team', u'Mark Shuttleworth'),
     (u'Ubuntu Team', u'Mark Shuttleworth'),
     (u'Ubuntu Translators', u'Rosetta Administrators'),
     (u'testing Spanish team', u'Carlos Perell\xf3 Mar\xedn')]
    >>> sorted((team.displayname, team.teamowner.displayname)
    ...        for team in vocab.search('team'))
    [(u'Hoary Gnome Team', u'Mark Shuttleworth'),
     (u'Simple Team', u'One Membership'),
     (u'Ubuntu Gnome Team', u'Mark Shuttleworth'),
     (u'Ubuntu Team', u'Mark Shuttleworth'),
     (u'Warty Gnome Team', u'Mark Shuttleworth'),
     (u'Warty Security Team', u'Mark Shuttleworth'),
     (u'testing Spanish team', u'Carlos Perell\xf3 Mar\xedn')]


=== ValidTeamMember ===

With the exception of all teams that have this team as a member and the
team itself, all valid persons and teams are valid members.

    >>> team = getUtility(IPersonSet).getByName('ubuntu-team')
    >>> team2 = getUtility(IPersonSet).getByName('guadamen')
    >>> person = getUtility(IPersonSet).getByName('name16')

ValidTeamMember needs a context:

    >>> vocab = vocabulary_registry.get(None, "ValidTeamMember")
    Traceback (most recent call last):
    ...
    AssertionError: ...

ValidTeamMember's context must implement ITeam:

    >>> vocab = vocabulary_registry.get(person, "ValidTeamMember")
    Traceback (most recent call last):
    ...
    AssertionError: ...

'name16' is a valid member for 'ubuntu-team':

    >>> vocab = vocabulary_registry.get(team, "ValidTeamMember")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> person in vocab
    True
    >>> [person.name for person in vocab.search('foo.bar')]
    [u'name16']

'ubuntu-team' is not a valid member for itself:

    >>> team in vocab
    False
    >>> [person.name for person in vocab.search('ubuntu-team')]
    [u'name18']

'ubuntu-team' is a member of 'guadamen', so 'guadamen' can't be a member
of 'ubuntu-team'.

    >>> team2 in vocab
    False
    >>> [person.name for person in vocab.search('guadamen')]
    []


=== ValidTeamOwner ===

With the exception of the team itself and all teams owned by that team,
all valid persons and teams are valid owners for the team in context.

ValidTeamOwner needs a context.

    >>> vocab = vocabulary_registry.get(None, "ValidTeamOwner")
    Traceback (most recent call last):
    ...
    AssertionError: ...

ValidTeamOwner's context must be a team.

    >>> person = getUtility(IPersonSet).getByName('name16')
    >>> vocab = vocabulary_registry.get(person, "ValidTeamOwner")
    Traceback (most recent call last):
    ...
    AssertionError: ...

'ubuntu-team' is not a valid owner for itself.

    >>> vocab = vocabulary_registry.get(team, "ValidTeamOwner")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> team in vocab
    False
    >>> [person.name for person in vocab.search('ubuntu-team')]
    [u'name18']

'name16' is a valid owner for 'ubuntu-team'.

    >>> person in vocab
    True
    >>> [person.name for person in vocab.search('foo.bar')]
    [u'name16']


=== Processor ===

All processors type available in Launchpad.

    >>> vocab = vocabulary_registry.get(None, "Processor")
    >>> vocab.displayname
    'Select a Processor'

    >>> [term.token for term in vocab.searchForTerms('386')]
    ['386']


=== BugWatchVocabulary ===

All bug watches associated with a bugtask's bug

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bugtask = bug_one.bugtasks[0]
    >>> vocab = vocabulary_registry.get(bugtask, "BugWatch")
    >>> for term in vocab:
    ...     print term.title
    The Mozilla.org Bug Tracker <a...>#123543</a>
    The Mozilla.org Bug Tracker <a...>#2000</a>
    The Mozilla.org Bug Tracker <a...>#42</a>
    Debian Bug tracker <a...>#304014</a>


=== DistributionOrProductVocabulary ===

All products and distributions. Note that the value type is
heterogeneous.

    >>> vocab = vocabulary_registry.get(None, "DistributionOrProduct")
    >>> for term in vocab:
    ...     if 'Ubuntu' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Ubuntu Linux (Distribution) - class Distribution
    Ubuntu Test (Distribution) - class Distribution

Inactive projects and project groups are not available.

    >>> for term in vocab:
    ...     if 'Tomcat' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Tomcat (Product) - class Product
    >>> tomcat = getUtility(IProductSet).getByName('tomcat')
    >>> tomcat in vocab
    True
    >>> tomcat.active = False
    >>> flush_database_updates()
    >>> vocab = vocabulary_registry.get(None, "DistributionOrProduct")
    >>> tomcat in vocab
    False
    >>> tomcat.active = True
    >>> flush_database_updates()
    >>> vocab = vocabulary_registry.get(None, "DistributionOrProduct")
    >>> tomcat in vocab
    True

Project groups are not contained in this vocabulary:

    >>> apache = getUtility(IProjectSet).getByName('apache')
    >>> apache in vocab
    False


=== DistributionOrProductOrProjectVocabulary ===

All products, projects and distributions. Note that the value type is
heterogeneous.

    >>> vocab = vocabulary_registry.get(None, "DistributionOrProductOrProject")
    >>> for term in vocab:
    ...     if 'Ubuntu' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Ubuntu Linux (Distribution) - class Distribution
    Ubuntu Test (Distribution) - class Distribution

Inactive projects and project groups are not available.

    >>> from canonical.launchpad.ftests import syncUpdate
    >>> tomcat = getUtility(IProductSet).getByName('tomcat')
    >>> tomcat in vocab
    True
    >>> tomcat.active = False
    >>> syncUpdate(tomcat)
    >>> tomcat in vocab
    False

    >>> apache = getUtility(IProjectSet).getByName('apache')
    >>> apache in vocab
    True
    >>> apache.active = False
    >>> syncUpdate(apache)
    >>> apache in vocab
    False

    >>> vocab = vocabulary_registry.get(None, "DistributionOrProductOrProject")
    >>> for term in vocab:
    ...     if 'Apache' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    >>> for term in vocab:
    ...     if 'Tomcat' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    >>> getUtility(IProductSet).getByName('tomcat').active = True
    >>> getUtility(IProjectSet).getByName('apache').active = True
    >>> flush_database_updates()
    >>> vocab = vocabulary_registry.get(None, "DistributionOrProductOrProject")
    >>> for term in vocab:
    ...     if 'Apache' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Apache (Project) - class Project
    >>> for term in vocab:
    ...     if 'Tomcat' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Tomcat (Product) - class Product


=== FAQ ===

The FAQ vocabulary contains all the FAQs available in a particular
collection. It provides the IHugeVocabulary interface.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.webapp.vocabulary import IHugeVocabulary

    >>> vocabulary = vocabulary_registry.get(firefox, 'FAQ')
    >>> verifyObject(IHugeVocabulary, vocabulary)
    True

    >>> print vocabulary.displayname
    Select a FAQ

It contains all the FAQs of the collection, but not those from other
collections:

    >>> firefox_faqs = set(firefox.searchFAQs())
    >>> vocabulary_faqs = set(term.value for term in vocabulary)
    >>> firefox_faqs.symmetric_difference(vocabulary_faqs)
    set([])

And it only contains FAQs:

    >>> u'10' in vocabulary
    False

The term's token is the FAQ's id and its title is the FAQ's title:

    >>> firefox_faq = firefox.getFAQ(10)
    >>> term = vocabulary.getTerm(firefox_faq)
    >>> term.token
    '10'
    >>> print term.title
    How do I install plugins (Shockwave, QuickTime, etc.)?

Asking for something which isn't a FAQ of the target raises LookupError:

    >>> ubuntu_faq = ubuntu.getFAQ(1)
    >>> vocabulary.getTerm(ubuntu_faq)
    Traceback (most recent call last):
      ...
    LookupError:...

Since IHugeVocabulary extends IVocabularyTokenized, the term can also
be retrieved by token:

    >>> term = vocabulary.getTermByToken(u'10')
    >>> print term.title
    How do I install plugins (Shockwave, QuickTime, etc.)?

Trying to retrieve an invalid or non-existent token raises LookupError:

    >>> vocabulary.getTermByToken('not a good token')
    Traceback (most recent call last):
      ...
    LookupError:...

    >>> vocabulary.getTermByToken('1001')
    Traceback (most recent call last):
      ...
    LookupError:...

The searchForTerms() method returns a CountableIterator of terms that
are similar to the query:

    >>> from canonical.launchpad.webapp.vocabulary import CountableIterator
    >>> terms = vocabulary.searchForTerms('Problem showing SVG')
    >>> isinstance(terms, CountableIterator)
    True
    >>> terms.count()
    2
    >>> for term in terms:
    ...     print term.title
    How do I troubleshoot problems with extensions/themes?
    How do I install Java?


== SpecificationDepCandidatesVocabulary ==

All blueprints that can be added as a dependency of the
context blueprint.

First, we set up a product with three blueprints.

    >>> from canonical.lp.dbschema import SpecificationDefinitionStatus
    >>> evolution = getUtility(IProductSet).getByName('evolution')
    >>> foobar_person = getUtility(IPersonSet).getByName('name16')
    >>> foobar_person.displayname
    u'Foo Bar'
    >>> specset = getUtility(ISpecificationSet)
    >>> spec_a = specset.new('spec-a', 'Spec A',
    ...     'http://www.example.org/SpecA', 'The first spec',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=evolution)
    >>> spec_b = specset.new('spec-b', 'Spec B',
    ...     'http://www.example.org/SpecB', 'The second spec',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=evolution)
    >>> spec_c = specset.new('spec-c', 'Spec C',
    ...     'http://www.example.org/SpecC', 'The third spec',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=evolution)
    >>> sorted([spec.name for spec in evolution.specifications()])
    [u'spec-a', u'spec-b', u'spec-c']

The dependency candidates for spec_a are all blueprints for evolution
except for spec_a itself.

    >>> vocab = vocabulary_registry.get(
    ...     spec_a, "SpecificationDepCandidates")
    >>> sorted([term.value.name for term in vocab])
    [u'spec-b', u'spec-c']

Dependency candidate come only from the same product of the blueprint
they depend on.

    >>> unrelated_spec = specset.new('unrelated-spec', 'Unrelated Spec',
    ...     'http://example.com/SpecU', 'A spec unrelated to Evolution',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=firefox)
    >>> vocab = vocabulary_registry.get(
    ...     spec_a, "SpecificationDepCandidates")
    >>> unrelated_spec in vocab
    False
    >>> [term.value.product for term in vocab
    ...  if term.value.product != evolution]
    []

We mark spec_b as a dependency of spec_a and spec_c as a dependency
of spec_b.

    >>> spec_a.createDependency(spec_b)
    <SpecificationDependency at ...>
    >>> [spec.name for spec in spec_a.dependencies]
    [u'spec-b']

    >>> spec_b.createDependency(spec_c)
    <SpecificationDependency at ...>
    >>> [spec.name for spec in spec_b.dependencies]
    [u'spec-c']

No circular dependencies - the vocabulary excludes specifications that
are a dependency of the context spec.

    >>> spec_a in spec_b.all_blocked
    True
    >>> spec_b in spec_c.all_blocked
    True
    >>> vocab = vocabulary_registry.get(
    ...     spec_c, "SpecificationDepCandidates")
    >>> spec_a in [term.value for term in vocab]
    False

This vocabulary provides the IHugeVocabulary interface.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.webapp.vocabulary import IHugeVocabulary
    >>> verifyObject(IHugeVocabulary, vocab)
    True

The search() method returns specifications within the vocabulary
that matches the search string. The string is matched against the name,
or fallbacks to a full text search.

    >>> vocab = vocabulary_registry.get(
    ...     spec_a, "SpecificationDepCandidates")
    >>> list(vocab.search('ec-b')) == [spec_b]
    True
    >>> list(vocab.search('third')) == [spec_c]
    True

# XXX Tom Berger 2007-07-05: document more vocabularies here, particularly
# when they break!
