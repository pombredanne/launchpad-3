Vocabularies
============

Introduction
------------

Vocabularies are lists of terms. In Launchpad's Component Architecture
(CA), a vocabulary is a list of terms that a widget (normally a selection
style widget) "speaks", i.e., its allowed values.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.ftests import ANONYMOUS, login
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.webapp.interfaces import IOpenLaunchBag
    >>> from lp.registry.interfaces.person import IPersonSet
    >>> from lp.registry.interfaces.product import IProductSet
    >>> from lp.registry.interfaces.projectgroup import IProjectGroupSet
    >>> person_set = getUtility(IPersonSet)
    >>> product_set = getUtility(IProductSet)
    >>> login('foo.bar@canonical.com')
    >>> launchbag = getUtility(IOpenLaunchBag)
    >>> launchbag.clear()


Values, Tokens, and Titles
..........................

In Launchpad, we generally use "tokenized vocabularies." Each term in
a vocabulary has a value, token and title. A term is rendered in a
select widget like this:

<option value="$token">$title</option>

The $token is probably the data you would store in your DB. The Token is
used to uniquely identify a Term, and the Title is the thing you display
to the user.


Launchpad Vocabularies
----------------------

There are two kinds of vocabularies in Launchpad: enumerable and
non-enumerable. Enumerable vocabularies are short enough to render in a
select widget. Non-enumerable vocabularies require a query interface to make
it easy to choose just one or a couple of options from several hundred,
several thousand, or more.

Vocabularies should not be imported - they can be retrieved from the
vocabulary registry.

    >>> from zope.schema.vocabulary import getVocabularyRegistry
    >>> from zope.security.proxy import removeSecurityProxy
    >>> vocabulary_registry = getVocabularyRegistry()
    >>> def get_naked_vocab(context, name):
    ...     return removeSecurityProxy(
    ...         vocabulary_registry.get(context, name))
    >>> product_vocabulary = vocabulary_registry.get(None, "Product")
    >>> product_vocabulary.displayname
    'Select a project'


Enumerable Vocabularies
-----------------------


DistributionUsingMaloneVocabulary
.................................

All the distributions that use Malone as their main bug tracker.

    >>> using_malone_vocabulary = get_naked_vocab(
    ...     None, 'DistributionUsingMalone')
    >>> len(using_malone_vocabulary)
    2
    >>> for term in using_malone_vocabulary:
    ...     print term.token, term.value.displayname, term.title
    gentoo Gentoo Gentoo
    ubuntu Ubuntu Ubuntu

    >>> from lp.app.interfaces.launchpad import ILaunchpadCelebrities
    >>> ubuntu = getUtility(ILaunchpadCelebrities).ubuntu
    >>> ubuntu in using_malone_vocabulary
    True
    >>> debian = getUtility(ILaunchpadCelebrities).debian
    >>> debian in using_malone_vocabulary
    False

    >>> term = using_malone_vocabulary.getTerm(ubuntu)
    >>> print term.token, term.value.displayname, term.title
    ubuntu Ubuntu Ubuntu

    >>> term = using_malone_vocabulary.getTerm(debian)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> term = using_malone_vocabulary.getTermByToken('ubuntu')
    >>> print term.token, term.value.displayname, term.title
    ubuntu Ubuntu Ubuntu

    >>> term = using_malone_vocabulary.getTermByToken('debian')
    Traceback (most recent call last):
    ...
    LookupError:...


BugNominatableSeriesVocabulary
..............................

All the series that can be nominated for fixing.

This vocabulary needs either a product or distribution in the launchbag
to get the available series. It also needs a bug, since it list only
series that haven't already been nominated.

Let's start with putting a product in the launchbag.

    >>> firefox = product_set.getByName('firefox')
    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(firefox)

Firefox has the following series:

    >>> for series in firefox.series:
    ...     print series.name
    1.0
    trunk

Now, if we look at bug one, we can see that it hasn't been targeted
for any Firefox series yet:

    >>> from lp.bugs.interfaces.bug import IBugSet

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> for bugtask in bug_one.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Mozilla Firefox
    mozilla-firefox (Ubuntu)
    mozilla-firefox (Debian)

It has however been nominated for 1.0:

    >>> for nomination in bug_one.getNominations(firefox):
    ...     print nomination.target.name
    1.0

This means that if we iterate through the vocabulary with bug one, only
the trunk will be nominatable:

    >>> firefox_bug_one = bug_one.bugtasks[0]
    >>> firefox_bug_one.target.name
    u'firefox'
    >>> series_vocabulary = vocabulary_registry.get(
    ...     firefox_bug_one, 'BugNominatableSeries')
    >>> for term in series_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    trunk: Trunk

No series is targeted or nominated on bug 4:

    >>> bug_four = getUtility(IBugSet).get(4)
    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Mozilla Firefox

    >>> for nomination in bug_four.getNominations(firefox):
    ...     print nomination.target.name

So if we give bug four to the vocabulary, all series will be returned:

    >>> firefox_bug_four = bug_four.bugtasks[0]
    >>> firefox_bug_four.target.name
    u'firefox'
    >>> series_vocabulary = vocabulary_registry.get(
    ...     firefox_bug_four, 'BugNominatableSeries')
    >>> for term in series_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    1.0: 1.0
    trunk: Trunk

The same works for distributions:

    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(ubuntu)

Bug one is nominated for Ubuntu Hoary:

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> for bugtask in bug_one.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Mozilla Firefox
    mozilla-firefox (Ubuntu)
    mozilla-firefox (Debian)

    >>> for nomination in bug_one.getNominations(ubuntu):
    ...     print nomination.target.name
    hoary

So Hoary isn't included in the vocabulary:

    >>> ubuntu_bug_one = bug_one.bugtasks[1]
    >>> ubuntu_bug_one.distribution.name
    u'ubuntu'
    >>> series_vocabulary = vocabulary_registry.get(
    ...     ubuntu_bug_one, 'BugNominatableSeries')
    >>> for term in series_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    breezy-autotest: Breezy-autotest
    grumpy: Grumpy
    warty: Warty

The same is true for bug two, where the bug is targeted to Hoary.

    >>> bug_two = getUtility(IBugSet).get(2)
    >>> for bugtask in bug_two.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Tomcat
    Ubuntu
    Ubuntu Hoary
    mozilla-firefox (Debian)
    mozilla-firefox (Debian Woody)

    >>> for nomination in bug_two.getNominations(ubuntu):
    ...     print nomination.target.name
    hoary

    >>> ubuntu_bug_two = bug_two.bugtasks[1]
    >>> ubuntu_bug_two.distribution.name
    u'ubuntu'
    >>> series_vocabulary = vocabulary_registry.get(
    ...     ubuntu_bug_two, 'BugNominatableSeries')
    >>> for term in series_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    breezy-autotest: Breezy-autotest
    grumpy: Grumpy
    warty: Warty

We can get a specific term by using the release name:

    >>> term = series_vocabulary.getTermByToken('warty')
    >>> term.value == ubuntu.getSeries('warty')
    True

Trying to get a non-existent release will result in a
NoSuchDistroSeries error.

    >>> series_vocabulary.getTermByToken('non-such-release')
    Traceback (most recent call last):
    ...
    NoSuchDistroSeries...


ProjectProductsVocabularyUsingMalone
....................................

All the products in a project using Malone.


    >>> mozilla_project = getUtility(IProjectGroupSet).getByName('mozilla')
    >>> for product in mozilla_project.products:
    ...     print "%s: %s" % (product.name, product.bug_tracking_usage.name)
    firefox: LAUNCHPAD
    thunderbird: UNKNOWN

    >>> mozilla_products_vocabulary = vocabulary_registry.get(
    ...     mozilla_project,'ProjectProductsUsingMalone')
    >>> for term in mozilla_products_vocabulary:
    ...     print "%s: %s" %(term.token, term.title)
    firefox: Mozilla Firefox


Non-Enumerable Vocabularies
---------------------------

Iterating over non-enumerable vocabularies, while possible, will
probably kill the database. Instead, these vocabularies are
search-driven.


BinaryAndSourcePackageNameVocabulary
....................................

The list of binary and source package names, ordered by name.

    >>> package_name_vocabulary = vocabulary_registry.get(
    ...     None, "BinaryAndSourcePackageName")
    >>> package_name_vocabulary.displayname
    'Select a Package'

When a package name matches both a binary package name and a source
package of the exact same name, the binary package name is
returned. This allows us, in bug reporting for example, to collect the
most specific information possible.

Let's demonstrate by searching for "mozilla-firefox", for which there is
both a source and binary package of that name.

    >>> package_name_terms = package_name_vocabulary.searchForTerms(
    ...     "mozilla-firefox")
    >>> package_name_terms.count()
    2
    >>> [(term.token, term.title) for term in package_name_terms]
    [('mozilla-firefox', u'mozilla-firefox'),
     ('mozilla-firefox-data', u'mozilla-firefox-data')]

Searching for "mozilla" should return the binary package name above, and
the source package named "mozilla".

    >>> package_name_terms = package_name_vocabulary.searchForTerms("mozilla")
    >>> package_name_terms.count()
    3
    >>> [(term.token, term.title) for term in package_name_terms]
    [('mozilla', u'mozilla'),
     ('mozilla-firefox', u'mozilla-firefox'),
     ('mozilla-firefox-data', u'mozilla-firefox-data')]

The search does a case-insensitive, substring match.

    >>> package_name_terms = package_name_vocabulary.searchForTerms("lInuX")
    >>> package_name_terms.count()
    2
    >>> [(term.token, term.title) for term in package_name_terms]
    [('linux-2.6.12', u'linux-2.6.12'),
     ('linux-source-2.6.15', u'linux-source-2.6.15')]


BinaryPackageNameVocabulary
...........................

All the binary packages in Launchpad.

    >>> bpn_vocabulary = vocabulary_registry.get(None, 'BinaryPackageName')
    >>> len(bpn_vocabulary)
    8

    >>> bpn_terms = bpn_vocabulary.searchForTerms("mozilla")
    >>> len(bpn_terms)
    2
    >>> [(term.token, term.title) for term in bpn_terms]
    [('mozilla-firefox', u'iceweasel huh ?'),
     ('mozilla-firefox-data', u'Mozilla Firefox Data is .....')]


SourcePackageNameVocabulary
...........................

All the source packages in Launchpad.

    >>> spn_vocabulary = vocabulary_registry.get(None, 'SourcePackageName')
    >>> len(spn_vocabulary)
    17

    >>> spn_terms = spn_vocabulary.searchForTerms("mozilla")
    >>> len(spn_terms)
    2
    >>> [(term.token, term.title) for term in spn_terms]
    [('mozilla', u'mozilla'), ('mozilla-firefox', u'mozilla-firefox')]

    >>> spn_terms = spn_vocabulary.searchForTerms("pmount")
    >>> len(spn_terms)
    1
    >>> [(term.token, term.title) for term in spn_terms]
    [('pmount', u'pmount')]


Processor
.........

All processors type available in Launchpad.

    >>> vocab = vocabulary_registry.get(None, "Processor")
    >>> vocab.displayname
    'Select a processor'

    >>> [term.token for term in vocab.searchForTerms('386')]
    ['386']


BugWatchVocabulary
..................

All bug watches associated with a bugtask's bug.

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bugtask = bug_one.bugtasks[0]
    >>> vocab = vocabulary_registry.get(bugtask, "BugWatch")
    >>> for term in vocab:
    ...     print term.title
    The Mozilla.org Bug Tracker <a...>#123543</a>
    The Mozilla.org Bug Tracker <a...>#2000</a>
    The Mozilla.org Bug Tracker <a...>#42</a>
    Debian Bug tracker <a...>#304014</a>

Bug watches with an email address URL (i.e. starts with "mailto:") are
treated differently.

    >>> from lp.bugs.interfaces.bugtracker import IBugTrackerSet
    >>> from lp.bugs.interfaces.bugwatch import IBugWatchSet

    >>> bug_twelve = getUtility(IBugSet).get(12)
    >>> email_bugtracker = getUtility(IBugTrackerSet).getByName('email')
    >>> email_bugwatch = getUtility(IBugWatchSet).createBugWatch(
    ...     bug_twelve, launchbag.user, email_bugtracker, '')
    >>> email_bugwatch.url
    u'mailto:bugs@example.com'

The title is rendered differently compared to other bug watches.

    >>> bugtask = bug_twelve.bugtasks[0]
    >>> vocab = vocabulary_registry.get(bugtask, "BugWatch")
    >>> for term in vocab:
    ...     print term.title
    Email bugtracker &lt;<a...>bugs@example.com</a>&gt;

Additionally, if the bug tracker's title contains the bug tracker's
URL, then the title is linkified instead.

    >>> email_bugtracker.title = (
    ...     'Lionel Richtea (%s)' % (
    ...         email_bugtracker.baseurl,))

    >>> for term in vocab:
    ...     print term.title
    Lionel Richtea (<a...>mailto:bugs@example.com</a>)

When there is no logged-in user, the title is much different. The
email address is hidden, and there is no hyperlink.

    >>> current_user = launchbag.user
    >>> login(ANONYMOUS)

    >>> for term in vocab:
    ...     print term.title
    Lionel Richtea (mailto:&lt;email address hidden&gt;)


PPA
...

The PPA vocabulary contains all the PPAs available in a particular
collection. It provides the IHugeVocabulary interface.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.webapp.vocabulary import IHugeVocabulary

    >>> vocabulary = get_naked_vocab(None, 'PPA')
    >>> verifyObject(IHugeVocabulary, vocabulary)
    True

    >>> print vocabulary.displayname
    Select a PPA

Iterations over the PPA vocabulary will return on PPA archives.

    >>> sorted([term.value.owner.name for term in vocabulary])
    [u'cprov', u'mark', u'no-priv']

PPA vocabulary terms contain:

 * token: the PPA owner name combined with the archive name (using '/');
 * value: the IArchive object;
 * title: the first line of the PPA description text.

    >>> cprov_term = vocabulary.getTermByToken('cprov/ppa')

    >>> print cprov_term.token
    cprov/ppa

    >>> print cprov_term.value
    <Archive ...>

    >>> print cprov_term.title
    packages to help my friends.

Not found terms result in LookupError.

    >>> vocabulary.getTermByToken('foobar')
    Traceback (most recent call last):
    ...
    LookupError: foobar

PPA vocabulary searches consider the owner FTI and the PPA FTI.

    >>> def print_search_results(results):
    ...     for archive in results:
    ...         term = vocabulary.toTerm(archive)
    ...         print '%s: %s' % (term.token, term.title)

    >>> cprov_search = vocabulary.search('cprov')
    >>> print_search_results(cprov_search)
    cprov/ppa: packages to help my friends.

    >>> celso_search = vocabulary.search('celso')
    >>> print_search_results(celso_search)
    cprov/ppa: packages to help my friends.

    >>> friends_search = vocabulary.search('friends')
    >>> print_search_results(friends_search)
    cprov/ppa: packages to help my friends.

We will create an additional PPA for Celso named 'testing'

    >>> from lp.soyuz.enums import ArchivePurpose
    >>> from lp.soyuz.interfaces.archive import IArchiveSet

    >>> login_person(current_user)
    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> cprov_testing = getUtility(IArchiveSet).new(
    ...     owner=cprov, name='testing', purpose=ArchivePurpose.PPA,
    ...     description='testing packages.')

Now, a search for 'cprov' will return 2 ppas and the result is ordered
by PPA name.

    >>> cprov_search = vocabulary.search('cprov')
    >>> print_search_results(cprov_search)
    cprov/ppa: packages to help my friends.
    cprov/testing: testing packages.

The vocabulary search also supports specific named PPA lookups
follwing the same combined syntax used to build unique tokens.

    >>> named_search = vocabulary.search('cprov/testing')
    >>> print_search_results(named_search)
    cprov/testing: testing packages.

As mentioned the PPA vocabulary term title only contains the first
line of the PPA description.

    >>> cprov.archive.description = "Single line."
    >>> flush_database_updates()

    >>> cprov_term = vocabulary.getTermByToken('cprov/ppa')
    >>> print cprov_term.title
    Single line.

    >>> cprov.archive.description = "First line\nSecond line."
    >>> flush_database_updates()

    >>> cprov_term = vocabulary.getTermByToken('cprov/ppa')
    >>> print cprov_term.title
    First line

PPAs with empty description are identified and have a title saying so.

    >>> cprov.archive.description = None
    >>> flush_database_updates()

    >>> cprov_term = vocabulary.getTermByToken('cprov/ppa')
    >>> print cprov_term.title
    No description available

Queries on empty strings also results in a valid SelectResults.

    >>> empty_search = vocabulary.search('')
    >>> empty_search.count() == 0
    True


# XXX Tom Berger 2007-07-05: document more vocabularies here, particularly
# when they break!
