= Merging =

For many reasons (i.e. a gina run) we could have duplicated accounts in
Launchpad. Once a duplicated account is identified, we need to allow the user
to merge two accounts into a single one, because both represent the same
person and they're there just because each of those was created using a
different email address.

    >>> from zope.component import getUtility
    >>> from canonical.database.sqlbase import sqlvalues, flush_database_updates
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from canonical.launchpad.ftests import login, ANONYMOUS

    >>> login(ANONYMOUS)
    >>> personset = getUtility(IPersonSet)
    >>> name16 = personset.getByName('name16')
    >>> sample = personset.getByName('name12')
    >>> admins = personset.getByName('admins')
    >>> marilize = personset.getByName('marilize')


== Sanity checks ==

We can't merge an account that still has email addresses attached to it

    >>> personset.merge(marilize, sample)
    Traceback (most recent call last):
    ...
    AssertionError: ...


== Preparing test person for the merge ==

Merging people involves updating the merged person relationships. Let's
put the person we will merge into some of those.

    # To assign marilize as the ubuntu team owner, we must log on as the
    # previous owner.
    >>> login('mark@hbd.com')

    >>> ubuntu_team = personset.getByName('ubuntu-team')
    >>> ubuntu_team.teamowner = marilize

    >>> ubuntu_translators = personset.getByName('ubuntu-translators')
    >>> ubuntu_translators.addMember(marilize, marilize)
    >>> rosetta_admins = personset.getByName('rosetta-admins')
    >>> rosetta_admins.addMember(marilize, marilize)

Karma gets reassigned to the person we merge into. Let's assign karma to
Marilize and save it for later comparison.

    >>> from canonical.launchpad.interfaces import IProductSet
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> marilize_karma = marilize.assignKarma('bugfixed', product=firefox)
    >>> saved_marilize_karma_id = marilize_karma.id
    >>> print marilize_karma.person.name
    marilize
    >>> sampleperson_old_karma = sample.karma

Branches whose owner is being merged are uniquified by appending '-N' where N
is a unique integer. We create "peoplemerge" and "peoplemerge-1" branches owned
by marilize, and a "peoplemerge" and "peoplemerge-1" branches owned by 'Sample
Person' to test that branch name uniquifying works.

Branches with smaller IDs will be processed first, so we create "peoplemerge"
first, and it will be renamed "peoplemerge-2". The extant "peoplemerge-1"
branch will be renamed "peoplemerge-1-1". The "peoplemerge-0" branch will not
be renamed since it will not conflict.

That is not a particularly sensible way of renaming branches, but it is simple
to implement, and it be should extremely rare for the case to occur.

    >>> from canonical.launchpad.interfaces import BranchType, IBranchSet
    >>> branchset = getUtility(IBranchSet)
    >>> peoplemerge = branchset.new(
    ...     BranchType.HOSTED, 'peoplemerge', sample, sample, None, None)
    >>> peoplemerge1 = branchset.new(
    ...     BranchType.HOSTED, 'peoplemerge-1', sample, sample, None, None)
    >>> peoplemerge0 = branchset.new(
    ...     BranchType.HOSTED, 'peoplemerge-0', marilize, marilize, None, None)
    >>> peoplemerge2 = branchset.new(
    ...     BranchType.HOSTED, 'peoplemerge', marilize, marilize, None, None)
    >>> peoplemerge11 = branchset.new(
    ...     BranchType.HOSTED, 'peoplemerge-1', marilize, marilize, None, None)

'Sample Person' is a deactivated member of the 'Ubuntu Translators' team,
while marilize is an active member. After the merge, 'Sample Person' will be an
active member of that team.

    >>> sample in ubuntu_translators.inactivemembers
    True
    >>> marilize in ubuntu_translators.activemembers
    True


== Do the merge! ==

    # Now we remove the only email address marilize had, so that we can merge
    # it.  First we need to change its status, though, because we can't delete
    # a person's preferred email.
    >>> from canonical.launchpad.interfaces.emailaddress import (
    ...     EmailAddressStatus)
    >>> email = marilize.preferredemail
    >>> email.status = EmailAddressStatus.VALIDATED
    >>> email.destroySelf()

    >>> personset.merge(marilize, sample)


== Merge results ==

Check that 'Sample Person' has indeed become an active member of 'Ubuntu
Translators'

    >>> sample in ubuntu_translators.activemembers
    True
    >>> sample.inTeam(ubuntu_translators)
    True

Check that the branches have been renamed properly.

    >>> sample.getBranch(None, 'peoplemerge') == peoplemerge
    True
    >>> sample.getBranch(None, 'peoplemerge-0') == peoplemerge0
    True
    >>> sample.getBranch(None, 'peoplemerge-1') == peoplemerge1
    True
    >>> sample.getBranch(None, 'peoplemerge-2') == peoplemerge2
    True
    >>> sample.getBranch(None, 'peoplemerge-1-1') == peoplemerge11
    True

The Karma that was previously assigned to marilize is now assigned to name12
(Sample Person).

    >>> from canonical.database.sqlbase import flush_database_caches
    >>> flush_database_caches()
    >>> saved_marilize_karma_id == marilize_karma.id
    True
    >>> print marilize_karma.person.name
    name12

Note that we don't bother migrating karma caches - it will just be reset next
time the caches are rebuilt.

    >>> sample.karma == sampleperson_old_karma
    True

A merged account gets a -merged suffix on its name.

    >>> from canonical.launchpad.database import Person
    >>> cur = Person._connection._connection.cursor()

    >>> cur.execute("SELECT id FROM Person WHERE name='marilize-merged'")
    >>> cur.fetchone()[0] == marilize.id
    True

    >>> cur.execute("select person, team, status from teammembership where "
    ...             "person = %s and team = %s"
    ...             % sqlvalues(sample.id, rosetta_admins.id))
    >>> cur.fetchone()
    [12, 30, 2]

    >>> sample.inTeam(rosetta_admins)
    True

    >>> cur.execute("select p1.name from person as p1, person as p2 where "
    ...             "p1.id = p2.teamowner and p2.name = 'ubuntu-team'")
    >>> cur.fetchone()[0]
    u'name12'

The account that has been merged is flagged. We can use this to eliminate
merged accounts from lists etc.

    >>> cur.execute("SELECT merged FROM Person WHERE name='marilize-merged'")
    >>> cur.fetchone()[0]
    12

    >>> cur.execute("SELECT merged FROM Person WHERE name='name12'")
    >>> cur.fetchone()[0] is None
    True


== Person decoration ==

Several tables "extend" the Person table by having additional information
that is UNIQUEly keyed to Person.id. We have a utility function that merges
information in those tables, we test it here.

We will use PersonLocation as an example. There are many permutations and
combinations, we will exercise them all, and in each case we'll create, and
then delete, the needed two people.

    >>> from canonical.launchpad.database import PersonSet
    >>> from canonical.launchpad.interfaces import PersonCreationRationale
    >>> personset = PersonSet()

    >>> skip = []
    >>> def decorator_refs(cur, winner, loser):
    ...    cur.execute(
    ...        "SELECT person, last_modified_by FROM PersonLocation "
    ...        "WHERE person IN (%(loser)d, %(winner)d)"
    ...        "      OR last_modified_by IN (%(loser)d, %(winner)d)"
    ...        "ORDER BY date_created" % {
    ...        'winner': winner.id, 'loser': loser.id})
    ...    result = ''
    ...    for line in cur.fetchall():
    ...        for item in line:
    ...            if item == winner.id: result += 'winner, '
    ...            elif item == loser.id: result += 'loser, '
    ...            else: result += str(item) + ', '
    ...        result += '\n'
    ...    return result.strip()
    >>> def new_players():
    ...  lead = 99
    ...  while True:
    ...     lead += 1
    ...     name = str(lead)
    ...     lp = PersonCreationRationale.OWNER_CREATED_LAUNCHPAD
    ...     winner = Person(name=name+'.winner', displayname='Merge Winner',
    ...                     creation_rationale=lp)
    ...     loser = Person(name=name+'.loser', displayname='Merge Loser',
    ...                     creation_rationale=lp)
    ...     yield winner, loser
    >>> endless_supply_of_players = new_players()

First, we will test a merge where there is no decoration.

    >>> winner, loser = endless_supply_of_players.next()
    >>> print decorator_refs(cur, winner, loser)
    <BLANKLINE>
    >>> personset._merge_person_decoration(winner, loser, skip, cur,
    ...     'PersonLocation', 'person', ['last_modified_by',])

"Skip" should have been updated with the table and unique reference column
name.

    >>> print skip
    [('personlocation', 'person')]

There should still be no columns that reference the winner or loser.

    >>> print decorator_refs(cur, winner, loser)
    <BLANKLINE>

OK, now, this time, we will add some decorator information to the winner but
not the loser.

    >>> winner, loser = endless_supply_of_players.next()
    >>> winner.timezone = 'America/Santiago'
    >>> print decorator_refs(cur, winner, loser)
    winner, winner,
    >>> personset._merge_person_decoration(winner, loser, skip, cur,
    ...     'PersonLocation', 'person', ['last_modified_by',])

There should now still be one decorator, with all columns pointing to the
winner:

    >>> print decorator_refs(cur, winner, loser)
    winner, winner,

This time, we will have a decorator for the person that is being merged INTO
another person, but nothing on the target person.

    >>> winner, loser = endless_supply_of_players.next()
    >>> loser.timezone = 'America/Santiago'
    >>> print decorator_refs(cur, winner, loser)
    loser, loser,
    >>> personset._merge_person_decoration(winner, loser, skip, cur,
    ...     'PersonLocation', 'person', ['last_modified_by',])

There should now still be one decorator, with all columns pointing to the
winner:

    >>> print decorator_refs(cur, winner, loser)
    winner, winner,

Now, we want to show what happens when there is a decorator for both the
to_person and the from_person. We expect that the from_person record will
remain as noise but non-unique columns will have been updated to point to
the winner, and the to_person will be unaffected.

    >>> winner, loser = endless_supply_of_players.next()
    >>> winner.timezone = 'America/Santiago'
    >>> loser.timezone = 'America/New_York'
    >>> print decorator_refs(cur, winner, loser)
    winner, winner,
    loser, loser,
    >>> personset._merge_person_decoration(winner, loser, skip, cur,
    ...     'PersonLocation', 'person', ['last_modified_by',])
    >>> print decorator_refs(cur, winner, loser)
    winner, winner,
    loser, winner,



== Merging teams ==

Merging of teams is also possible and uses the same API used for merging
people.  Note, though, that when merging teams, its polls will not be
carried over to the remaining team.  Team memberships, on the other hand,
are carried over just like when merging people.

    >>> from datetime import datetime, timedelta
    >>> import pytz
    >>> from canonical.launchpad.interfaces import IPollSubset, PollSecrecy
    >>> test_team = personset.newTeam(sample, 'test-team', 'Test team')
    >>> launchpad_devs = personset.getByName('launchpad')
    >>> launchpad_devs.addMember(
    ...     test_team, reviewer=launchpad_devs.teamowner, force_team_add=True)
    >>> today = datetime.now(pytz.timezone('UTC'))
    >>> tomorrow = today + timedelta(days=1)
    >>> poll = IPollSubset(test_team).new(
    ...     'test-poll', 'Title', 'Proposition', today, tomorrow,
    ...     PollSecrecy.OPEN, allowspoilt=True)

    # test_team has a superteam, one active member and a poll.
    >>> [team.name for team in test_team.super_teams]
    [u'launchpad']
    >>> test_team.teamowner.name
    u'name12'
    >>> [member.name for member in test_team.allmembers]
    [u'name12']
    >>> list(IPollSubset(test_team).getAll())
    [<Poll at ...]

    # Landscape-developers has no super teams, two members and no polls.
    >>> landscape = personset.getByName('landscape-developers')
    >>> [team.name for team in landscape.super_teams]
    []
    >>> landscape.teamowner.name
    u'name12'
    >>> [member.name for member in landscape.allmembers]
    [u'salgado', u'name12']
    >>> list(IPollSubset(landscape).getAll())
    []

Now we try to merge them, but since test_team has active members it can't be
merged.

    >>> personset.merge(test_team, landscape)
    Traceback (most recent call last):
    ...
    AssertionError: Only teams without active members can be merged

For cases like this we have an API which takes care of deactivating all
active members of the team so that we can perform the merge.

    # Only admins can use that API, though, so we need to login as an admin.
    >>> login('foo.bar@canonical.com')

    >>> comment = "We're merging this team into another one."
    >>> test_team.deactivateAllMembers(comment, personset.getByName('name16'))
    >>> flush_database_caches()
    >>> personset.merge(test_team, landscape)

    # The resulting Landscape-developers has now a super team, but has
    # no polls and its members are still the same two from before the
    # merge.
    >>> landscape.teamowner.name
    u'name12'
    >>> [member.name for member in landscape.allmembers]
    [u'salgado', u'name12']
    >>> [team.name for team in landscape.super_teams]
    [u'launchpad']
    >>> list(IPollSubset(landscape).getAll())
    []

A team can't be merged into another one if it has an associated mailing
list.  This is for the sole reason that it's very unlikely to happen and
we don't really want to write code to support things that will probably
never be needed.

    >>> from canonical.launchpad.interfaces import IMailingListSet
    >>> mailing_list = getUtility(IMailingListSet).new(landscape)
    >>> ubuntu_team = personset.getByName('ubuntu-team')
    >>> personset.merge(landscape, ubuntu_team)
    Traceback (most recent call last):
    ...
    AssertionError: Can't merge teams which have mailing lists...

