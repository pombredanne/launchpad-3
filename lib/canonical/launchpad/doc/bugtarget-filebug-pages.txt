= Filebug view classes =

The base class used for all the filebug pages is FileBugViewBase. It
contains enough functionality to file bug, the classes inheriting from
it only adds some more functionality, like adding fields, searching for
similar bug reports, etc.

    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest
    >>> from canonical.launchpad.browser import FileBugViewBase
    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> ubuntu_firefox = ubuntu.getSourcePackage('mozilla-firefox')
    >>> bug_data = dict(
    ...     title='Test Title', comment='Test description.')

The validate and action don't use the request when filing the bug, so we
can pass an empty request and pass the data dict to the methods
directly.

    >>> login('no-priv@canonical.com')
    >>> filebug_view = FileBugViewBase(ubuntu_firefox, LaunchpadTestRequest())
    >>> filebug_view.validate(bug_data) is None
    True
    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'
    >>> filebug_view.added_bug.description
    u'Test description.'

== Adding extra info to filed bugs ==

It's possible for bug reporting tools to upload a file with debug
information to Launchpad, and pass that information to the filebug page.
When the data is uploaded a token is returned, which is appended to the
+filebug URL, resulting in a URL like '/.../+filebug/12345abcde'. The
+filebug view's publishTraverse method looks up the correct data from
using the token.

The uploaded debug information should be MIME multipart message, where
the Content-Disposition header tells Launchpad what to do with the
different parts.

=== First inline part ==

The first inline part will be appended to the bug description.

    >>> debug_data = """MIME-Version: 1.0 
    ... Content-type: multipart/mixed; boundary=boundary
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ...
    ... This should be added to the description.
    ...
    ... --boundary--
    ... """

    >>> import transaction
    >>> from canonical.launchpad.interfaces import ITemporaryStorageManager
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)

We need to commit the transaction since the data will be stored in the
Librarian.

    >>> transaction.commit()

Now, if we pass the token to the filebug view, the extra_data
attribute will be set with the actual data.

    >>> request = LaunchpadTestRequest()
    >>> filebug_view = FileBugViewBase(ubuntu_firefox, request)
    >>> filebug_view.publishTraverse(request, token) is filebug_view
    True
    >>> filebug_view.extra_data.extra_description
    u'This should be added to the description.'

    >>> filebug_view.validate(bug_data) is None
    True
    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'
    >>> print filebug_view.added_bug.description #doctest: -NORMALIZE_WHITESPACE
    Test description.
    <BLANKLINE>
    This should be added to the description.

A notification was added to inform the user about what happened.

    >>> for notification in filebug_view.request.response.notifications:
    ...     print notification.message
    Thank you for your bug report.
    Additional information was added to the bug description.

=== Other inline parts ===

If there are more than one inline part, those will be added as comments
to the bug.

    >>> debug_data = """MIME-Version: 1.0 
    ... Content-type: multipart/mixed; boundary=boundary
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ...
    ... This should be added to the description.
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ...
    ... This should be added as a comment.
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ...
    ... This should be added as another comment.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> request = LaunchpadTestRequest()
    >>> filebug_view = FileBugViewBase(ubuntu_firefox, request)
    >>> filebug_view.publishTraverse(request, token) is filebug_view
    True
    >>> filebug_view.validate(bug_data) is None
    True
    >>> filebug_view.submit_bug_action.success(bug_data)

    >>> filebug_view.added_bug.title
    u'Test Title'
    >>> print filebug_view.added_bug.description #doctest: -NORMALIZE_WHITESPACE
    Test description.
    <BLANKLINE>
    This should be added to the description.

    >>> for comment in filebug_view.added_bug.messages[1:]:
    ...     print "Comment by %s: %s" % (
    ...         comment.owner.displayname, comment.text_contents)
    Comment by No Privileges Person: This should be added as a comment.
    Comment by No Privileges Person: This should be added as another comment.

Notifications were added to inform the user about what happened.

    >>> for notification in filebug_view.request.response.notifications:
    ...     print notification.message
    Thank you for your bug report.
    Additional information was added to the bug description.
    A comment with additional information was added to the bug report.
    A comment with additional information was added to the bug report.

=== Attachments ===

All the parts that have a 'Content-disposition: attachment' header
will get added as attachments to the bug. The attachment description can
be specified using a Content-description header, but it's not required.

    >>> debug_data = """MIME-Version: 1.0 
    ... Content-type: multipart/mixed; boundary=boundary
    ...
    ... --boundary
    ... Content-disposition: attachment; filename='attachment1'
    ... Content-type: text/plain; charset=utf-8
    ...
    ... This is an attachment.
    ...
    ... --boundary
    ... Content-disposition: attachment; filename='attachment2'
    ... Content-description: Attachment description.
    ... Content-type: text/plain; charset=ISO-8859-1
    ...
    ... This is another attachment, with a description.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> request = LaunchpadTestRequest()
    >>> filebug_view = FileBugViewBase(ubuntu_firefox, request)
    >>> filebug_view.publishTraverse(request, token) is filebug_view
    True
    >>> filebug_view.validate(bug_data) is None
    True
    >>> filebug_view.submit_bug_action.success(bug_data)

Since the attachments are stored in the Librarian, we need to commit the
transaction in order to access them.

    >>> transaction.commit()

    >>> filebug_view.added_bug.title
    u'Test Title'
    >>> print filebug_view.added_bug.description
    Test description.

The attachments got added, with the charsets preserved, and the one that
didn't specify a description got an autogenerated one.

    >>> for attachment in filebug_view.added_bug.attachments:
    ...     print "Filename: %s" % attachment.libraryfile.filename
    ...     print "Content type: %s" % attachment.libraryfile.mimetype
    ...     print "Description: %s" % attachment.title
    ...     print "Contents:\n%s" % attachment.libraryfile.read()
    ...     print
    Filename: attachment1
    Content type: text/plain; charset=utf-8
    Description: attachment1
    Contents:
    This is an attachment.
    <BLANKLINE>
    Filename: attachment2
    Content type: text/plain; charset=ISO-8859-1
    Description: Attachment description.
    Contents:
    This is another attachment, with a description.
    <BLANKLINE>

Notifications were added to inform the user about what happened.

    >>> for notification in filebug_view.request.response.notifications:
    ...     print notification.message
    Thank you for your bug report.
    The file "attachment1" was attached to the bug report.
    The file "attachment2" was attached to the bug report.

The attachments are all added to the same comment.

    >>> for comment in filebug_view.added_bug.messages[1:]:
    ...     print "Comment by %s: %s attachment(s)" % (
    ...         comment.owner.displayname, comment.bugattachments.count())
    Comment by No Privileges Person: 2 attachment(s)

== publishTraverse() ==

As already seen above, it's the FileBugViewBase's publishTraverse that
finds the right blob to use.

    >>> request = LaunchpadTestRequest()
    >>> filebug_view = FileBugViewBase(ubuntu_firefox, request)
    >>> filebug_view.publishTraverse(request, token) is filebug_view
    True
    >>> filebug_view.extra_data_token == token
    True
    >>> filebug_view.extra_data is not None
    True

Since the view itself is returned, it will handle further traversals as
well, so if we call the method again, it represents a URL like
'.../+filebug/token/foo', which should raise a NotFound error.

    >>> filebug_view.publishTraverse(request, token)
    Traceback (most recent call last):
    ...
    NotFound:...

=== Not found tokens ===

If publishTraverse is called with a token that can't be found, a
NotFound error is raised.

    >>> request = LaunchpadTestRequest()
    >>> filebug_view = FileBugViewBase(ubuntu_firefox, request)
    >>> filebug_view.publishTraverse(request, 'no-such-token')
    Traceback (most recent call last):
    ...
    NotFound:...

== Adding tags to filed bugs ==

    >>> bug_data = dict(
    ...     title=u'Test Title', comment=u'Test description.',
    ...     tags=[u'foo', u'bar'])

The validate and action don't use the request when filing the bug, so we
can pass an empty request and pass the data dict to the methods
directly.

    >>> login('no-priv@canonical.com')
    >>> filebug_view = FileBugViewBase(ubuntu_firefox, LaunchpadTestRequest())
    >>> filebug_view.validate(bug_data) is None
    True
    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'
    >>> filebug_view.added_bug.description
    u'Test description.'
    >>> for tag in filebug_view.added_bug.tags:
    ...     print tag
    bar
    foo
