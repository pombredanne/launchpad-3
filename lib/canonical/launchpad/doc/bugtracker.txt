= Monitoring External Bug Trackers in Malone =

Malone allows you to monitor bugs in external bug tracking systems. This
document discusses the API of external bug trackers. To learn more about
bug watches, the object that represents the link between a Malone bug
and an external bug, see bugwatch.txt.

    >>> import pytz
    >>> from datetime import datetime, timedelta
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.interfaces import IBugTrackerSet
    >>> bugtracker_set = getUtility(IBugTrackerSet)
    >>> mozilla_bugzilla = bugtracker_set.getByName('mozilla.org')
    >>> now = datetime.now(pytz.timezone('UTC'))

We can get a list of all the bug tracker's bug watches needing to be
updated.  The current criteria for needing a update is that it hasn't
been updated in the last 23 hours.

    >>> bug_watches = mozilla_bugzilla.watches
    >>> print bug_watches.count()
    4

    >>> print bug_watches[0].remotebug, bug_watches[0].bug.id
    2000 1
    >>> bug_watches[0].lastchecked = None

    >>> print bug_watches[1].remotebug, bug_watches[1].bug.id
    123543 1
    >>> bug_watches[1].lastchecked = now - timedelta(hours=12)

Note that bugtracker.watches may produce multiple watches for the same
remote bug.

    >>> print bug_watches[2].remotebug, bug_watches[2].bug.id
    42 1
    >>> bug_watches[2].lastchecked = now - timedelta(hours=36)

    >>> print bug_watches[3].remotebug, bug_watches[3].bug.id
    42 2
    >>> bug_watches[3].lastchecked = now - timedelta(days=1)

The watches needing updating should the ones with old statuses, 2000 and 42:

    >>> flush_database_updates()
    >>> for bug_watch in mozilla_bugzilla.getBugWatchesNeedingUpdate(23):
    ...     print bug_watch.remotebug, bug_watch.bug.id
    2000 1
    42 2
    42 1


== Auto-creating bug trackers ==

The bugtracker module contains a method, make_bugtracker_name() which
can be used to generate a bug tracker name when a bugtracker is
automatically created. make_bugtracker_name() accepts a single
parameter, uri, which is used as the basis for the auto-generated name.

Passing in a URI will produce a name based on the host name part of
that URL.

    >>> from canonical.launchpad.database.bugtracker import (
    ...     make_bugtracker_name)
    >>> make_bugtracker_name('http://bugs.example.com/shrubbery')
    'auto-bugs.example.com'

Passing in a mailto: URI will produce a name based on the local part
of the email address.

    >>> make_bugtracker_name('mailto:foo.bar@canonical.com')
    'auto-foo.bar'

Similarly, there is also make_bugtracker_title(), which does something
similar, but for the title.

    >>> from canonical.launchpad.database.bugtracker import (
    ...     make_bugtracker_title)
    >>> make_bugtracker_title('http://bugs.example.com/shrubbery')
    'bugs.example.com/shrubbery'

For email addresses, it uses the first part of the domain too.

    >>> make_bugtracker_title('mailto:foo.bar@canonical.com')
    'Email to foo.bar@canonical'

The IBugTrackerSet interface provides a method, ensureBugTracker(),
which will retrieve or create a bug tracker for the parameters passed to
it. If this method is not passed a name parameter when it creates a new
bugtracker it will use make_bugtracker_name() to generate a name for the
bug tracker.

    >>> from canonical.launchpad.interfaces import (
    ...     BugTrackerType, IPersonSet)
    >>> sample_person = getUtility(IPersonSet).getByEmail(
    ...     'test@canonical.com')
    >>> a_bugtracker = bugtracker_set.ensureBugTracker(
    ...     baseurl='http://bugs.example.com', owner=sample_person,
    ...     bugtrackertype=BugTrackerType.BUGZILLA,
    ...     title=None, summary=None, contactdetails=None, name=None)
    >>> a_bugtracker.name
    u'auto-bugs.example.com'

ensureBugTracker() also performs collision-avoidance on the names which
it generates using make_bugtracker_name(). If another bug tracker is
created with the same hostname as a_bugtracker above but different URLs,
the new bugtracker's name will be mutated so that the two names do not
collide.

    >>> a_bugtracker = bugtracker_set.ensureBugTracker(
    ...     baseurl='http://bugs.example.com/ni', owner=sample_person,
    ...     bugtrackertype=BugTrackerType.BUGZILLA,
    ...     title=None, summary=None, contactdetails=None, name=None)
    >>> a_bugtracker.name
    u'auto-bugs.example.com-1'


== Top Bug Trackers ==

The Malone front page shows a list of the top Malone bug trackers, as
ordered by the number of bugs being monitored by Malone in each of
them. Use IBugTrackerSet.getMostActiveBugTrackers to get this list.

    >>> top_trackers = bugtracker_set.getMostActiveBugTrackers(limit=4)
    >>> sorted([(tracker.watches.count(), tracker.name)
    ...         for tracker in top_trackers])
    [(1, u'ubuntu-bugzilla'), (2, u'gnome-bugzilla'),
     (4, u'mozilla.org'), (5, u'debbugs')]


== Getting Bug Trackers ==

You can get a specific bug tracker from the database by querying by its
base URL.

    >>> mozilla_bugzilla = bugtracker_set.queryByBaseURL(
    ...     u'https://bugzilla.mozilla.org/')
    >>> mozilla_bugzilla.baseurl
    u'https://bugzilla.mozilla.org/'

It's necessary to specify the exact URL, differences in the schema
(http vs. https) and trailing slashes are accepted.

    >>> mozilla_bugzilla = bugtracker_set.queryByBaseURL(
    ...     u'http://bugzilla.mozilla.org')
    >>> mozilla_bugzilla.baseurl
    u'https://bugzilla.mozilla.org/'

If the exact bugtracker isn't found but a the url searched for
is a substring of an existing bugtracker, we use the first match.

    >>> mozilla_bugzilla = bugtracker_set.queryByBaseURL(
    ...     u'zilla.mozilla.org')
    >>> mozilla_bugzilla.baseurl
    u'https://bugzilla.mozilla.org/'

If no bug tracker can be found None is returned.

    >>> bugtracker_set.queryByBaseURL('http://no/such/bugtracker') is None
    True


=== Aliases ===

A bug tracker can have a number of alias URLs associated with it.

    >>> from canonical.launchpad.interfaces import IBugTrackerAliasSet
    >>> bugtrackeralias_set = getUtility(IBugTrackerAliasSet)

The most natural way to work with aliases is via the aliases attribute
present on IBugTracker. This can be used to query, set or remove
aliases.

    >>> mozilla_bugzilla.aliases = [
    ...     'https://norwich.example.com/',
    ...     'http://cambridge.example.com/']

    >>> mozilla_bugzilla.aliases
    (u'http://cambridge.example.com/',
     u'https://norwich.example.com/')

    >>> mozilla_bugzilla.aliases = []
    >>> mozilla_bugzilla.aliases
    ()

You can assign any iterable (of URL strings) to the aliases attribute,
but, when accessed, aliases is always a regular tuple.

Because this attribute is computed on each access, an immutable object
- a tuple - is returned. This defends against mutations of aliases
where the expectation is that the aliases in the database are changed,
but silently are not. For example, if a plain list were returned, it
might be tempting to append() another alias to it. But this would not
be reflected in the database.

You can also assign None to aliases to remove all aliases. This has
the same effect as assigning an empty list.

    >>> mozilla_bugzilla.aliases = None
    >>> mozilla_bugzilla.aliases
    ()

    >>> mozilla_bugzilla.aliases = set(['http://set.example.com/'])
    >>> mozilla_bugzilla.aliases
    (u'http://set.example.com/',)

    >>> mozilla_bugzilla.aliases = (u'http://tuple.example.com/',)
    >>> mozilla_bugzilla.aliases
    (u'http://tuple.example.com/',)

Your ordering is not preserved; aliases are sorted using Python's
standard unicode ordering.

    >>> mozilla_bugzilla.aliases = (
    ...     'http://%s.example.com/' % domain
    ...     for domain in '111 zzz ccc ZZZ'.split())
    >>> mozilla_bugzilla.aliases
    (u'http://111.example.com/',
     u'http://ZZZ.example.com/',
     u'http://ccc.example.com/',
     u'http://zzz.example.com/')

BugTrackerAliases can also be looked up by bug tracker.

    >>> mozilla_bugzilla.aliases = [
    ...     'http://just.example.com/',
    ...     'http://magic.example.com/']

Query by bug tracker:

    >>> sorted(alias.base_url for alias in
    ...        bugtrackeralias_set.queryByBugTracker(mozilla_bugzilla))
    [u'http://just.example.com/',
     u'http://magic.example.com/']

The aliases attribute never contains the current baseurl. For example,
if BugTracker.baseurl is changed to an existing alias of itself, the
aliases attribute hides the baseurl, although it is still recorded as
an alias.

    >>> mozilla_bugzilla.baseurl = 'http://magic.example.com/'
    >>> mozilla_bugzilla.aliases
    (u'http://just.example.com/',)

    >>> sorted(alias.base_url for alias in
    ...        bugtrackeralias_set.queryByBugTracker(mozilla_bugzilla))
    [u'http://just.example.com/',
     u'http://magic.example.com/']

    >>> mozilla_bugzilla.baseurl = 'https://bugzilla.mozilla.org/'


== Pillars for bugtrackers ===

    >>> trackers = list(bugtracker_set)
    >>> pillars = bugtracker_set.getPillarsForBugtrackers(trackers)
    >>> for t in pillars:
    ...     print t.name, [p.name for p in pillars[t]]
    gnome-bugzilla [u'gnome']


== Imported bug messages ==

Each BugTracker has an imported_bug_messages property that returns all
bug messages which have been imported for a given bug tracker.

    >>> def print_bug_messages(bug_messages):
    ...     for bug_message in bug_messages:
    ...         print '* bug: %d' % bug_message.bug.id
    ...         print '- remote bug: %s' % bug_message.bugwatch.remotebug
    ...         print '- message subject: %s' % bug_message.message.subject

The Mozilla Bugzilla has no imported bug messages:

    >>> print_bug_messages(mozilla_bugzilla.imported_bug_messages)

We will forge some BugMessage records before trying again:

    >>> from canonical.launchpad.interfaces import IBugMessageSet
    >>> from zope.security.proxy import removeSecurityProxy

    >>> for num, bug_watch in enumerate(mozilla_bugzilla.watches):
    ...     bug_message = getUtility(IBugMessageSet).createMessage(
    ...         'You are Number %d.' % (num + 1),
    ...         bug_watch.bug, sample_person)
    ...     removeSecurityProxy(bug_message).bugwatch = bug_watch
    >>> flush_database_updates()

    >>> print_bug_messages(mozilla_bugzilla.imported_bug_messages)
    * bug: 1
    - remote bug: 2000
    - message subject: You are Number 1.
    * bug: 1
    - remote bug: 123543
    - message subject: You are Number 2.
    * bug: 1
    - remote bug: 42
    - message subject: You are Number 3.
    * bug: 2
    - remote bug: 42
    - message subject: You are Number 4.
