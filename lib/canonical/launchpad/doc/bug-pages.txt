= Bug Filing Pages =

== Filing a Bug ==

There are three objects on which you can file a bug. An
SQLObjectCreatedEvent is published when the bug is filed. Let's register
an event listener to demonstrate this.

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> import transaction

    >>> from canonical.launchpad.ftests.event import TestEventListener
    >>> from canonical.launchpad.event.interfaces import ISQLObjectCreatedEvent
    >>> from canonical.launchpad.interfaces import IBug
    >>> def on_created_event(object, event):
    ...     print "SQLObjectCreatedEvent: %r" % object
    >>> on_created_listener = TestEventListener(
    ...     IBug, ISQLObjectCreatedEvent, on_created_event)

1. Filing a bug on a distribution.

The distribution filebug page will attach a bugtask to a sourcepackage
if the user provides a valid package name when reporting the bug.

If the package name entered by the user happens to be a binary package
name, that information is recorded in the description, and the first
comment, of the bug report.

    >>> from zope.component import getView, getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IBugTaskSet, IBugSet, IDistributionSet, BugTaskSearchParams,
    ...     IProductSet, IPersonSet, ILaunchBag, IOpenLaunchBag)
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

    >>> launchbag = getUtility(IOpenLaunchBag)
    >>> login("foo.bar@canonical.com")

    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")
    >>> request = LaunchpadTestRequest(
    ...     method="POST",
    ...     form={'field.title': 'bug in bin pkg',
    ...           'field.comment': 'a bug in a bin pkg',
    ...           'packagename_option': 'choose',
    ...           'field.packagename': 'linux-2.6.12',
    ...           'field.actions.submit_bug': 'Submit Bug Report'})

    >>> ubuntu_filebug = getView(ubuntu, "+filebug", request)
    >>> launchbag.clear()
    >>> launchbag.add(ubuntu)

    >>> ubuntu_filebug.initialize()
    SQLObjectCreatedEvent: <Bug at ...>

    >>> launchbag.clear()

    >>> current_user = getUtility(ILaunchBag).user
    >>> search_params = BugTaskSearchParams(
    ...     searchtext="bin pkg", user=current_user)

    >>> latest_ubuntu_bugtask = ubuntu.searchTasks(search_params)[0]

The user specified a binary package name, so that's been added to the
bug description and the first comment:

    >>> print latest_ubuntu_bugtask.bug.description
    Binary package hint: linux-2.6.12
    <BLANKLINE>
    <BLANKLINE>
    a bug in a bin pkg

the source package from which the binary was built has been set on
the bugtask.

    >>> print latest_ubuntu_bugtask.sourcepackagename.name
    linux-source-2.6.15

2. Filing a bug on a product.

    >>> firefox = getUtility(IProductSet).getByName("firefox")
    >>> request = LaunchpadTestRequest(
    ...     method="POST",
    ...     form={'field.title': 'a firefox bug',
    ...           'field.comment': 'a test bug',
    ...           'field.actions.submit_bug': 'Submit Bug Report'})

    >>> firefox_filebug = getView(firefox, "+filebug", request)

    >>> firefox_filebug.initialize()
    SQLObjectCreatedEvent: <Bug at ...>

3. Filing a bug on a distribution source package.

You can also access the +filebug page from a sourcepackage.

    >>> ubuntu_firefox = ubuntu.getSourcePackage("mozilla-firefox")

    >>> request = LaunchpadTestRequest(
    ...     method="POST",
    ...     form={'field.title': 'a firefox bug',
    ...           'field.comment': 'a test bug',
    ...           'packagename_option': 'choose',
    ...           'field.packagename': 'mozilla-firefox',
    ...           'field.actions.submit_bug': 'Submit Bug Report'})

    >>> ubuntu_firefox_filebug = getView(
    ...     ubuntu_firefox, "+filebug", request)

    >>> launchbag.add(ubuntu)

    >>> ubuntu_firefox_filebug.initialize()
    SQLObjectCreatedEvent: <Bug at ...>

    >>> launchbag.clear()

== Adding Comments ==

Let's flush all changes so far to ensure we're looking at a consistent view of
the database.

    >>> flush_database_updates()
    >>> transaction.commit()

To add new comments, users POST to the +addcomment page:

    >>> request = LaunchpadTestRequest(
    ...     method="POST",
    ...     form={'field.subject': latest_ubuntu_bugtask.bug.title,
    ...           'field.comment': 'I can reproduce this bug.',
    ...           'field.actions.save': 'Save Changes'})
    >>> ubuntu_addcomment = getView(latest_ubuntu_bugtask, "+addcomment-form", request)
    >>> ubuntu_addcomment.initialize()

They may even, by mistake, post the same comment twice:

    >>> request = LaunchpadTestRequest(
    ...     method="POST",
    ...     form={'field.subject': latest_ubuntu_bugtask.bug.title,
    ...           'field.comment': 'I can reproduce this bug.',
    ...           'field.actions.save': 'Save Changes'})
    >>> ubuntu_addcomment = getView(latest_ubuntu_bugtask, "+addcomment-form", request)
    >>> ubuntu_addcomment.initialize()

Comments are cached in the view, so we need to flush updates and then
grab a new view to actually see them:

    >>> flush_database_updates()
    >>> transaction.commit()

    >>> ubuntu_bugview = getView(latest_ubuntu_bugtask, "+index", request)
    >>> print len(ubuntu_bugview.comments)
    3
    >>> [(c.index, c.owner.name, c.text_contents) for c in ubuntu_bugview.comments]
    [(0, u'name16', u'Binary package hint: linux-2.6.12\n\na bug in a bin pkg'),
     (1, u'name16', u'I can reproduce this bug.'),
     (2, u'name16', u'I can reproduce this bug.')]

== Description and Comment Display ==

When a user posts a new bug, the first comment and the description are
identical. Take as an example the first bug posted above:

    >>> print latest_ubuntu_bugtask.bug.description
    Binary package hint: linux-2.6.12
    <BLANKLINE>
    <BLANKLINE>
    a bug in a bin pkg

Its description has the same contents as the bug's first comment:

    >>> print latest_ubuntu_bugtask.bug.messages[0].text_contents
    Binary package hint: linux-2.6.12
    <BLANKLINE>
    <BLANKLINE>
    a bug in a bin pkg

The view class offers a method to check exactly that:

    >>> ubuntu_bugview.wasDescriptionModified()
    False

If we go ahead and modify the description, however:

    >>> latest_ubuntu_bugtask.bug.description = "A bug in the linux kernel"
    >>> flush_database_updates()
    >>> transaction.commit()

    >>> ubuntu_bugview.wasDescriptionModified()
    True

The displayable comments for a bug are returned doing:

    >>> viewable_comments = ubuntu_bugview.getBugCommentsForDisplay()

Because we omit the first comment, and because the third comment is
indentical to the second, we really only display one comment:

    >>> print len(viewable_comments)
    1
    >>> [(c.index, c.owner.name, c.text_contents) for c in viewable_comments]
    [(1, u'name16', u'I can reproduce this bug.')]

(Unregister our listener, since we no longer need it.)

    >>> on_created_listener.unregister()


= Bug Portlets =

== Duplicates Portlet ==

The duplicate bugs portlet lists duplicates of the current bug. If the
duplicate bug affects the current context, the link to the dupe will
remain in the current context. If the dupe has not been reported in
the current context, the dupe link will be to the generic
/bugs/$bug.id redirect link.

    >>> bugtaskset = getUtility(IBugTaskSet)
    >>> bugset = getUtility(IBugSet)

Bug 6 is a duplicate of bug 5, and since both bugs affect Firefox, the
duplicate link remains in the current context.

    >>> bug_five_in_firefox = bugtaskset.get(14)

    >>> print bug_five_in_firefox.bug.id
    5
    >>> print bug_five_in_firefox.product.name
    firefox


    >>> bug_page_view = getView(
    ...     bug_five_in_firefox.bug, "+portlet-duplicates", request)

    >>> bug_six = bugset.get(6)

    >>> getUtility(IOpenLaunchBag).add(bug_five_in_firefox)

    >>> print bug_page_view.getDupeBugLink(bug_six)
    http://.../firefox/+bug/6

Bug 2 is not reported in Firefox. Let's mark bug 2 as a dupe of bug 5,
and see how the returned link changes.

    >>> bug_two = bugset.get(2)
    >>> bug_two.duplicateof = 5

    >>> bug_page_view = getView(
    ...     bug_five_in_firefox.bug, "+portlet-duplicates", request)

    >>> print bug_page_view.getDupeBugLink(bug_two)
    http://.../bugs/2

== Bug Navigation ==

The +subscribe link has different text depending on if the user is
subscribed to the bug, or if a team the user of a member of is
subscribed to it.

If the user isn't subscribed to the bug and neither of his teams are
subscribed to it, 'Subscribe' is shown.

    >>> login("foo.bar@canonical.com")
    >>> foo_bar = getUtility(IPersonSet).getByEmail('foo.bar@canonical.com')
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bug_one.isSubscribed(foo_bar)
    False
    >>> for team in foo_bar.teams_participated_in:
    ...     if bug_one.isSubscribed(team):
    ...         print "%s is subsribed to the bug" % team.displayname
    ...         break
    ... else:
    ...     print "No teams are subscribed to the bug."
    No teams are subscribed to the bug.

    >>> from canonical.launchpad.browser import BugContextMenu
    >>> bug_one_bugtask = bug_one.bugtasks[0]
    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(bug_one_bugtask)
    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Subscribe'

    >>> bug_menu.subscription().icon
    'add'

If we subscribe Foo Bar, 'Unsubscribe' is shown.

    >>> bug_one.subscribe(foo_bar, foo_bar)
    <BugSubscription at ...>
    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Unsubscribe'

    >>> bug_menu.subscription().icon
    'remove'

If we subscribe one of the teams that Foo Bar is a member of, it will
still say 'Unsubscribe':

    >>> launchpad_team = getUtility(IPersonSet).getByName('launchpad')
    >>> foo_bar.inTeam(launchpad_team)
    True
    >>> bug_one.subscribe(launchpad_team, launchpad_team)
    <BugSubscription at ...>
    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Unsubscribe'

    >>> bug_menu.subscription().icon
    'remove'

However, if we now unsubscribe Foo Bar, it will say
'Subscribe/Unsubscribe' since he will have the option of either
subscribing himself or unsubscribing the Launchpad team.

    >>> bug_one.unsubscribe(foo_bar)

    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Subscribe/Unsubscribe'

    >>> bug_menu.subscription().icon
    'edit'

He will have the possibility to unsubscribe only the team that he's a
member of, so if we unsubscribe the Launchpad team and subscribe some
other team, it will say only 'Subscribe'.

    >>> shipit_team = getUtility(IPersonSet).getByName('shipit-admins')
    >>> foo_bar.inTeam(shipit_team)
    False
    >>> bug_one.unsubscribe(launchpad_team)
    >>> bug_one.subscribe(shipit_team, shipit_team)
    <BugSubscription at ...>

    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Subscribe'

    >>> bug_menu.subscription().icon
    'add'

If the user is logged out, it also says 'Subscribe/Unsubscribe', since
we can't know if the user is subscribed or not.

    >>> login(ANONYMOUS)
    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Subscribe/Unsubscribe'

    >>> bug_menu.subscription().icon
    'edit'

    Subscribers from duplicates have the option to unsubscribe as well. For
    example, Steve Alexander can currently subscribe to bug #3.

    >>> bug_three = bugset.get(3)
    >>> bug_three_bugtask = bug_three.bugtasks[0]
    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(bug_three_bugtask)

    >>> login("steve.alexander@ubuntulinux.com")

    >>> bug_menu = BugContextMenu(bug_three_bugtask)
    >>> bug_menu.subscription().text
        'Subscribe'

    Bug if bug #2, a bug that Steve is directly subscribed to, is marked as
    a dupe of bug #3, then Steve gets indirectly subscribed to bug #3, and
    is presented with the Unsubscribe link.

    >>> from canonical.launchpad.ftests import syncUpdate

    >>> bug_two.duplicateof = bug_three
    >>> syncUpdate(bug_two)

    >>> bug_menu.subscription().text
        'Unsubscribe'

    Now, let's revert that duplicate marking and demonstrate it again, this
    time where the subscription from the duplicate is of a /team/ of which
    the current user is a member. So, for Foo Bar, bug #3 has a simple
    Subscribe link initially.

    >>> bug_two.duplicateof = None
    >>> syncUpdate(bug_two)

    >>> login("foo.bar@canonical.com")

    >>> bug_menu.subscription().text
        'Subscribe'

    Now let's subscribe Ubuntu Team directly to bug #2. When bug #2 is duped
    against bug #3, the link changes to Subscribe/Unsubscribe, because Foo
    Bar can subscribe himself, or unsubscribe the Ubuntu Team, which got
    indirectly subscribed to bug #3 from the dupe, bug #2.

    >>> ubuntu_team = getUtility(IPersonSet).getByName("ubuntu-team")
    >>> bug_two.subscribe(ubuntu_team, ubuntu_team)
        <BugSubscription...>

    >>> bug_two.duplicateof = bug_three
    >>> syncUpdate(bug_two)

    >>> bug_menu.subscription().text
        'Subscribe/Unsubscribe'


== BugTasks and Nominations Table ==

A table is rendered at the top of the bug page which shows both bugtasks
and nominations. This table is rendered with the
+bugtasks-and-nomination-table view.

    >>> request = LaunchpadTestRequest()

    >>> bugtasks_and_nominations_view = getView(
    ...     bug_one_bugtask.bug, "+bugtasks-and-nominations-table", request)

The getBugTasksAndNominations method returns a list of bugtasks and
nominations to render in the table, sorted by bugtargetdisplayname. Approved
nominations are not included in the returned results, because an
approved nomination will have created a task anyway.

    >>> from canonical.launchpad.interfaces import IBugTask, IBugNomination

    >>> def get_object_type(task_or_nomination):
    ...     if IBugTask.providedBy(task_or_nomination):
    ...         return "bugtask"
    ...     elif IBugNomination.providedBy(task_or_nomination):
    ...         return "nomination"
    ...     else:
    ...         return "unknown"

    >>> def print_tasks_and_nominations(tasks_and_nominations):
    ...     for task_or_nomination_dict in tasks_and_nominations:
    ...         task_or_nomination = task_or_nomination_dict['row_context']
    ...         print "%s, %s, %s" % (
    ...             get_object_type(task_or_nomination),
    ...             task_or_nomination.status.title,
    ...             task_or_nomination.target.bugtargetdisplayname)

    >>> tasks_and_nominations = (
    ...     bugtasks_and_nominations_view.getBugTasksAndNominations())

    >>> print_tasks_and_nominations(tasks_and_nominations)
    bugtask, New, Mozilla Firefox
    nomination, Nominated, Mozilla Firefox 1.0
    bugtask, Confirmed, mozilla-firefox (Debian)
    bugtask, New, mozilla-firefox (Ubuntu)
    nomination, Nominated, Ubuntu Hoary

Let's nominate the bug for upstream and an Ubuntu series and see how
the list changes.

(Login as an unprivileged user to be able to nominate.)

    >>> login("no-priv@canonical.com")

    >>> current_user = getUtility(ILaunchBag).user
    >>> ubuntu_warty = ubuntu.getSeries("warty")
    >>> firefox_trunk = firefox.getSeries("trunk")

    >>> bug_one.addNomination(current_user, target=ubuntu_warty)
    <BugNomination ...>
    >>> bug_one.addNomination(current_user, target=firefox_trunk)
    <BugNomination ...>

    >>> tasks_and_nominations = (
    ...     bugtasks_and_nominations_view.getBugTasksAndNominations())

    >>> print_tasks_and_nominations(tasks_and_nominations)
    bugtask, New, Mozilla Firefox
    nomination, Nominated, Mozilla Firefox 1.0
    nomination, Nominated, Mozilla Firefox trunk
    bugtask, Confirmed, mozilla-firefox (Debian)
    bugtask, New, mozilla-firefox (Ubuntu)
    nomination, Nominated, Ubuntu Hoary
    nomination, Nominated, Ubuntu Warty

Let's add another affected package in Ubuntu to the bug.

    >>> evolution = ubuntu.getSourcePackage("evolution")

    >>> current_user = getUtility(ILaunchBag).user

    >>> bugtaskset.createTask(
    ...     owner=current_user, bug=bug_one,
    ...     distribution=evolution.distribution,
    ...     sourcepackagename=evolution.sourcepackagename)
    <BugTask ...>

A nomination row will be included for evolution now too.

    >>> tasks_and_nominations = (
    ...     bugtasks_and_nominations_view.getBugTasksAndNominations())

    >>> print_tasks_and_nominations(tasks_and_nominations)
    bugtask, New, Mozilla Firefox
    nomination, Nominated, Mozilla Firefox 1.0
    nomination, Nominated, Mozilla Firefox trunk
    bugtask, New, evolution (Ubuntu)
    nomination, Nominated, Ubuntu Hoary
    nomination, Nominated, Ubuntu Warty
    bugtask, Confirmed, mozilla-firefox (Debian)
    bugtask, New, mozilla-firefox (Ubuntu)
    nomination, Nominated, Ubuntu Hoary
    nomination, Nominated, Ubuntu Warty

When a nomination is approved, it turns into a task; the nomination is
no longer shown. Declined nominations continue to be shown.

(First, login as an admin, to ensure we have the privileges to
approve/decline nominations.)

    >>> login("foo.bar@canonical.com")
    >>> current_user = getUtility(ILaunchBag).user

    >>> ubuntu_hoary = ubuntu.getSeries("hoary")
    >>> hoary_nomination = bug_one.getNominationFor(ubuntu_hoary)
    >>> warty_nomination = bug_one.getNominationFor(ubuntu_warty)

    >>> hoary_nomination.approve(current_user)
    >>> warty_nomination.decline(current_user)

    >>> tasks_and_nominations = (
    ...     bugtasks_and_nominations_view.getBugTasksAndNominations())

    >>> print_tasks_and_nominations(tasks_and_nominations)
    bugtask, New, Mozilla Firefox
    nomination, Nominated, Mozilla Firefox 1.0
    nomination, Nominated, Mozilla Firefox trunk
    bugtask, New, evolution (Ubuntu)
    nomination, Declined, Ubuntu Warty
    bugtask, New, evolution (Ubuntu Hoary)
    bugtask, Confirmed, mozilla-firefox (Debian)
    bugtask, New, mozilla-firefox (Ubuntu)
    nomination, Declined, Ubuntu Warty
    bugtask, New, mozilla-firefox (Ubuntu Hoary)

Bug Edit Page
=============

The bug edit page is used to edit the summary, description, nick name,
and bug tags. If the user try to add a tag that hasn't been used in the
current context, we display a confirmation button, which shouldn't be
automatically rendered by the form template. In order to show how it
works, let's override the edit page, making it a bit shorter, and
initialize the test harness.

    >>> from canonical.launchpad.browser import BugEditView
    >>> class BugEditViewTest(BugEditView):
    ...     def index(self):
    ...         print 'EDIT BUG'

    >>> firefox_task = bug_one.bugtasks[0]
    >>> firefox_task.bugtargetdisplayname
    u'Mozilla Firefox'
    >>> from canonical.launchpad.ftests import LaunchpadFormHarness
    >>> bug_edit = LaunchpadFormHarness(firefox_task, BugEditViewTest)

Initially, the normal edit page is shown, with a single button.

    >>> bug_edit.view.render()
    EDIT BUG
    >>> [action.label for action in bug_edit.view.actions]
    ['Change']

If we fill in some values and submit the action, the view will redirect
and the bug will have been edited.

    >>> login('test@canonical.com')
    >>> edit_values = {
    ...     'field.title': u'New title',
    ...     'field.description': u'New description.',
    ...     'field.name': u'new-nickname',
    ...     'field.tags': u'doc'}

    >>> bug_edit.submit('change', edit_values)
    >>> bug_edit.hasErrors()
    False
    >>> bug_edit.wasRedirected()
    True

    >>> bug_one.title
    u'New title'
    >>> bug_one.description
    u'New description.'
    >>> bug_one.name
    u'new-nickname'
    >>> bug_one.tags
    [u'doc']


Emails are sent out by adding entries to the bugnotification table. We
need to know how many messages are currently in that table.

    >>> from canonical.launchpad.database import BugNotification, Bug
    >>> bn_set = BugNotification.select(BugNotification.q.bugID == bug_one.id)
    >>> start_bugnotification_count = bn_set.count()

Re-adding the same tag that already exists shouldn't notify anyone.

    >>> edit_values['field.tags'] = u'doc doc'
    >>> bug_edit.submit('change', edit_values)
    >>> bug_edit.hasErrors()
    False
    >>> for message in bug_edit.view.notifications:
    ...     print message

    >>> bug_edit.wasRedirected()
    True
    >>> bn_set = BugNotification.select(BugNotification.q.bugID == bug_one.id)
    >>> bn_set.count() == start_bugnotification_count
    True

The tag 'doc' has already been used for other Firefox bugs, let's try
adding a tag that hasn't already been used. Add 'new-tag' multiple times
so that we can verify that it will only be added once.

    >>> edit_values['field.tags'] = u'new-tag doc new-tag'
    >>> bug_edit.submit('change', edit_values)

Now the form will have a notification, asking us to confirm that we indeed
want to use a new tag. The notification includes a button, with which
the user can confirm that he wants to add the tag.

    >>> bug_edit.hasErrors()
    False
    >>> for message in bug_edit.view.notifications:
    ...     print message
    The tag "new-tag" hasn't yet been used by Mozilla Firefox before.
    Is this a new tag?...<input ...Yes, define new tag...>

    >>> bug_edit.wasRedirected()
    False

The form still contains the 'Change' button, though, so that the user
can edit the tag and submit the form again.

    >>> bug_edit.view.render()
    EDIT BUG
    >>> [action.label for action in bug_edit.view.actions]
    ['Change']

If we click on the 'Yes, define new tag' button, we'll get redirected to
the bug page, and the bug will have the new tag.

    >>> bug_edit.submit('confirm_tag', edit_values)
    >>> bug_edit.hasErrors()
    False
    >>> bug_edit.wasRedirected()
    True

    >>> bug_one.tags
    [u'doc', u'new-tag']

Since the 'new-tag' was added, a new entry in the bugnotification table
should exist.

    >>> bn_set = BugNotification.select(BugNotification.q.bugID == bug_one.id,
    ...                                 orderBy = BugNotification.q.id)
    >>> start_bugnotification_count == bn_set.count() - 1
    True
    >>> bn_set[-1].message.text_contents
    u'** Tags added: new-tag'


= Visibility of Imported DebBugs Comments =

Comments imported from the DebBugs bug tracker are not displayed in the
user interface by default.

A config option, malone.show_imported_comments, controls whether or not
imported comments will be displayed. We can demonstrate these using the
standard BugTaskView for bug 15, which has a debian bug watch and
imported comments.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.browser import BugTaskView
    >>> from canonical.launchpad.interfaces import IBugSet
    >>> from canonical.launchpad.webapp.servers import (
    ...     LaunchpadTestRequest)
    >>> bug = getUtility(IBugSet).get(15)
    >>> view = BugTaskView(bug.bugtasks[0], LaunchpadTestRequest())

By default, the comments returned which have been imported from a bug
watch will have a can_be_shown property of False.

    >>> for comment in view.getBugCommentsForDisplay():
    ...     comment.can_be_shown
    False
    False
    False
    False
    False
    False

However, if we set the show_imported_comments config option to True, the
imported comments for bug 4 will be displayable.

    >>> from canonical.config import config
    >>> config.malone.show_imported_comments = True
    >>> view = BugTaskView(bug.bugtasks[0], LaunchpadTestRequest())
    >>> for comment in view.getBugCommentsForDisplay():
    ...     comment.can_be_shown
    True
    True
    True
    True
    True
    True

