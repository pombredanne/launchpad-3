Text Searching
==============

Introduction
------------
We are currently using tsearch2 to provide full text searching
capabilities inside the PostgreSQL database. 

Although in a lot of cases simple substring searches using LIKE would be
fine or even preferred, the disadvantage of using LIKE is that PostgreSQL
cannot use any indexes to do the substring search. This does not scale
when we need to search tens of thousands of entries (packages) or hundreds
of thousands of entries (people) or millions of entries (translations).

Installation
------------
tsearch2 is part of the `postgresql-contrib` package. This is installed
into the launchpad database using the script `database/schema/fti.py`,
which is run automatically during database creation.

This script does the following:

    * Hooks `tsearch2` into the launchpad database, installing it into
      the ts2 schema.

    * Creates all the full text indexes. These are in the form of a new
      column called `fti` on a number of tables. Which tables and
      which columns are indexed is defined inside the fti.py script.

    * Creates the `ftq(text)` stored procedure. This procedure makes
      queries against the indexes simpler and consistant throughout
      our applications.

It is the Database Administrator's responsibility to rerun `fti.py` as
part of the production rollouts if this script has been modified. It does
not need to be rerun if the script has not changed. Rebuilding the indexes
currently takes several minutes on production, during which time the
production database is unavailable.

Querying
--------

The examples use the following helper function to execute SQL commands
against the database and display the results:

    >>> from canonical.database.sqlbase import cursor
    >>> def runsql(query, *args):
    ...     '''Run an SQL query and return the results as text'''
    ...     colsize = 25
    ...     cur = cursor() # Get a cursor
    ...     if args:
    ...         cur.execute(query, args)
    ...     else:
    ...         cur.execute(query)
    ...     for row in cur.fetchall():
    ...         line = ''
    ...         for col in row:
    ...             if isinstance(col, (float,int,long)):
    ...                 col = '%1.2f' % col
    ...             col = col.encode('ascii', 'replace')
    ...             if len(col) > colsize:
    ...                 line += '%s... ' % col[:colsize-3]
    ...             else:
    ...                 fmt = '%%-%ds ' % colsize
    ...                 line += fmt % col
    ...         line = line.rstrip()
    ...         print line


All queries against the full text indexes use the following basic syntax:

    >>> runsql("SELECT displayname FROM Person WHERE fti @@ ftq('Mark')")
    Mark Shuttleworth

Queries are all case insensitive:

    >>> runsql("""SELECT displayname FROM Person WHERE fti @@ ftq('cArlos')
    ...               ORDER BY displayname""")
    Carlos Perell? Mar?n
    Carlos Valdivia Yag?e

If a query contains multiple words, an AND query is performed:

    >>> runsql("""SELECT displayname FROM Person
    ...               WHERE fti @@ ftq('Carlos Valdivia')""")
    Carlos Valdivia Yag?e

This can also be explicity performed by joining the words with 'and':

    >>> runsql("""
    ...     SELECT displayname FROM Person
    ...         WHERE fti @@ ftq('carlos AND valdivia') ORDER BY displayname
    ...     """)
    Carlos Valdivia Yag?e

We also support 'OR' as a boolean operation:

    >>> runsql("""
    ...     SELECT displayname FROM Person
    ...         WHERE fti @@ ftq('valdivia OR mark') ORDER BY displayname
    ...     """)
    Carlos Valdivia Yag?e
    Mark Shuttleworth

NULL searches will return nothing:

    >>> runsql("""
    ...     SELECT displayname FROM Person
    ...         WHERE fti @@ ftq(NULL) ORDER BY displayname
    ...     """)


ftq(text) & _ftq(text)
----------------------

To help debug the `ftq(text)` helper, a similar function exists sharing
the same code that returns a string rather than the compiled version. This
allows us to check the 'query munging' algorithms we are using and debug
any syntax error exceptions being generated.

The following examples show the text version of the query using
`_ftq(text)`, and the compiled version returned by `ftq(text)`

    >>> from canonical.database.sqlbase import SQLBase
    >>> def ftq(query):
    ...     query = query.encode('UTF-8')
    ...     cur = cursor()
    ...     try:
    ...         cur.execute("SELECT _ftq(%s), ftq(%s)", (query, query))
    ...         uncompiled, compiled = cur.fetchone()
    ...     except:
    ...         SQLBase._connection._connection.rollback()
    ...         raise
    ...     if uncompiled is not None:
    ...         uncompiled = uncompiled.encode('US-ASCII', 'backslashreplace')
    ...         uncompiled = uncompiled.replace(' ','')
    ...     if compiled is not None:
    ...         compiled = compiled.decode('UTF-8')
    ...         compiled = compiled.encode('US-ASCII', 'backslashreplace')
    ...     print '%s <=> %s' % (uncompiled, compiled)


Queries are lowercased

    >>> ftq('Hello')
    hello <=> 'hello'


Boolean operations are allowed

    >>> ftq('hi AND mom')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('hi & mom')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('hi OR mom')
    hi|mom <=> 'hi' | 'mom'

    >>> ftq('hi | mom')
    hi|mom <=> 'hi' | 'mom'

    >>> ftq('hi & -dad')
    hi&!dad <=> 'hi' & !'dad'



Brackets are allowed to specify precidence

    >>> ftq('(HI OR HELLO) & mom')
    (hi|hello)&mom <=> ( 'hi' | 'hello' ) & 'mom'

    >>> ftq('Hi(Mom)')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('(Hi)Mom')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('Hi(Big)Momma')
    hi&big&momma <=> 'hi' & 'big' & 'momma'

    >>> ftq('foo(bar OR baz)') # Bug #32071
    foo&(bar|baz) <=> 'foo' & ( 'bar' | 'baz' )

    >>> ftq('foo (bar OR baz)')
    foo&(bar|baz) <=> 'foo' & ( 'bar' | 'baz' )


We also support negation

    >>> ftq('!Hi')
    !hi <=> !'hi'

    >>> ftq('-(Hi & Mom)')
    !(hi&mom) <=> !( 'hi' & 'mom' )

    >>> ftq('Foo & ! Bar')
    foo&!bar <=> 'foo' & !'bar'


The implicit boolean operation is AND

    >>> ftq('Hi Mom')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('Hi -mom')
    hi&!mom <=> 'hi' & !'mom'

    >>> ftq('hi (mom OR mum)')
    hi&(mom|mum) <=> 'hi' & ( 'mom' | 'mum' )
    
    >>> ftq('(hi OR hello) mom')
    (hi|hello)&mom <=> ( 'hi' | 'hello' ) & 'mom'

    >>> ftq('(hi OR hello) -mom')
    (hi|hello)&!mom <=> ( 'hi' | 'hello' ) & !'mom'

    >>> ftq('(hi ho OR hoe) work go')
    (hi&ho|hoe)&work&go <=> ( 'hi' & 'ho' | 'hoe' ) & 'work' & 'go'


Hypenation is handled specially. Note that the & operator has precidence
over the | operator and that tsearch2 removes the unnecessary branckets.

    >>> ftq('foo-bar')
    ((foo&bar)|foobar) <=> 'foo' & 'bar' | 'foobar'

    >>> ftq('foo-bar-baz')
    ((foo&bar&baz)|foobarbaz) <=> 'foo' & 'bar' & 'baz' | 'foobarbaz'

    >>> ftq('foo & bar-baz')
    foo&((bar&baz)|barbaz) <=> 'foo' & ( 'bar' & 'baz' | 'barbaz' )

    >>> ftq('-foo bar-')
    !foo&bar <=> !'foo' & 'bar'

    >>> ftq('---foo--- ---bar---')
    foo&bar <=> 'foo' & 'bar'


Most punctuation characters are converted to whitespace outside of
words, or treated as a hypen inside words. The exceptions are the
operators ()!&|!.

    >>> ftq(':100%')
    100 <=> '100'

    >>> ftq(r'foo\bar')
    ((foo&bar)|foobar) <=> 'foo' & 'bar' | 'foobar'

    >>> ftq('/dev/pmu')
    ((dev&pmu)|devpmu) <=> 'dev' & 'pmu' | 'devpmu'

    >>> ftq('cool!')
    cool <=> 'cool'

    >>> ftq('foo@bar.com')
    ((foo&bar&com)|foobarcom) <=> 'foo' & 'bar' & 'com' | 'foobarcom'    


Some punctuation we pass through to tsearch2 for it to handle.

    >>> ftq("shouldn't") # NB. This gets stemmed, see below
    shouldn't <=> 'shouldn'

It was noticed though in Bug #33920 that tsearch2 couldn't cope if the
apostrophe was not inside a word. So we strip it in these cases.

    >>> ftq("'cool")
    cool <=> 'cool'
    >>> ftq("'shouldn't")
    shouldn't <=> 'shouldn'
    >>> ftq("' cool")
    cool <=> 'cool'
    >>> ftq("cool '")
    cool <=> 'cool'
    >>> ftq("' cool '")
    cool <=> 'cool'
    >>> ftq("'cool'")
    cool <=> 'cool'
    >>> ftq("('cool' AND bananas)")
    (cool&bananas) <=> 'cool' & 'banana'

It was also noticed through Bug #39828 that tsearch2 will not cope if the
! character is embedded inside or found at the end of a word.

    >>> ftq('cool!')
    cool <=> 'cool'
    >>> ftq('hi!mom')
    hi&mom <=> 'hi' & 'mom'
    >>> ftq('hi!!!!!mom')
    hi&mom <=> 'hi' & 'mom'
    >>> ftq('hi !mom')
    hi&!mom <=> 'hi' & !'mom'


Bug #44913 - Unicode characters in the wrong place

    >>> ftq(u'a-a\N{LATIN SMALL LETTER C WITH CEDILLA}')
    ((a&a\xe7)|aa\xe7) <=> 'a\xe7' | 'aa\xe7'

    Cut & Paste of 'Smart' quotes

    >>> ftq(u'a-a\N{RIGHT DOUBLE QUOTATION MARK}')
    ((a&a)|aa) <=> 'aa'

    >>> ftq(u'\N{LEFT SINGLE QUOTATION MARK}a.a\N{RIGHT SINGLE QUOTATION MARK}')
    ((a&a)|aa) <=> 'aa'


Bug #44913 - Nothing but stopwords in a query needing repair

    >>> ftq('a)a')
    (a)&a <=> None


Stop words (words deemed too common in English to search on) are removed
from queries by tsearch2. 

    >>> ftq("Don't do it harder!")
    don't&do&it&harder <=> 'harder'


Note that some queries will return None after compilation, because they
contained nothing but stop words or punctuation.

    >>> ftq("don't do it!")
    don't&do&it <=> None

    >>> ftq(",,,")
    None <=> None


Queries containing nothing except whitespace, boolean operators and
punctuation will just return None.

    >>> ftq(" ")
    None <=> None
    >>> ftq("AND")
    None <=> None
    >>> ftq(" AND (!)")
    None <=> None
    >>> ftq("-")
    None <=> None


Words are also stemmed by tsearch2 (using the English stemmer).

    >>> ftq("administrators")
    administrators <=> 'administr'

    >>> ftq("administrate")
    administrate <=> 'administr'



Dud queries are 'repaired', such as doubled operators, trailing operators
or invalid leading operators

    >>> ftq('hi & OR mom')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('(hi OR OR hello) AND mom')
    (hi|hello)&mom <=> ( 'hi' | 'hello' ) & 'mom'

    >>> ftq('(hi OR AND hello) AND mom')
    (hi|hello)&mom <=> ( 'hi' | 'hello' ) & 'mom'

    >>> ftq('(hi OR -AND hello) AND mom')
    (hi|!hello)&mom <=> ( 'hi' | !'hello' ) & 'mom'

    >>> ftq('(hi OR - AND hello) AND mom')
    (hi|hello)&mom <=> ( 'hi' | 'hello' ) & 'mom'

    >>> ftq('hi AND mom AND')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('& hi & mom')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('(& hi | hello) AND mom')
    (hi|hello)&mom <=> ( 'hi' | 'hello' ) & 'mom'

    >>> ftq('() hi mom ( ) ((! |((&)))) :-)')
    (hi&mom) <=> 'hi' & 'mom'

    >>> ftq("(hi mom")
    (hi&mom) <=> 'hi' & 'mom'

    >>> ftq("(((hi mom")
    (((hi&mom))) <=> 'hi' & 'mom'

    >>> ftq("hi mom)")
    (hi&mom) <=> 'hi' & 'mom'

    >>> ftq("hi mom)))")
    (((hi&mom))) <=> 'hi' & 'mom'

    >>> ftq("hi (mom")
    hi&(mom) <=> 'hi' & 'mom'

    >>> ftq("hi) mom")
    (hi)&mom <=> 'hi' & 'mom'

    >>> ftq("(foo .") # Bug 43245
    (foo) <=> 'foo'

    >>> ftq("(foo.")
    (foo) <=> 'foo'


Phrase Searching
----------------
We do not support searching for quoted phrases. This is technically
possible, but not trivial. The database side of implementing this would
simply be to make `ftq(text)` convert "a b" to (a&b). However, we then
need to filter the returned results and that filter needs to be aware of
what rows are being indexed.


Ranking
-------

We have ranking information stored in the indexes, as specified in fti.py.
The rank of a result is calculated using the tsearch2 rank() function.

    >>> runsql(r"""
    ...     SELECT
    ...         name, rank(fti, ftq('gnome')) AS rank
    ...     FROM product
    ...     WHERE fti @@ ftq('gnome')
    ...     ORDER BY rank DESC, name
    ...     """)
    gnome-terminal            0.80
    applets                   0.69
    gnomebaker                0.28
    python-gnome2-dev         0.14
    evolution                 0.12
    ubuntu                    0.06


You can also build complex multi table queries and mush all the
ranked results together. This query does a full text search on
the Bug and Message tables, as well as substring name searches on
SourcepackageName.name and Product.name. The rank() function returns an
float between 0 and 1, so I just chose some arbitrary constants for name
matches that seemed appropriate. It is also doing a full text search
against the Product table, and manually lowering the rank (again using
an arbitrary constant that seemed appropriate).

    >>> runsql(r"""
    ...   SELECT title, max(ranking) FROM (
    ...    SELECT Bug.title,rank(Bug.fti||Message.fti,ftq('firefox')) AS ranking
    ...    FROM Bug, BugMessage, Message
    ...    WHERE Bug.id = BugMessage.bug AND Message.id = BugMessage.message
    ...       AND (Bug.fti @@ ftq('firefox') OR Message.fti @@ ftq('firefox'))
    ...    UNION
    ...    SELECT Bug.title, 0.70 AS ranking
    ...    FROM Bug, BugTask, SourcepackageName
    ...    WHERE Bug.id = BugTask.bug
    ...       AND BugTask.sourcepackagename = SourcepackageName.id
    ...       AND SourcepackageName.name LIKE lower('%firefox%')
    ...    UNION
    ...    SELECT Bug.title, 0.72 AS ranking
    ...    FROM Bug, BugTask, Product
    ...    WHERE Bug.id = BugTask.bug
    ...       AND BugTask.product = Product.id
    ...       AND Product.name LIKE lower('%firefox%')
    ...    UNION
    ...    SELECT Bug.title, rank(Product.fti, ftq('firefox')) - 0.3 AS ranking
    ...    FROM Bug, BugTask, Product
    ...    WHERE Bug.id = BugTask.bug
    ...       AND BugTask.product = Product.id
    ...       AND Product.fti @@ ftq('firefox')
    ...    ) AS BugMatches
    ...   GROUP BY title
    ...   HAVING max(ranking) > 0.2
    ...   ORDER BY max(ranking) DESC, title
    ...   """)
    Firefox crashes when S... 0.72
    Firefox does not suppo... 0.72
    Firefox install instru... 0.72
    Reflow problems with c... 0.72
    Blackhole Trash folder    0.70
    Bug Title Test            0.70
    Printing doesn't work     0.70

