The Queue Builder
=================

QueueBuilder is a script to sanely initialise new build jobs, it
verifies the available DistroArchSeriess, for which we are able to
build packages, repairs broken Builds entries that makes sense,
verifies the packages pending to build, install the jobs in
BuildQueue table and scores the build acording a bunch of
parameters.

Setting up
----------

  >>> import tempfile, os, operator
  >>> from canonical.buildmaster.master import (BuilddMaster,
  ...   determineArchitecturesToBuild)

import the bunch of required database classes:

  >>> from canonical.database.sqlbase import flush_database_updates
  >>> from canonical.launchpad.database import (
  ...      SourcePackageRelease, SourcePackageName, DistroSeries,
  ...      SourcePackagePublishingHistory,
  ...      SecureSourcePackagePublishingHistory,
  ...      PocketChroot, DistroArchSeries, Build, BuildQueue,
  ...      SourcePackageReleaseFile)

  >>> from canonical.lp.dbschema import (
  ...      PackagePublishingPocket, PackagePublishingStatus,
  ...      SourcePackageFileType)

  >>> from canonical.database.constants import UTC_NOW

The Master side of Buildd requires access to Launchpad Database, the
user designed for this kind of access is 'fiera', as in all test the
transaction should be retrieved.

  >>> import transaction

The master also requires an 'logging' instance to not compromise the
standard output with noisely output.

  >>> import logging
  >>> logger = logging.getLogger()
  >>> logger.setLevel(logging.DEBUG)

Now we have satisfied all needs for BuildMaster, let's instantiate it.

  >>> bm = BuilddMaster(logger, transaction)

Emulates a PocketChroot entry to validate the distroarchrelese
Ubuntu/Hoary/i386/RELEASE and Debian/Woody/i386/RELEASE:

  >>> hoary = DistroSeries.selectOneBy(name='hoary')
  >>> hoary_dar = DistroArchSeries.selectOneBy(distroseries=hoary,
  ...                                           architecturetag='i386')
  >>> hoary_dar2 = DistroArchSeries.selectOneBy(distroseries=hoary,
  ...                                            architecturetag='hppa')

  >>> woody = DistroSeries.selectOneBy(name='woody')
  >>> woody_dar = DistroArchSeries.selectOneBy(distroseries=woody,
  ...                                           architecturetag='i386')

Pick up any existent librarian file as chroot.

  >>> pocket = PocketChroot(distroarchseries=hoary_dar, chroot=1)
  >>> pocket = PocketChroot(distroarchseries=hoary_dar2, chroot=2)
  >>> pocket = PocketChroot(distroarchseries=woody_dar, chroot=3)

Produce a set of available DistroArchSeries, for which the
build jobs will be created.

  >>> distroserieses = set()
  >>> for dar in DistroArchSeries.select():
  ...     distroserieses.add(dar.distroseries)
  ...     bm.addDistroArchSeries(dar)
  >>> distroserieses = sorted(distroserieses, key=operator.attrgetter('name'))

Only Ubuntu/Hoary/i386 and Debian/Woody/i386 have an available CHROOT.

  >>> sorted((arch.distroseries.name, arch.architecturetag)
  ...        for arch in bm._archserieses.keys())
  [(u'hoary', u'hppa'), (u'hoary', u'i386'), (u'woody', u'i386')]

Ensure sampledata is processed
------------------------------

Kick off any pending builds we have to avoid any lint in our tests (there are a
couple that will be created based on our sampledata). This is to allow
us to study carefully what is being added as we add new series and builds.

  >>> for dr in distroserieses:
  ...      bm.createMissingBuilds(dr)

  >>> flush_database_updates()

Add the missing build queue entres, but don't run
sanitiseAndScoreCandidates to avoid destroying build queue items that
won't ever build (and therefore allow us to meaninfully compare the
BuildQueue entries that are added for our test).

  >>> bm.addMissingBuildQueueEntries()

Store current status of the database:

  >>> old_builds = set(Build.select())
  >>> old_jobs = set(BuildQueue.select())

Create some series and publications
-----------------------------------

Define a helper function to create series and publications for those
series.

We need to publish the source in order to get it visible to the
createMissingBuilds() method. Additionally if the target is an already
released distroseries it can only be visible if published in in
special pocket (UPDATES, SECURITY or BACKPORTS)

  >>> count = 1
  >>> def createPackageAndPublication(name, series, architecturehintlist,
  ...     archive=None):
  ...     """Create a SourcePackageRelease, ReleaseFile and publication.
  ...
  ...     Return a tuple with (SourcePackageRelease, publication)
  ...     """
  ...     global count
  ...     tar = SourcePackageFileType.TARBALL
  ...     published = PackagePublishingStatus.PUBLISHED
  ...     release_pocket = PackagePublishingPocket.UPDATES
  ...     if archive is None:
  ...        archive = series.main_archive
  ...     srcpkgrel = SourcePackageRelease(
  ...         creator=1,
  ...         version=str(666+count),
  ...         section=1,
  ...         maintainer=1,
  ...         component=1,
  ...         uploaddistroseries=1,
  ...         sourcepackagename=name,
  ...         architecturehintlist=architecturehintlist,
  ...         builddependsindep='foo (<< 1.0)',
  ...         builddepends=None,
  ...         dsc=None,
  ...         copyright='placeholder ...',
  ...         changelog=None,
  ...         dscsigningkey=None,
  ...         dsc_format="1.0",
  ...         dsc_maintainer_rfc822="mark <mark@mark.com>",
  ...         dsc_standards_version="3.6.9",
  ...         dsc_binaries="%s" % name.name,
  ...         upload_archive=archive)
  ...     srcfile = SourcePackageReleaseFile(
  ...         sourcepackagerelease=srcpkgrel,
  ...         libraryfile=1,
  ...         filetype=tar)
  ...     p = SecureSourcePackagePublishingHistory(
  ...         sourcepackagerelease=srcpkgrel,
  ...         distroseries=series,
  ...         status=published,
  ...         pocket=release_pocket,
  ...         component=srcpkgrel.component,
  ...         section=srcpkgrel.section,
  ...         datecreated=UTC_NOW,
  ...         archive=archive)
  ...     count += 1
  ...     return srcpkgrel, p

Adding a few dummy sourcepackagereleases and publish it in Ubuntu/Hoary.

  >>> name1 = SourcePackageName(name="test-buildd")
  >>> spr_all, pub_all = createPackageAndPublication(name1, hoary, "all")
  >>> name2 = SourcePackageName(name="test-buildd-2")
  >>> spr_any, pub_any = createPackageAndPublication(name2, hoary, "any")
  >>> name3 = SourcePackageName(name="test-buildd-3")
  >>> spr_three, pub_three = createPackageAndPublication(
  ...                           name3, hoary, "i386 hppa amd64")
  >>> name4 = SourcePackageName(name="test-buildd-4")
  >>> spr_one, pub_one = createPackageAndPublication(name4, hoary, "hppa")
  >>> name5 = SourcePackageName(name="test-buildd-5")
  >>> spr_woody, pub_woody = createPackageAndPublication(name5, woody, "hppa")

Check the architectures
-----------------------

See if the code which determines archs to build does the right thing for
each of these options:

  >>> legal_archs = set(hoary.architectures)
  >>> [a.architecturetag for a in
  ...       determineArchitecturesToBuild(pub_all, legal_archs, hoary)]
  [u'i386']
  >>> [a.architecturetag for a in
  ...       determineArchitecturesToBuild(pub_any, legal_archs, hoary)]
  [u'hppa', u'i386']
  >>> [a.architecturetag for a in
  ...       determineArchitecturesToBuild(pub_three, legal_archs, hoary)]
  [u'hppa', u'i386']
  >>> [a.architecturetag for a in
  ...       determineArchitecturesToBuild(pub_one, legal_archs, hoary)]
  [u'hppa']

Check any-foo and linux-foo notation in architecture hint list
--------------------------------------------------------------

See bug 73761.

  >>> name6 = SourcePackageName(name="test-buildd-6")
  >>> spr_any_foo, pub_any_foo = createPackageAndPublication(
  ...     name6, hoary, "any-hppa")
  >>> name7 = SourcePackageName(name="test-buildd-7")
  >>> spr_linux_foo, pub_linux_foo = createPackageAndPublication(
  ...     name7, hoary, "linux-i386")

  >>> [a.architecturetag for a in
  ...       determineArchitecturesToBuild(pub_any_foo, legal_archs, hoary)]
  [u'hppa']
  >>> [a.architecturetag for a in
  ...       determineArchitecturesToBuild(pub_linux_foo, legal_archs, hoary)]
  [u'i386']


Check architectures against source PAS
--------------------------------------

  >>> from canonical.buildmaster.pas import BuildDaemonPackagesArchSpecific

Write a harness that lets us easily test PAS statements:

  >>> def getPASVerifier(pas_string, dar=hoary):
  ...   """Build and return a PAS verifier based on the string provided."""
  ...   temp_dir = tempfile.mkdtemp()
  ...   pas_filename = os.path.join(temp_dir, "Packages-arch-specific")
  ...   pas = file(pas_filename, "w")
  ...   pas.write(pas_string)
  ...   pas.close()
  ...   pas_verify = BuildDaemonPackagesArchSpecific(temp_dir, dar)
  ...   os.unlink(pas_filename)
  ...   return pas_verify

First check a positive source listing:

  >>> pas_verify = getPASVerifier("%test-buildd-3: i386")
  >>> [a.architecturetag for a in
  ...       determineArchitecturesToBuild(pub_three, legal_archs, hoary,
  ...                                     pas_verify)]
  [u'i386']

And now a negative source listing:

  >>> pas_verify = getPASVerifier("%test-buildd-3: !i386")
  >>> [a.architecturetag for a in
  ...       determineArchitecturesToBuild(pub_three, legal_archs, hoary,
  ...                                     pas_verify)]
  [u'hppa']

And a source listing which causes us to produce no builds:

  >>> pas_verify = getPASVerifier("%test-buildd-3: sparc")
  >>> [a.architecturetag for a in
  ...       determineArchitecturesToBuild(pub_three, legal_archs, hoary,
  ...                                     pas_verify)]
  []

Binary PAS
----------

To check binary PAS listings we'll use a publication for
mozilla-firefox, which already has its data set up.

  >>> warty = DistroSeries.selectOneBy(name="warty")
  >>> firefox_pub = SecureSourcePackagePublishingHistory.get(18)
  >>> legal_archs = set(warty.architectures)
  >>> pas_verify = getPASVerifier("mozilla-firefox: i386 sparc", dar=warty)
  >>> [a.architecturetag for a in
  ...       determineArchitecturesToBuild(firefox_pub, legal_archs, warty,
  ...                                     pas_verify)]
  [u'i386']

And a binary PAS listing that tries to exclude i386 and hppa from an
arch-any build. The exclusion of i386 is ignored; see comment in
pas.py:_handleBinaryPAS for more information on why.

  >>> pas_verify = getPASVerifier("mozilla-firefox: !i386 !hppa", dar=warty)
  >>> [a.architecturetag for a in
  ...       determineArchitecturesToBuild(firefox_pub, legal_archs, warty,
  ...                                     pas_verify)]
  [u'i386']


Create and verify the new builds
--------------------------------

Create missing builds (packages w/o build entry) for those distroserieses.
We expect to have a couple of new builds for the sane Hoary and a warning about
the absence of nominatedarchindep field for Woody:

  >>> for dr in distroserieses:
  ...      bm.createMissingBuilds(dr)

  >>> flush_database_updates()

Check that we only created new Build entries for the new hoary releases:

  >>> new_builds = set(Build.select()) - old_builds
  >>> for build in sorted(new_builds, key=operator.attrgetter('id')):
  ...   print build.title
  i386 build of test-buildd 667 in ubuntu hoary UPDATES
  hppa build of test-buildd-2 668 in ubuntu hoary UPDATES
  i386 build of test-buildd-2 668 in ubuntu hoary UPDATES
  hppa build of test-buildd-3 669 in ubuntu hoary UPDATES
  i386 build of test-buildd-3 669 in ubuntu hoary UPDATES
  hppa build of test-buildd-4 670 in ubuntu hoary UPDATES
  hppa build of test-buildd-6 672 in ubuntu hoary UPDATES
  i386 build of test-buildd-7 673 in ubuntu hoary UPDATES

And have a look at our arch-all series's build:

  >>> b = Build.selectOneBy(sourcepackagerelease=spr_all)
  >>> (b.sourcepackagerelease.name, b.distroarchseries.distroseries.name)
  (u'test-buildd', u'hoary')

Create and verify the new queue entries
---------------------------------------

Now we have Build table properly set and probably with some entries
marked as NEEDSBUILD we can create BuildQueue entries for it

  >>> bm.addMissingBuildQueueEntries()
  >>> print BuildQueue.select().count() - len(old_jobs)
  8

A separate method, sanitiseAndScoreCandidates, is responsible for
cleaning up the BuildQueue and scroring the jobs properly. Since we
haven't run it yet, we'll see that the new entries we've created have
the default score value of 0:

  >>> bq = BuildQueue.select(orderBy='id')[len(old_jobs)]
  >>> bq.lastscore
  0

Check the published component name retriever, they might be different,
i.e., the published component can be different than the original component.

  >>> bq.build.current_component.name
  u'main'
  >>> bq.build.sourcepackagerelease.component.name
  u'main'

Sanitise the queue
------------------

After sanitising the jobs, only the ones containing
sourcepackagerelease files should remain:

  >>> jobs = bm.sanitiseAndScoreCandidates()

  >>> new_jobs = [job for job in jobs if job not in old_jobs]
  >>> len(new_jobs)
  8

  >>> job = new_jobs[0]
  >>> job.build.sourcepackagerelease.name
  u'test-buildd'

And we grant some score depending on: time pending on the buildqueue,
component the package belongs to, and the urgency of the upload.
There is still some work to do here, for further information see the
buildmaster/master.py code. The job presented should won
exactly ** 1005 ** points last turn (5 for the default urgency 'LOW'
and 1000 for the 'Main' component, further tests for scoring are in
buildd-scoring.txt)

  >>> job.lastscore
  1005

== PPA work ==

Currently all Build/BuildQueue are processed in the same batch,
independently of the targeted archive.

For testing PPA we will snapshot the current build/buildqueue status
again:

  >>> old_builds = set(Build.select())
  >>> old_jobs = set(BuildQueue.select())

Then we can create new publication target to PPA archive present in
the sample data:

  >>> from canonical.launchpad.interfaces import IPersonSet
  >>> cprov = getUtility(IPersonSet).getByName('cprov')

  >>> name6 = SourcePackageName(name="test-ppa")
  >>> spr_hoary_ppa, pub_hoary_ppa = createPackageAndPublication(
  ...     name6, hoary, "i386 hppa", archive=cprov.archive)

Now we create builds and buildqueues and check their contents:

  >>> for dr in distroserieses:
  ...      bm.createMissingBuilds(dr)
  >>> flush_database_updates()

Check that we only created new Build entry for ppa publication:

  >>> new_builds = set(Build.select()) - old_builds
  >>> for build in sorted(new_builds, key=operator.attrgetter('id')):
  ...   print build.title
  i386 build of test-ppa 674 in ubuntu hoary UPDATES

Note that it did not create a build for 'hppa' as is requested in the
given 'architeturehintlist' ('i386 hppa'). Only 'i386' and 'amd64' are
allowed for PPA (see further comments in buildmaster/master.py).

Check if BuildQueue are also created for ppa_builds:

  >>> bm.addMissingBuildQueueEntries()
  >>> jobs = bm.sanitiseAndScoreCandidates()

  >>> new_jobs = [job for job in jobs if job not in old_jobs]
  >>> len(new_jobs)
  1

Check if the BuildQueue/Build contains the right Archive, which would
suffice for the build being dispatched and collected correctly (see
buildd-slavescanner.txt):

  >>> ppa_job = new_jobs[0]
  >>> ppa_job.build.archive.owner.name
  u'cprov'
