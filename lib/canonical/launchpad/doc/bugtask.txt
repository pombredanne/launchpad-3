Introduction
============

Bugs are problems in software. When a bug gets assigned to a specific
upstream or distro/sourcepackagename, a bug /task/ is created. In
essence, a bug task is a bug that needs to be fixed in a specific
place. Where a bug has things like a title, comments and subscribers,
it's the bug task that tracks importance, assignee, etc.

Working with Bug Tasks in Launchpad
===================================

Creating Bug Tasks
------------------

All BugTask creation and retrieval is done through an IBugTaskSet utility.

    >>> from zope.component import getUtility
    >>> import transaction
    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> bugtaskset = getUtility(IBugTaskSet)

To create a bug task, you have to be logged in:

    >>> from canonical.launchpad.ftests import login, ANONYMOUS
    >>> login('foo.bar@canonical.com')

There are three kinds of bug tasks. We need to pass the bug task creation
methods some other objects to create a task, so lets get the utilities we need
to access those other objects:

    >>> from canonical.launchpad.interfaces import (IBugSet, IPersonSet,
    ...     IProductSet, IDistributionSet, IDistroReleaseSet,
    ...     ISourcePackageNameSet)
    >>> productset = getUtility(IProductSet)
    >>> distroset = getUtility(IDistributionSet)
    >>> distoreleaseset = getUtility(IDistroReleaseSet)
    >>> sourcepackagenameset = getUtility(ISourcePackageNameSet)
    >>> bugset = getUtility(IBugSet)
    >>> personset = getUtility(IPersonSet)
    >>> bug_one = bugset.get(1)
    >>> sabdfl = personset.get(1)

Next, we need to grab some values to provide for importance and status.

    >>> from canonical.lp.dbschema import (BugTaskStatus, BugTaskImportance)
    >>> STATUS_UNCONFIRMED = BugTaskStatus.UNCONFIRMED
    >>> STATUS_CONFIRMED = BugTaskStatus.CONFIRMED
    >>> STATUS_FIXRELEASED = BugTaskStatus.FIXRELEASED
    >>> IMPORTANCE_MEDIUM = BugTaskImportance.MEDIUM

  i. Upstream -- a bug that has to be fixed in an upstream product

    >>> evolution = productset.get(5)
    >>> upstream_task = bugtaskset.createTask(
    ...     bug=bug_one, product=evolution, owner=sabdfl,
    ...     status=STATUS_UNCONFIRMED, importance=IMPORTANCE_MEDIUM)
    >>> upstream_task.product == evolution
    True

    >>> from canonical.launchpad.interfaces import IUpstreamBugTask
    >>> IUpstreamBugTask.providedBy(upstream_task)
    True

  ii. Distro -- a bug that has to be fixed in a specific distro

    >>> ubuntu = distroset.get(1)
    >>> distro_task = bugtaskset.createTask(
    ...     bug=bug_one, distribution=ubuntu, owner=sabdfl,
    ...     status=STATUS_UNCONFIRMED, importance=IMPORTANCE_MEDIUM)
    >>> distro_task.distribution == ubuntu
    True

    >>> from canonical.launchpad.interfaces import IDistroBugTask
    >>> IDistroBugTask.providedBy(distro_task)
    True

  ii. Distro Release -- a bug that has to be fixed in a specific distro
  release. These tasks are used for release management and backporting.

    >>> warty = distoreleaseset.get(1)
    >>> distro_release_task = bugtaskset.createTask(
    ...     bug=bug_one, distrorelease=warty, owner=sabdfl,
    ...     status=STATUS_UNCONFIRMED, importance=IMPORTANCE_MEDIUM)
    >>> distro_release_task.distrorelease == warty
    True

    >>> from canonical.launchpad.interfaces import IDistroReleaseBugTask
    >>> IDistroReleaseBugTask.providedBy(distro_release_task)
    True

XXX: Brad Bollenbach, 2005-02-24: See the bottom of this file for a chunk of
test documentation that is missing from here, due to problems with resetting
the connection after a ProgrammingError is raised. ARGH.

Retrieving and Searching for Bug Tasks
--------------------------------------

To retrieve a specific BugTask, use IBugTaskSet.get. As an example,
interacting with the system as an anonymous (i.e. unauthenticated) user:

    >>> from canonical.launchpad.interfaces import IPerson
    >>> from canonical.launchpad.database import Person
    >>> login(ANONYMOUS)

let's fetch the BugTask with ID 2:

    >>> bugtask = bugtaskset.get(2)
    >>> bugtask.bug.title
    u'Firefox does not support SVG'

If you pass an ID for which no object exists, you'll get a
zope.exceptions.NotFoundError:

    >>> bugtask = bugtaskset.get(-1)
    Traceback (most recent call last):
      ...
    NotFoundError: 'BugTask with ID -1 does not exist'

To retrieve a set of bug tasks matching a set of search criteria, use
the searchTasks method of the IBugTarget interface. Here's how you'd
grab all the UNCONFIRMED and CONFIRMED tasks:

For upstream:

    >>> from canonical.launchpad.searchbuilder import any
    >>> from canonical.lp.dbschema import BugTaskStatus
    >>> from canonical.launchpad.database import Product
    >>> from canonical.launchpad.interfaces import BugTaskSearchParams
    >>> upstream_mozilla = Product.get(4)
    >>> params = BugTaskSearchParams(status=any(BugTaskStatus.UNCONFIRMED,
    ...                                         BugTaskStatus.CONFIRMED),
    ...                              orderby="id", user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    4
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [2, 13, 14, 15]

By project:

    >>> from canonical.launchpad.interfaces import IProjectSet
    >>> mozilla_project = getUtility(IProjectSet).getByName('mozilla')
    >>> params = BugTaskSearchParams(status=any(BugTaskStatus.UNCONFIRMED,
    ...                                         BugTaskStatus.CONFIRMED),
    ...                              orderby="id", user=None)
    >>> bugtasks = mozilla_project.searchTasks(params)
    >>> print bugtasks.count()
    4
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [2, 13, 14, 15]

For a distribution:

    >>> debian = distroset.get(3)
    >>> sample_person = personset.get(12)
    >>> params = BugTaskSearchParams(status=any(BugTaskStatus.UNCONFIRMED,
    ...                                         BugTaskStatus.CONFIRMED),
    ...                              orderby="id", user=None,
    ...                              assignee=sample_person)
    >>> bugtasks = debian.searchTasks(params)
    >>> print bugtasks.count()
    1
    >>> bugtasks[0].id
    5

For a person:

    >>> from canonical.database.sqlbase import (
    ...     flush_database_updates, flush_database_caches)
    >>> foobar = personset.get(16)
    >>> evolution_sourcepackage = sourcepackagenameset.queryByName('evolution')
    >>> ubuntu_evolution_task = bugtaskset.createTask(
    ...     bug=bug_one, distribution=ubuntu, owner=foobar,
    ...     status=STATUS_UNCONFIRMED, importance=IMPORTANCE_MEDIUM,
    ...     sourcepackagename=evolution_sourcepackage)
    >>> flush_database_updates()
    >>> params = BugTaskSearchParams(owner=foobar, user=None,
    ...                              orderby='targetname')
    >>> [bugtask.targetname for bugtask in foobar.searchTasks(params)]
    [u'Evolution',
     u'Jokosher',
     u'Jokosher',
     u'Mozilla Firefox 1.0',
     u'Ubuntu',
     u'evolution (Ubuntu)',
     u'linux-source-2.6.15 (Ubuntu)',
     u'mozilla-firefox (Debian)',
     u'mozilla-firefox (Ubuntu)',
     u'thunderbird (Ubuntu)']

It's also possible to search bugs that a person is subscribed to:

    >>> params = BugTaskSearchParams(user=None, subscriber=foobar, orderby="id")
    >>> [bugtask.bug.id for bugtask in foobar.searchTasks(params)]
    [7, 7, 9, 9, 10, 11, 12]

We can even search bugs that a person reported OR that are assigned to that
person.
    
    >>> params_assignee = BugTaskSearchParams(user=None, assignee=foobar)
    >>> params_owner = BugTaskSearchParams(user=None, owner=foobar)

    >>> for bugtask in foobar.searchTasks(params_assignee, params_owner):
    ...     assignee = getattr(bugtask.assignee, 'name', None)
    ...     owner = getattr(bugtask.owner, 'name', None)
    ...     print bugtask.bug.id, bugtask.targetname, assignee, owner
     3 mozilla-firefox (Debian) None name16
     1 mozilla-firefox (Ubuntu) None name16
     7 Evolution name16 name16
     8 mozilla-firefox (Debian) name16 name12
     9 thunderbird (Ubuntu) None name16
    10 linux-source-2.6.15 (Ubuntu) None name16
     2 Ubuntu None name16
     5 Mozilla Firefox 1.0 None name16
    11 Jokosher None name16
    12 Jokosher None name16
     1 evolution (Ubuntu) None name16

How about the bugs reported by foobar, the ones he's subscribed to and the
ones that are assigned to him --all of them together. That makes a nice list
for a person's +bugs page.

    >>> params_subscriber = BugTaskSearchParams(user=None, subscriber=foobar)
    >>> for bugtask in foobar.searchTasks(
    ...         params_assignee, params_owner, params_subscriber):
    ...     assignee = getattr(bugtask.assignee, 'name', None)
    ...     owner = getattr(bugtask.owner, 'name', None)
    ...     subscribed = ""
    ...     if foobar in bugtask.bug.getDirectSubscribers():
    ...         subscribed = "Subscribed"
    ...     print bugtask.bug.id, bugtask.targetname, assignee, owner, subscribed
     3 mozilla-firefox (Debian) None name16
     1 mozilla-firefox (Ubuntu) None name16
     7 Evolution name16 name16 Subscribed
     8 mozilla-firefox (Debian) name16 name12
     9 thunderbird (Ubuntu) None name16 Subscribed
     9 Mozilla Thunderbird None name12 Subscribed
    10 linux-source-2.6.15 (Ubuntu) None name16 Subscribed
     2 Ubuntu None name16
     7 evolution (Debian) None name12 Subscribed
     5 Mozilla Firefox 1.0 None name16
    11 Jokosher None name16 Subscribed
    12 Jokosher None name16 Subscribed
     1 evolution (Ubuntu) None name16


To provide null-matching search criteria, use
canonical.launchpad.searchbuilder.NULL:

    >>> from canonical.launchpad.searchbuilder import NULL
    >>> params = BugTaskSearchParams(assignee=NULL, user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    2
    >>> print [bugtask.bug.id for bugtask in bugtasks]
    [4, 6]

    >>> params = BugTaskSearchParams(sourcepackagename=NULL, user=None)
    >>> bugtasks = ubuntu.searchTasks(params)
    >>> print sorted(bugtask.bug.id for bugtask in bugtasks)
    [1, 2]

For negating a search argument, use not_equals:

    >>> from canonical.launchpad.searchbuilder import not_equals

    >>> params = BugTaskSearchParams(
    ...     importance=not_equals(BugTaskImportance.LOW), user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)

    >>> print sorted(bugtask.bug.id for bugtask in bugtasks)
    [4, 5, 6]

There's also support for searching tasks based on a string of text, e.g.:

    >>> params = BugTaskSearchParams(searchtext="instructions", user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    1
    >>> print [bugtask.bug.id for bugtask in bugtasks]
    [5]

searchtext is also used in a substring search against the target name:

    >>> params = BugTaskSearchParams(searchtext="mozilla-firefoxX", user=None)
    >>> bugtasks = debian.searchTasks(params)
    >>> print bugtasks.count()
    0
    >>> params = BugTaskSearchParams(searchtext="mozilla-firefox", user=None)
    >>> bugtasks = debian.searchTasks(params)
    >>> print bugtasks.count()
    4
    >>> params = BugTaskSearchParams(searchtext="mozilla-fire", user=None)
    >>> bugtasks = debian.searchTasks(params)
    >>> print bugtasks.count()
    4

When the IBugTarget is an IDistribution, IDistributionSourcePackage, or
ISourcePackage, you may include a "component" argument to filter the
search. Let's file some bugs on cnews, a universe package, to
demonstrate how component filtering works.

    >>> from canonical.launchpad.interfaces import CreateBugParams, ILaunchBag

    >>> cnews = ubuntu.getSourcePackage("cnews")

    >>> login("foo.bar@canonical.com")

    >>> launchbag = getUtility(ILaunchBag)

    >>> params = CreateBugParams(
    ...     owner=launchbag.user,
    ...     title="a bug in a universe package",
    ...     comment="test")
    >>> cnews.createBug(params)
    <Bug ...>

There are now three bugtasks open on packages in Ubuntu main.

    >>> from canonical.launchpad.interfaces import IComponentSet
    >>> componentset = getUtility(IComponentSet)
    >>> main = componentset["main"]
    >>> universe = componentset["universe"]

    >>> params = BugTaskSearchParams(component=main, user=None)
    >>> main_tasks = ubuntu.searchTasks(params)
    >>> sorted(bugtask.bug.id for bugtask in main_tasks)
    [1, 10]

And there is the one bug on a "universe" package that we just added:

    >>> params = BugTaskSearchParams(component=universe, user=None)
    >>> universe_tasks = ubuntu.searchTasks(params)
    >>> sorted(bugtask.bug.title for bugtask in universe_tasks)
    [u'a bug in a universe package']

Let's get all bugs on either main or universe:

    >>> params = BugTaskSearchParams(
    ...     component=any(main, universe), user=None)
    >>> main_or_universe_tasks = ubuntu.searchTasks(params)
    >>> sorted(bugtask.bug.id for bugtask in main_or_universe_tasks)
    [1, 10, 13L]

You can also filter your search on other bugtasks. Let's show only bugs
where a bug watch is needed. This means that we should show only bugs
where there is at least one other bugtask on the bug, on a target which
doesn't use Malone, and which lacks a bug watch.

    >>> from canonical.launchpad.ftests.test_bugtask import (
    ...     BugTaskSearchBugsElsewhereTest)
    >>> test_helper = BugTaskSearchBugsElsewhereTest(helper_only=True)

    >>> params = BugTaskSearchParams(
    ...     pending_bugwatch_elsewhere=True, user=None)
    >>> pending_bugwatch_elsewhere_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in pending_bugwatch_elsewhere_tasks:
    ...     test_helper.assertBugTaskIsPendingBugWatchElsewhere(bugtask)
    ...     print bugtask.bug.id, bugtask.bug.title
    2 Blackhole Trash folder

Pass the only_resolved_upstream flag to include only bugtasks linked to
watches that are rejected, fixed committed or fix released, or bugtasks
related to upstream bugtasks (i.e. filed on the same bug) that are fix
committed or fix released.

    >>> login('test@canonical.com')
    >>> test_helper.setUpBugsResolvedUpstreamTests()

    >>> from canonical.launchpad.interfaces import RESOLVED_BUGTASK_STATUSES
    >>> params = BugTaskSearchParams(
    ...     only_resolved_upstream=True, orderby='id', user=None)
    >>> closed_elsewhere_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in closed_elsewhere_tasks:
    ...     test_helper.assertBugTaskIsResolvedUpstream(bugtask)
    ...     print bugtask.bug.id, bugtask.targetname
    1 mozilla-firefox (Ubuntu)
    1 Ubuntu
    1 evolution (Ubuntu)
    2 Ubuntu
    9 thunderbird (Ubuntu)

We can also filter our search to include only bugs that are not known to
affect upstream, i.e., bugs that don't have an IUpstreamBugTask.

    >>> params = BugTaskSearchParams(
    ...     has_no_upstream_bugtask=True, orderby='id', user=None)
    >>> tasks_with_no_upstreams = ubuntu.searchTasks(params)
    >>> for bugtask in tasks_with_no_upstreams:
    ...     test_helper.assertShouldBeShownOnNoUpstreamTaskSearch(bugtask)
    ...     print bugtask.bug.id, bugtask.targetname
    10 linux-source-2.6.15 (Ubuntu)
    13 cnews (Ubuntu)

    >>> test_helper.tearDownBugsElsewhereTests()

The search filter can also return bugs that are related to CVE reports:

    >>> params = BugTaskSearchParams(
    ...     has_cve=True, orderby='id', user=None)
    >>> tasks_with_cves = ubuntu.searchTasks(params)
    >>> for bugtask in tasks_with_cves:
    ...     print bugtask.bug.id, bugtask.targetname
    1 mozilla-firefox (Ubuntu)
    1 Ubuntu
    1 evolution (Ubuntu)
    2 Ubuntu

Bug Task Targets
----------------

The "target" of an IBugTask is one of the following things:

  * an upstream product

    >>> upstream_task.target == evolution
    True

  * a product series

    >>> from canonical.launchpad.interfaces import IProductSeriesBugTask

    >>> firefox = productset['firefox']
    >>> firefox_1_0 = firefox.getSeries("1.0")

    >>> productseries_task = bugtaskset.createTask(
    ...     owner=sabdfl, bug=bug_one, productseries=firefox_1_0)
    >>> IProductSeriesBugTask.providedBy(productseries_task)
    True

    >>> productseries_task.target == firefox_1_0
    True

  * a distribution

    >>> distro_task.target == ubuntu
    True

  * a distrorelease

    >>> distro_release_task.target == warty
    True

  * a distribution sourcepackage

    >>> from canonical.launchpad.database.distributionsourcepackage import DistributionSourcePackage
    >>> from canonical.launchpad.interfaces import IDistributionSourcePackage
    >>> distro_sp_task = bugtaskset.get(4)
    >>> expected_target = DistributionSourcePackage(
    ...     distro_sp_task.distribution,
    ...     distro_sp_task.sourcepackagename)
    >>> got_target = distro_sp_task.target
    >>> IDistributionSourcePackage.providedBy(distro_sp_task.target)
    True
    >>> got_target.distribution == expected_target.distribution
    True
    >>> got_target.sourcepackagename == expected_target.sourcepackagename
    True

  * a distrorelease sourcepackage

    >>> from canonical.launchpad.database import SourcePackage
    >>> from canonical.launchpad.interfaces import ISourcePackage
    >>> distro_release_sp_task = bugtaskset.get(16)
    >>> expected_target = SourcePackage(
    ...     distrorelease=distro_release_sp_task.distrorelease,
    ...     sourcepackagename=distro_release_sp_task.sourcepackagename)
    >>> got_target = distro_release_sp_task.target
    >>> ISourcePackage.providedBy(distro_release_sp_task.target)
    True
    >>> got_target.distrorelease == expected_target.distrorelease
    True
    >>> got_target.sourcepackagename == expected_target.sourcepackagename
    True

Each task has a "targetname", a string describing the site of the
task. It concatenates the display names of the distribution,

    >>> bugtask = bugtaskset.get(17)
    >>> bugtask.targetname
    u'mozilla-firefox (Ubuntu)'

distro release, or product;

    >>> bugtask = bugtaskset.get(2)
    >>> bugtask.targetname
    u'Mozilla Firefox'

the name of the source package (if any); and the name of the binary
package (but only if it's named differently from the source
package).

Editing Bug Tasks
-----------------

Upstream Bug Tasks
^^^^^^^^^^^^^^^^^^

To edit an upstream task, you must be logged in. Anonymous users
cannot edit upstream tasks.

    >>> login(ANONYMOUS)
    >>> upstream_task.transitionToStatus(STATUS_CONFIRMED)
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'transitionToStatus', 'launchpad.Edit')

Let's login and try again.

    >>> login('jeff.waugh@ubuntulinux.com')
    >>> upstream_task.transitionToStatus(STATUS_FIXRELEASED)

Distro and Distro Release Bug Tasks
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Any logged-in user can edit tasks filed on distros as long as the bug
is not marked private. So, as an anonymous user, we can edit anything:

    >>> login(ANONYMOUS)
    >>> distro_task.transitionToStatus(STATUS_FIXRELEASED)
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'transitionToStatus', 'launchpad.Edit')

    >>> distro_release_task.transitionToAssignee(sample_person)
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'transitionToAssignee', 'launchpad.Edit')

But once authenticated:

    >>> login('test@canonical.com')

We can edit the task:

    >>> distro_task.transitionToStatus(STATUS_FIXRELEASED)
    >>> distro_release_task.transitionToAssignee(sample_person)

Conjoined Bug Tasks
-------------------

A bugtask open on the current development release for a distro is kept
in sync with the "generic" bugtask for that distro, because they
represent the same piece of work. The same is true for product and
productseries tasks, when the productseries task is targeted to the
IProduct.developmentfocus. The following attributes are synched:

    * status
    * assignee
    * importance
    * milestone
    * sourcepackagename
    * date_confirmed
    * date_inprogress
    * date_assigned
    * date_closed

We'll open a bug on just the distribution, and also a bug on a specific
package.

    >>> params = CreateBugParams(
    ...     owner=launchbag.user,
    ...     title="a test bug",
    ...     comment="test bug description")
    >>> ubuntu_netapplet = ubuntu.getSourcePackage("netapplet")
    >>> ubuntu_netapplet_bug = ubuntu_netapplet.createBug(params)
    >>> generic_netapplet_task = ubuntu_netapplet_bug.bugtasks[0]

    >>> ubuntu_bug = ubuntu.createBug(params)
    >>> generic_ubuntu_task = ubuntu_bug.bugtasks[0]

First, we'll target the bug for the current Ubuntu release, Hoary. Note
that the synched attributes are copied when the release- and
series-specific tasks are created. We'll set non-default attribute
values for each generic task to demonstrate.

    >>> print ubuntu.currentrelease.name
    hoary

    >>> ubuntu_edgy_milestone = ubuntu.currentrelease.newMilestone("knot1")

    >>> generic_netapplet_task.transitionToStatus(BugTaskStatus.INPROGRESS)
    >>> generic_netapplet_task.transitionToAssignee(sample_person)
    >>> generic_netapplet_task.milestone = ubuntu_edgy_milestone
    >>> generic_netapplet_task.importance = BugTaskImportance.CRITICAL

    >>> current_release_ubuntu_task = bugtaskset.createTask(
    ...     bug=ubuntu_bug, owner=launchbag.user,
    ...     distrorelease=ubuntu.currentrelease)

    >>> current_release_netapplet_task = bugtaskset.createTask(
    ...     bug=ubuntu_netapplet_bug, owner=launchbag.user,
    ...     distrorelease=ubuntu.currentrelease,
    ...     sourcepackagename=ubuntu_netapplet.sourcepackagename)

(The attributes were synched with the generic task.)

    >>> print current_release_netapplet_task.status.title
    In Progress
    >>> print current_release_netapplet_task.assignee.displayname
    Sample Person
    >>> print current_release_netapplet_task.milestone.name
    knot1
    >>> print current_release_netapplet_task.importance.title
    Critical

    >>> current_release_netapplet_task.date_assigned == (
    ...     generic_netapplet_task.date_assigned)
    True

    >>> current_release_netapplet_task.date_confirmed == (
    ...     generic_netapplet_task.date_confirmed)
    True

    >>> current_release_netapplet_task.date_inprogress == (
    ...     generic_netapplet_task.date_inprogress)
    True

    >>> current_release_netapplet_task.date_closed == (
    ...     generic_netapplet_task.date_closed)
    True

We'll also add some product and productseries tasks.

    >>> alsa_utils = productset['alsa-utils']

    >>> print alsa_utils.development_focus.name
    trunk

    >>> generic_alsa_utils_task = bugtaskset.createTask(
    ...     bug=ubuntu_netapplet_bug, owner=launchbag.user,
    ...     product=alsa_utils)

    >>> devel_focus_alsa_utils_task = bugtaskset.createTask(
    ...     bug=ubuntu_netapplet_bug, owner=launchbag.user,
    ...     productseries=alsa_utils.getSeries("trunk"))

A conjoined bugtask involves a master and slave in the conjoined
relationship. The slave is the generic product or distribution task;
the master is the release- or series-specific task. These tasks are
accessed through the conjoined_master and conjoined_slave properties.

    >>> current_release_netapplet_task.conjoined_slave == (
    ...     generic_netapplet_task)
    True
    >>> current_release_netapplet_task.conjoined_master is None
    True

    >>> generic_netapplet_task.conjoined_slave is None
    True
    >>> generic_netapplet_task.conjoined_master == (
    ...     current_release_netapplet_task)
    True

    >>> current_release_ubuntu_task.conjoined_slave == (
    ...     generic_ubuntu_task)
    True
    >>> current_release_ubuntu_task.conjoined_master is None
    True
    >>> generic_ubuntu_task.conjoined_master == (
    ...     current_release_ubuntu_task)
    True
    >>> generic_ubuntu_task.conjoined_slave is None
    True

    >>> devel_focus_alsa_utils_task.conjoined_slave == (
    ...     generic_alsa_utils_task)
    True
    >>> devel_focus_alsa_utils_task.conjoined_master is None
    True

    >>> generic_alsa_utils_task.conjoined_slave is None
    True
    >>> generic_alsa_utils_task.conjoined_master == (
    ...     devel_focus_alsa_utils_task)
    True

A distrorelease/productseries task that isn't the current development
focus, doesn't have any conjoined masters or slaves.

    >>> alsa_utils_stable = alsa_utils.newSeries(
    ...     launchbag.user, 'stable', 'The stable series.')
    >>> alsa_utils.development_focus == alsa_utils_stable
    False
    >>> stable_netapplet_task = bugtaskset.createTask(
    ...     bug=ubuntu_netapplet_bug, owner=launchbag.user,
    ...     productseries=alsa_utils_stable)
    >>> stable_netapplet_task.conjoined_master is None
    True
    >>> stable_netapplet_task.conjoined_slave is None
    True

    >>> warty = ubuntu.getRelease('warty')
    >>> warty == ubuntu.currentrelease
    False
    >>> warty_netapplet_task = bugtaskset.createTask(
    ...     bug=ubuntu_netapplet_bug, owner=launchbag.user,
    ...     distrorelease=warty,
    ...     sourcepackagename=ubuntu_netapplet.sourcepackagename)
    >>> warty_netapplet_task.conjoined_master is None
    True
    >>> warty_netapplet_task.conjoined_slave is None
    True

If a distribution doesn't have a current release, its tasks don't have a
conjoined master or slave.

    >>> gentoo = getUtility(IDistributionSet).getByName('gentoo')
    >>> gentoo.currentrelease is None
    True

    >>> gentoo_netapplet_task = bugtaskset.createTask(
    ...     bug=ubuntu_netapplet_bug, owner=launchbag.user,
    ...     distribution=gentoo,
    ...     sourcepackagename=ubuntu_netapplet.sourcepackagename)
    >>> gentoo_netapplet_task.conjoined_master is None
    True
    >>> gentoo_netapplet_task.conjoined_slave is None
    True


Now the attributes are kept in sync. Here are examples of each:

(Login as Foo Bar, because the milestone and importance examples
require extra privileges.)

    >>> login("foo.bar@canonical.com")

1. Status

    >>> print generic_netapplet_task.status.title
    In Progress
    >>> print current_release_netapplet_task.status.title
    In Progress
    >>> generic_netapplet_task.date_closed is None
    True
    >>> current_release_netapplet_task.date_closed is None
    True

    >>> current_release_netapplet_task.transitionToStatus(
    ...     BugTaskStatus.FIXRELEASED)

    >>> print generic_netapplet_task.status.title
    Fix Released
    >>> print current_release_netapplet_task.status.title
    Fix Released

    >>> generic_netapplet_task.date_closed
    datetime.datetime...
    >>> generic_netapplet_task.date_closed == (
    ...     current_release_netapplet_task.date_closed)
    True

2. Assignee

    >>> no_priv = personset.getByName("no-priv")

    >>> generic_alsa_utils_task.assignee is None
    True
    >>> devel_focus_alsa_utils_task.assignee is None
    True
    >>> generic_alsa_utils_task.date_assigned is None
    True
    >>> devel_focus_alsa_utils_task.date_assigned is None
    True

    >>> devel_focus_alsa_utils_task.transitionToAssignee(no_priv)

    >>> print generic_alsa_utils_task.assignee.displayname
    No Privileges Person
    >>> print devel_focus_alsa_utils_task.assignee.displayname
    No Privileges Person

    >>> generic_alsa_utils_task.date_assigned
    datetime.datetime...
    >>> generic_alsa_utils_task.date_assigned == (
    ...     devel_focus_alsa_utils_task.date_assigned)
    True

3. Importance

    >>> print generic_netapplet_task.importance.title
    Critical
    >>> print current_release_netapplet_task.importance.title
    Critical

    >>> current_release_netapplet_task.importance = BugTaskImportance.MEDIUM

    >>> print generic_netapplet_task.importance.title
    Medium
    >>> print current_release_netapplet_task.importance.title
    Medium

4. Milestone

    >>> test_milestone = alsa_utils.development_focus.newMilestone("test")

    >>> generic_alsa_utils_task.milestone is None
    True
    >>> devel_focus_alsa_utils_task.milestone is None
    True

    >>> devel_focus_alsa_utils_task.milestone = test_milestone

    >>> print generic_alsa_utils_task.milestone.name
    test
    >>> print devel_focus_alsa_utils_task.milestone.name
    test

5. Source package name

    >>> ubuntu_pmount = ubuntu.getSourcePackage("pmount")

    >>> print generic_netapplet_task.sourcepackagename.name
    netapplet
    >>> print current_release_netapplet_task.sourcepackagename.name
    netapplet

    >>> current_release_netapplet_task.sourcepackagename = (
    ...     ubuntu_pmount.sourcepackagename)

    >>> print generic_netapplet_task.sourcepackagename.name
    pmount
    >>> print current_release_netapplet_task.sourcepackagename.name
    pmount

The generic tasks are not directly editable.

    >>> generic_netapplet_task.transitionToStatus(BugTaskStatus.REJECTED)
    Traceback (most recent call last):
      ...
    ConjoinedBugTaskEditError: This task cannot be edited directly, it
                               should be edited through its conjoined_master.

    >>> generic_alsa_utils_task.transitionToAssignee(launchbag.user)
    Traceback (most recent call last):
      ...
    ConjoinedBugTaskEditError: This task cannot be edited directly, it
                               should be edited through its conjoined_master.


A conjoined relationship can be broken, though. If the development
task (i.e the conjoined master) is Rejected, it means that the bug is
deferred to the next release. In this case the development task should
be Rejected, while the generic task keeps the value it had before,
allowing it to stay open.

First let's change the status from Fix Released, since it doesn't make
sense to reject such a task.

    >>> current_release_netapplet_task.transitionToStatus(
    ...     BugTaskStatus.CONFIRMED)
    >>> print generic_netapplet_task.status.title
    Confirmed
    >>> print current_release_netapplet_task.status.title
    Confirmed
    >>> generic_netapplet_task.date_closed is None
    True
    >>> current_release_netapplet_task.date_closed is None
    True


Now, if we reject the current release task, the generic task will still
be confirmed.

    >>> current_release_netapplet_task.transitionToStatus(
    ...     BugTaskStatus.REJECTED)

    >>> print generic_netapplet_task.status.title
    Confirmed
    >>> print current_release_netapplet_task.status.title
    Rejected

    >>> generic_netapplet_task.date_closed is None
    True
    >>> current_release_netapplet_task.date_closed is None
    False

And the bugtasks are no longer conjoined:

    >>> generic_netapplet_task.conjoined_master is None
    True
    >>> current_release_netapplet_task.conjoined_slave is None
    True

Null Bug Tasks
--------------

Sometimes we need to be able to render a page for a bug in a context,
when the bug hasn't actually been filed yet in that context. For cases
like these, use the NullBugTask object.


    >>> netapplet = productset.get(11)
    >>> null_bugtask = bug_one.getNullBugTask(product=netapplet)
    >>> IUpstreamBugTask.providedBy(null_bugtask)
    True

    >>> null_bugtask.id is None
    True
    >>> null_bugtask.title == 'Bug #1 in NetApplet: "Firefox does not support SVG"'
    True
    >>> null_bugtask.product is netapplet
    True
    >>> null_bugtask.bug == bug_one
    True
    >>> null_bugtask.datecreated is None
    True
    >>> null_bugtask.date_assigned is None
    True
    >>> null_bugtask.age is None
    True
    >>> null_bugtask.status is None
    True
    >>> null_bugtask.sourcepackagename is None
    True
    >>> null_bugtask.distribution is None
    True
    >>> null_bugtask.distrorelease is None
    True
    >>> null_bugtask.milestone is None
    True
    >>> null_bugtask.importance is None
    True
    >>> null_bugtask.assignee is None
    True
    >>> null_bugtask.bugwatch is None
    True
    >>> null_bugtask.owner is None
    True
    >>> null_bugtask.target == netapplet
    True
    >>> null_bugtask.targetname
    u'NetApplet'
    >>> expected_related_task_ids = [
    ...     task.id for task in null_bugtask.related_tasks]
    >>> actual_related_task_ids = [task.id for task in bug_one.bugtasks]
    >>> expected_related_task_ids.sort()
    >>> actual_related_task_ids.sort()
    >>> expected_related_task_ids == actual_related_task_ids
    True

    >>> null_bugtask.conjoined_slave is None
    True
    >>> null_bugtask.conjoined_master is None
    True

The astute reader will have noticed that NullBugTask automatically
"marked" itself as providing the correct IBugTask interface. Let's see
two more examples:

    >>> ubuntu_null_bugtask = bug_one.getNullBugTask(distribution=ubuntu)
    >>> IDistroBugTask.providedBy(ubuntu_null_bugtask)
    True

    >>> warty_null_bugtask = bug_one.getNullBugTask(distrorelease=warty)
    >>> IDistroReleaseBugTask.providedBy(warty_null_bugtask)
    True

Bug Privacy
===========

A bug is either private or public. Private bugs are only visible (e.g. in search
listings) to explicit subscribers and Launchpad admins. Public bugs are visible
to anyone.

    >>> from zope.event import notify
    >>> from zope.publisher.browser import TestRequest
    >>> from canonical.launchpad.event.sqlobjectevent import (
    ...     SQLObjectToBeModifiedEvent, SQLObjectModifiedEvent)

Privacy and Unpriviledged Users
-------------------------------

Let's log in as the user Foo Bar (to be allowed to edit bugs):

    >>> login('foo.bar@canonical.com')
    >>> foobar = launchbag.user

and mark one of the Firefox bugs private. While we do this, we're also
going to subscribe the Ubuntu team to the bug report to help demonstrate
later on the interaction between privacy and teams (see the section
entitled _Privacy and Team Awareness_):

    >>> from canonical.launchpad.interfaces import IBug
    >>> from canonical.launchpad.webapp.snapshot import Snapshot

    >>> bug_upstream_firefox_no_svg_support = bugtaskset.get(2)

    >>> ubuntu_team = personset.get(17)
    >>> subscription = bug_upstream_firefox_no_svg_support.bug.subscribe(
    ...     ubuntu_team)

    >>> notify(SQLObjectToBeModifiedEvent(
    ...     bug_upstream_firefox_no_svg_support.bug, {'private' : True}))

    >>> old_state = Snapshot(
    ...     bug_upstream_firefox_no_svg_support.bug, providing=IBug)
    >>> bug_upstream_firefox_no_svg_support.bug.private = True
    >>> bug_set_private = SQLObjectModifiedEvent(
    ...     bug_upstream_firefox_no_svg_support.bug, old_state,
    ...     ["id", "title", "private"])
    >>> notify(bug_set_private)

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()

If we now login as someone who was neither implicitly nor explicitly subscribed
to this bug, e.g. No Privileges Person, they will not be able to access or set
properties of the bugtask.

    >>> login("no-priv@canonical.com")
    >>> mr_no_privs = launchbag.user

    >>> bug_upstream_firefox_no_svg_support.status
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'status', 'launchpad.View')

    >>> bug_upstream_firefox_no_svg_support.transitionToStatus(
    ...     BugTaskStatus.FIXCOMMITTED)
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'transitionToStatus', 'launchpad.Edit')

The private bugs will be invisible to No Privileges Person in the search
results:

    >>> params = BugTaskSearchParams(
    ...     status=any(STATUS_UNCONFIRMED, STATUS_CONFIRMED),
    ...     orderby="id", user=mr_no_privs)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    3
    >>> bug_ids = [bt.bug.id for bt in bugtasks]
    >>> print sorted(bug_ids)
    [4, 5, 6]

Likewise when the No Privileges Person tries to do a search on tasks
maintained by Foo Bar.

    >>> foobar_maintained_tasks = bugtaskset.maintainedBugTasks(
    ...     foobar, user=mr_no_privs)
    >>> [bugtask.bug.id for bugtask in foobar_maintained_tasks]
    [2]

Privacy and Priviledged Users
-----------------------------

Now, we'll log in as Mark Shuttleworth, who was assigned to this bug
when it was marked private:

    >>> login("mark@hbd.com")

And note that he can access and set the bugtask attributes:

    >>> bug_upstream_firefox_no_svg_support.status.title
    'Unconfirmed'

    >>> bug_upstream_firefox_no_svg_support.transitionToStatus(
    ...     BugTaskStatus.UNCONFIRMED)

Privacy and Team Awareness
--------------------------

No Privileges Person can't see the private bug, because he's not a subscriber:

    >>> login("no-priv@canonical.com")
    >>> no_priv = personset.getByName("no-priv")
    >>> params = BugTaskSearchParams(
    ...     status=any(STATUS_UNCONFIRMED, STATUS_CONFIRMED), user=no_priv)
    >>> firefox_bugtasks = firefox.searchTasks(params)
    >>> [bugtask.bug.id for bugtask in firefox_bugtasks]
    [4, 5, 6]


But if we add No Privileges Person to the Ubuntu Team, and because the Ubuntu
Team *is* subscribed to the bug, No Privileges Person will see the private bug.

    >>> login("mark@hbd.com")
    >>> ubuntu_team.addMember(no_priv, reviewer=ubuntu_team.teamowner)

    >>> login("no-priv@canonical.com")
    >>> params = BugTaskSearchParams(
    ...     status=any(STATUS_UNCONFIRMED, STATUS_CONFIRMED), user=foobar)
    >>> firefox_bugtasks = firefox.searchTasks(params)
    >>> [bugtask.bug.id for bugtask in firefox_bugtasks]
    [1, 4, 5, 6]


If we query for all bugtasks reported on all packages/products that
Sample Person maintains, we'll see that bug 1 is there (we'll not see it
if we query logged in as a user who can't see that bug).

    >>> foobar_maintained_tasks = bugtaskset.maintainedBugTasks(
    ...     sample_person, user=foobar)
    >>> sorted(bugtask.bug.id for bugtask in foobar_maintained_tasks)
    [1, 4, 5, 7]

Privacy and Launchpad Admins
----------------------------

Let's log in as Daniel Henrique Debonzi:

    >>> login("daniel.debonzi@canonical.com")
    >>> debonzi = launchbag.user

The same search as above yields the same result, because Daniel Debonzi is an
administrator.

    >>> firefox = productset.get(4)
    >>> params = BugTaskSearchParams(status=any(STATUS_UNCONFIRMED,
    ...                                         STATUS_CONFIRMED),
    ...                              user=debonzi)
    >>> firefox_bugtasks = firefox.searchTasks(params)
    >>> [bugtask.bug.id for bugtask in firefox_bugtasks]
    [1, 4, 5, 6]

If, still logged in as Daniel Debonzi, we query for all bugtasks
reported on packages/products for which Sample Person is the maintainer,
we'll also see bug 1 again in the results, even though it's private.

    >>> foobar_maintained_tasks = bugtaskset.maintainedBugTasks(
    ...     sample_person, user=debonzi)
    >>> sorted(bugtask.bug.id for bugtask in foobar_maintained_tasks)
    [1, 4, 5, 7]

Trying to retrieve the bug directly will work fine:

    >>> bug_upstream_firefox_no_svg_support = bugtaskset.get(2)

As will attribute access:

    >>> bug_upstream_firefox_no_svg_support.status.title
    'Unconfirmed'

And attribute setting:

    >>> bug_upstream_firefox_no_svg_support.transitionToStatus(
    ...     BugTaskStatus.FIXRELEASED)
    >>> bug_upstream_firefox_no_svg_support.transitionToStatus(
    ...     BugTaskStatus.UNCONFIRMED)

Sorting Bug Tasks
-----------------

Bug tasks need to sort in a very particular order. We want product tasks
first, then ubuntu tasks, then other distro-related tasks. In the
distro-related tasks we want a distribution-task first, then
distrorelease-tasks for that same distribution. The distrorelease tasks
should be sorted by distrorelease version.

Phew.

Let's just make sure that the tasks on bug_one sort correctly.

    >>> tasks = bug_one.bugtasks
    >>> for task in tasks:
    ...     print task.targetname
    Evolution
    Mozilla Firefox
    Mozilla Firefox 1.0
    Ubuntu
    evolution (Ubuntu)
    mozilla-firefox (Ubuntu)
    Ubuntu Warty
    mozilla-firefox (Debian)

BugTask Adaptation
------------------

An IBugTask can be adapted to an IBug.

   >>> from canonical.launchpad.interfaces import IBug

   >>> bugtask_four = bugtaskset.get(4)
   >>> bug = IBug(bugtask_four)
   >>> bug.title
   u'Firefox does not support SVG'

The targetnamecache attribute of BugTask
----------------------------------------

The BugTask table has this targetnamecache attribute which stores a computed
value to allow us to sort and search on that value without having to do lots
of SQL joins. This cached value gets updated daily by the
update-bugtask-targetnamecaches cronscript and whenever the bugtask is changed.
Of course, it's also computed and set when a bugtask is created.

    >>> upstream_task = bugtaskset.createTask(
    ...     bug=bug_one, product=netapplet, owner=sabdfl,
    ...     status=STATUS_UNCONFIRMED, importance=IMPORTANCE_MEDIUM)
    >>> upstream_task.targetname
    u'NetApplet'

    >>> thunderbird = productset.get(8)
    >>> upstream_task_id = upstream_task.id
    >>> upstream_task.product = thunderbird
    >>> upstream_task.targetname
    u'Mozilla Thunderbird'

    >>> thunderbird.name = 'thunderbird-ng'
    >>> thunderbird.displayname = 'Mozilla Thunderbird NG'

    # XXX: This flush_database_updates() shouldn't be needed because we
    # already have the transaction.commit() here, but without it
    # (flush_database_updates), the cronscript won't see the thunderbird name
    # change. See https://launchpad.net/products/launchpad/+bug/3989 for more
    # information.
    >>> flush_database_updates()
    >>> transaction.commit()

    >>> import subprocess
    >>> process = subprocess.Popen(
    ...     'cronscripts/update-bugtask-targetnamecaches.py -q', shell=True,
    ...     stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.PIPE)
    >>> (out, err) = process.communicate()
    >>> out, err
    ('', '')
    >>> process.returncode
    0

    # XXX: If we don't call flush_database_caches() here, we won't see the
    # changes made by the cronscript in objects we already have cached.
    >>> flush_database_caches()
    >>> transaction.commit()

    >>> bugtaskset.get(upstream_task_id).targetname
    u'Mozilla Thunderbird NG'

Target Uses Malone
------------------

Bug tasks have a flag, target_uses_malone, that says whether the bugtask
target uses Malone as its official bugtracker.

    >>> for bugtask in bug_one.bugtasks:
    ...     print "%-30s %s" % (bugtask.targetname, bugtask.target_uses_malone)
    Evolution                      True
    Mozilla Firefox                True
    Mozilla Firefox 1.0            True
    Mozilla Thunderbird NG         False
    Ubuntu                         True
    evolution (Ubuntu)             True
    mozilla-firefox (Ubuntu)       True
    Ubuntu Warty                   True
    mozilla-firefox (Debian)       False

Handling IntegrityError and ProgrammingError
--------------------------------------------

XXX: Brad Bollenbach, 2005-02-24: This bit testing the IntegrityError should be
higher up in the file (under the explanation about creating tasks), but I can't
figure out how to reset the connection properly after an IntegrityError is
raised. ARGH.

Note that a task filed on a specific distro release does *not* have its
distribution column set. In fact, a task must have exactly one of its product,
distribution or distrorelease fields set, otherwise the database integrity
constraints will be violated.

note that DatabaseError is a superclass of both IntegrityError and
ProgrammingError

    >>> from psycopg import DatabaseError
    >>> import sys
    >>> try: bad_task = bugtaskset.createTask(
    ...     bug=bug_one, distribution=ubuntu, distrorelease=warty,
    ...     owner=sabdfl, status=STATUS_UNCONFIRMED,
    ...     importance=IMPORTANCE_MEDIUM)
    ... except DatabaseError: print sys.exc_value
    ERROR:  new row for relation "bugtask" violates check constraint "bugtask_assignment_checks"
    <BLANKLINE>
    /*...*/ INSERT INTO BugTask ...

