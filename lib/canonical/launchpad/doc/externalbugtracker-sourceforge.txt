= ExternalBugTracker: SourceForge =

This covers the implementation of the ExternalBugTracker class for
SourceForge bugwatches.


== Basics ==

The ExternalBugTracker descendant class which implements methods for
updating bug watches on SourceForge bug trackers is
externalbugtracker.SourceForge, which implements IExternalBugTracker.

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     SourceForge)
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     new_bugtracker)
    >>> from canonical.launchpad.interfaces import (
    ...     BugTrackerType, IExternalBugTracker)
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> verifyObject(IExternalBugTracker,
    ...     SourceForge(new_bugtracker(BugTrackerType.SOURCEFORGE)))
    True

At present, the SourceForge support is disabled until the
ContinuousBugWatchChecking spec is fully implemented. As such,
get_external_bugtracker() will raise an error if a SourceForge bug
tracker is passed to it.

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     get_external_bugtracker)
    >>> from canonical.launchpad.interfaces import IPersonSet

    >>> sample_person = getUtility(IPersonSet).getByEmail('test@canonical.com')

    >>> example_bug_tracker = new_bugtracker(BugTrackerType.SOURCEFORGE)

    >>> get_external_bugtracker(example_bug_tracker)
    Traceback (most recent call last):
      ...
    UnknownBugTrackerTypeError: SOURCEFORGE


== Status Conversion ==

The SourceForge bug status/resolution combinations map to Launchpad bug
statuses. SourceForge.convertRemoteStatus() handles the conversion.

    >>> sourceforge = SourceForge(new_bugtracker(BugTrackerType.SOURCEFORGE))
    >>> sourceforge.convertRemoteStatus('Open').title
    'New'
    >>> sourceforge.convertRemoteStatus('Closed').title
    'Fix Released'
    >>> sourceforge.convertRemoteStatus('Pending').title
    'Incomplete'
    >>> sourceforge.convertRemoteStatus('Open:Accepted').title
    'Confirmed'
    >>> sourceforge.convertRemoteStatus('Open:Duplicate').title
    'Confirmed'
    >>> sourceforge.convertRemoteStatus('Open:Fixed').title
    'Fix Committed'
    >>> sourceforge.convertRemoteStatus('Open:Invalid').title
    'Invalid'
    >>> sourceforge.convertRemoteStatus('Open:Later').title
    'Confirmed'
    >>> sourceforge.convertRemoteStatus('Open:Out of Date').title
    'Invalid'
    >>> sourceforge.convertRemoteStatus('Open:Postponed').title
    'Confirmed'
    >>> sourceforge.convertRemoteStatus('Open:Rejected').title
    "Won't Fix"
    >>> sourceforge.convertRemoteStatus('Open:Remind').title
    'Confirmed'
    >>> sourceforge.convertRemoteStatus("Open:Won't Fix").title
    "Won't Fix"
    >>> sourceforge.convertRemoteStatus('Open:Works For Me').title
    'Invalid'
    >>> sourceforge.convertRemoteStatus('Closed:Accepted').title
    'Fix Committed'
    >>> sourceforge.convertRemoteStatus('Closed:Fixed').title
    'Fix Released'
    >>> sourceforge.convertRemoteStatus('Closed:Postponed').title
    "Won't Fix"
    >>> sourceforge.convertRemoteStatus('Pending:Postponed').title
    "Won't Fix"

If the status isn't something that our SourceForge ExternalBugTracker can
understand, Unknown will be returned and a warning logged.

    >>> sourceforge.convertRemoteStatus('eggs').title
    WARNING:...:Unknown status 'eggs'
    'Unknown'

UNKNOWN_REMOTE_STATUS maps to Unknown without generating a warning. This
handles the case where we've tried to probe for a bug but didn't succeed. For
example, if the bug number was invalid.

    >>> from canonical.launchpad.interfaces import UNKNOWN_REMOTE_STATUS
    >>> sourceforge.convertRemoteStatus(UNKNOWN_REMOTE_STATUS).title
    'Unknown'


== Initialization ==

Calling initializeRemoteBugDB() on our SourceForge instance and passing
it a set of remote bug IDs will fetch those bug IDs from the server and
file them in a local variable for later use.

We use a test-oriented implementation for the purposes of these tests,
which overrides ExternalBugTracker.urlopen() so that we don't have to
rely on a working network connection.

    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestSourceForge, print_bugwatches)
    >>> sourceforge = TestSourceForge(
    ...     new_bugtracker(BugTrackerType.SOURCEFORGE))
    >>> sourceforge.initializeRemoteBugDB([1722250])
    >>> sorted(sourceforge.bugs.keys())
    [1722250]

If a remote bug doesn't define the requisite data, an error will be
raised. We use a special sample bug, bug 0, which defines no status or
resolution, to demonstrate this:

    >>> sourceforge.initializeRemoteBugDB([0])
    Traceback (most recent call last):
      ...
    UnparseableBugData: Remote bug 0 does not define a status.


== Updating Bug Watches ==

First, we create some bug watches to test with. Example.com hosts a
SourceForge instance which has several bugs that we wish to watch:

    >>> from canonical.launchpad.interfaces import IBugSet

Launchpad.dev bug #10 is the same bug as reported in example.com bug
#1722250, so we add a watch against the remote bug.

    >>> example_bug = getUtility(IBugSet).get(10)
    >>> example_bugwatch = example_bug.addWatch(
    ...     example_bug_tracker, 1722250, sample_person)

    >>> print_bugwatches(example_bug_tracker.watches)
    Remote bug 1722250: None

Our SourceForge ExternalBugTracker can now process, and retrieve a
remote status for, the bug watch that we have created.

    >>> sourceforge = TestSourceForge(example_bug_tracker)
    >>> sourceforge.updateBugWatches(example_bug_tracker.watches)
    >>> print_bugwatches(example_bug_tracker.watches)
    Remote bug 1722250: Open:None

We now add some more watches against remote bugs in the example.com bug
tracker with a variety of statuses.

    >>> from canonical.launchpad.interfaces import IBugSet, IBugWatchSet
    >>> print_bugwatches(example_bug_tracker.watches,
    ...     sourceforge.convertRemoteStatus)
    Remote bug 1722250: New

    >>> remote_bugs = [
    ...     1722251,
    ...     1722252,
    ...     1722253,
    ...     1722254,
    ...     1722255,
    ...     1722256,
    ...     1722257,
    ...     1722258,
    ...     1722259,
    ... ]

    >>> bug_watch_set = getUtility(IBugWatchSet)
    >>> for remote_bug_id in remote_bugs:
    ...     bug_watch = bug_watch_set.createBugWatch(
    ...         bug=example_bug, owner=sample_person,
    ...         bugtracker=example_bug_tracker,
    ...         remotebug=str(remote_bug_id))

    >>> sourceforge.trace_calls = True
    >>> sourceforge.updateBugWatches(example_bug_tracker.watches)
    CALLED _getPage(u'support/tracker.php?aid=1722250')
    CALLED _getPage(u'support/tracker.php?aid=1722251')
    CALLED _getPage(u'support/tracker.php?aid=1722252')
    CALLED _getPage(u'support/tracker.php?aid=1722253')
    CALLED _getPage(u'support/tracker.php?aid=1722254')
    CALLED _getPage(u'support/tracker.php?aid=1722255')
    CALLED _getPage(u'support/tracker.php?aid=1722256')
    CALLED _getPage(u'support/tracker.php?aid=1722257')
    CALLED _getPage(u'support/tracker.php?aid=1722258')
    CALLED _getPage(u'support/tracker.php?aid=1722259')

The bug statuses have now been imported from the Example.com bug
tracker, so the bug watches should now have valid Launchpad bug
statuses:

    >>> print_bugwatches(example_bug_tracker.watches,
    ...     sourceforge.convertRemoteStatus)
    Remote bug 1722250: New
    Remote bug 1722251: Won't Fix
    Remote bug 1722252: Incomplete
    Remote bug 1722253: Won't Fix
    Remote bug 1722254: Invalid
    Remote bug 1722255: Confirmed
    Remote bug 1722256: Won't Fix
    Remote bug 1722257: Fix Committed
    Remote bug 1722258: Invalid
    Remote bug 1722259: Won't Fix
