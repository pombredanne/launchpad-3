= Answer Tracker Workflow =

The state of a question is tracked through its status attribute.
Six statuses are used to model a question lifecycle. These are defined
in the QuestionStatus enumeration.

    >>> from canonical.launchpad.interfaces import QuestionStatus
    >>> print "\n".join([status.name for status in QuestionStatus.items])
    OPEN
    NEEDSINFO
    ANSWERED
    SOLVED
    EXPIRED
    INVALID

Status change occurs in consequence of a user action. The possible
actions are defined in the QuestionAction enumeration.

    >>> from canonical.launchpad.interfaces import QuestionAction
    >>> print "\n".join([status.name for status in QuestionAction.items])
    REQUESTINFO
    GIVEINFO
    COMMENT
    ANSWER
    CONFIRM
    REJECT
    EXPIRE
    REOPEN
    SETSTATUS

There is a method available to execute each of these defined actions.

Let's define the actors that we are going to use to demonstrate the
Answer Tracker workflow. The 'No Privileges Person' will be the
submitter of questions, 'Sample Person' will be an answer contact for
the Ubuntu distribution, and 'Marilize Coetze' will be another user
providing support. Stub is a launchpad administrator that isn't also in
the Ubuntu Team that owns the distribution.

    >>> login('no-priv@canonical.com')

    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, ILanguageSet, IPersonSet)

    >>> personset = getUtility(IPersonSet)
    >>> sample_person = personset.getByEmail('test@canonical.com')
    >>> no_priv = personset.getByEmail('no-priv@canonical.com')
    >>> marilize = personset.getByEmail('marilize@hbd.com')
    >>> stub = personset.getByName('stub')

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> english = getUtility(ILanguageSet)['en']
    >>> sample_person.addLanguage(english)
    >>> ubuntu.addAnswerContact(sample_person)
    True

    # Sanity check: the admin isn't in the team owning the distribution.
    >>> stub.inTeam(ubuntu.owner)
    False

A question starts its lifecycle in the Open state.

    >>> from datetime import datetime, timedelta
    >>> from pytz import UTC
    >>> now = datetime.now(UTC)
    >>> new_question_args = {
    ...     'owner': no_priv,
    ...     'title': 'Unable to boot installer',
    ...     'description': "I've tried installing Ubuntu on a Mac. "
    ...     "But the installer never boots.",
    ...     'datecreated': now}
    >>> question = ubuntu.newQuestion(**new_question_args)
    >>> print question.status.title
    Open

From there, we have four representative scenarios.

== 1) Another user helps the submitter with his question ==

The most common scenario is where another user comes to help the
submitter and answers his question. This may involve exchanging
information with the submitter to clarify the question.

The requestInfo() method is used to ask the user for more information.
This method takes two mandatory parameters: the user making the question
and his question. It can also takes a 'datecreated' parameter specifying
the creation date of the question (which defaults to now).

    >>> question = ubuntu.newQuestion(**new_question_args)
    >>> now_plus_one_hour = now + timedelta(hours=1)
    >>> request_message = question.requestInfo(
    ...     sample_person, 'What is your Mac model?',
    ...     datecreated=now_plus_one_hour)

It returns the IQuestionMessage that was added to the question messages
history:

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import IQuestionMessage
    >>> verifyObject(IQuestionMessage, request_message)
    True
    >>> request_message == question.messages[-1]
    True
    >>> request_message.datecreated == now_plus_one_hour
    True
    >>> print request_message.owner.displayname
    Sample Person

The question message contains the action that was executed in the action
attribute and the status of the question after the action was executed in
the new_status attribute:

    >>> print request_message.action.name
    REQUESTINFO
    >>> print request_message.new_status.name
    NEEDSINFO

    >>> print request_message.text_contents
    What is your Mac model?

The subject of the message was generated automatically:

    >>> print request_message.subject
    Re: Unable to boot installer

The question is moved to the NEEDSINFO state and the datelastresponse
attribute is updated to the message timestamp.

    >>> print question.status.name
    NEEDSINFO
    >>> question.datelastresponse == now_plus_one_hour
    True

The question owner can reply to this information by using the giveInfo()
method which adds an IQuestionMessage with action GIVEINFO.

    >>> login('no-priv@canonical.com')
    >>> now_plus_two_hours = now + timedelta(hours=2)
    >>> reply_message = question.giveInfo(
    ...     "I have a PowerMac 7200.", datecreated=now_plus_two_hours)

    >>> print reply_message.action.name
    GIVEINFO
    >>> print reply_message.new_status.name
    OPEN
    >>> reply_message == question.messages[-1]
    True
    >>> print reply_message.owner.displayname
    No Privileges Person

The question is moved back to the OPEN state and the 'datelastquery'
attribute is updated to the message's creation date:

    >>> print question.status.name
    OPEN
    >>> question.datelastquery == now_plus_two_hours
    True

The other user has now enough information to give an answer to the
question. The giveAnswer() method is used for that purpose. Like the
requestInfo() method, it takes two mandatory parameters: the user
providing the answer and the answer itself.

    >>> login('test@canonical.com')
    >>> now_plus_three_hours = now + timedelta(hours=3)
    >>> answer_message = question.giveAnswer(
    ...     sample_person, "You need some configuration on the Mac side "
    ...     "to boot the installer on that model. Consult "
    ...     "https://help.ubuntu.com/community/Installation/OldWorldMacs "
    ...     "for all the details.", datecreated=now_plus_three_hours)
    >>> print answer_message.action.name
    ANSWER
    >>> print answer_message.new_status.name
    ANSWERED

After that action, the question's status is changed to ANSWERED and the
datelastresponse is updated to contain the date of the message.

    >>> print question.status.name
    ANSWERED
    >>> question.datelastresponse == now_plus_three_hours
    True

At that point, the question is considered answered, but we don't have
feedback from the user on whether it solved his problem or not. If it
doesn't the user can reopen the question. The reopen() method is used
for that purpose.

    >>> login('no-priv@canonical.com')
    >>> tomorrow = now + timedelta(days=1)
    >>> reopen_message = question.reopen(
    ...     "I installed BootX and I've progressed somewhat. I now get the "
    ...     "boot screen. But soon after the Ubuntu progress bar appears, I "
    ...     "get a OOM Killer message appearing on the screen.",
    ...      datecreated=tomorrow)
    >>> print reopen_message.action.name
    REOPEN
    >>> print reopen_message.new_status.name
    OPEN
    >>> print reopen_message.owner.displayname
    No Privileges Person

This moves back the question to the OPEN state and the datelastquery
attribute is updated to the message creation date.

    >>> print question.status.name
    OPEN
    >>> question.datelastquery == tomorrow
    True

The giveAnswer() will again be used to give an answer.

    >>> login('test@canonical.com')
    >>> tomorrow_plus_one_hour = tomorrow + timedelta(hours=1)
    >>> answer2_message = question.giveAnswer(
    ...     marilize, "You probably do not have enough RAM to use the "
    ...     "graphical installer. You can try the alternate CD with the "
    ...     "text installer.")

This again moves the question to the ANSWERED state.

    >>> print question.status.name
    ANSWERED

The question owner will hopefully come back to confirm that his
problem is solved. He can specify which answer message helped him
solved his problem. The confirmAnswer() method is used for that
purpose.

    >>> login('no-priv@canonical.com')
    >>> two_weeks_from_now = now + timedelta(days=14)
    >>> confirm_message = question.confirmAnswer(
    ...     "I upgraded to 512M of RAM (found on eBay) and I've "
    ...     "succesfully managed to install Ubuntu. Thanks for all the help.",
    ...     datecreated=two_weeks_from_now, answer=answer_message)
    >>> print confirm_message.action.name
    CONFIRM
    >>> print confirm_message.new_status.name
    SOLVED
    >>> print confirm_message.owner.displayname
    No Privileges Person

The question is moved to the SOLVED state, the message that solved
the question is saved in the answer attribute, the date_solved
and answerer attributes are also updated.

    >>> print question.status.name
    SOLVED
    >>> question.date_solved == two_weeks_from_now
    True
    >>> print question.answerer.displayname
    Sample Person
    >>> question.answer == answer_message
    True


== 2) Self-answer ==

Another scenario is for the case when the user comes back to give the
solution to the question himself. The giveAnswer() method is also used
for that case. The question owner can choose a best answer message
later on. The workflow permits the question owner to choose an answer
before or after the question status is set to SOLVED.

The question owner creates a question.

    >>> question = ubuntu.newQuestion(**new_question_args)

The question answer provides an answer that eludes to a decision
the question owner must make.

    >>> login('test@canonical.com')
    >>> tomorrow_plus_one_hour = tomorrow + timedelta(hours=1)
    >>> alt_answer_message = question.giveAnswer(
    ...     marilize, "Are you using a pre-G3 Mac? They are very difficult "
    ...     "to install to. You must mess with the hardware to trick "
    ...     "the core chips to let it install. You may not want to do this.")

The question owner logs in, and explains that he has researched the
problem, and come to a solution.

    >>> login('no-priv@canonical.com')
    >>> self_answer_message = question.giveAnswer(
    ...     no_priv, "I found some instructions on the Wiki on how to "
    ...     "install BootX to boot the installation CD on OldWorld Mac: "
    ...     "https://help.ubuntu.com/community/Installation/OldWorldMacs "
    ...     "This is complicated and since it's a very old machine, not "
    ...     "worth the trouble.",
    ...     datecreated=now_plus_one_hour)

In that case, the question owner is considered to have given
information that the problem is solved and the question is moved to
the SOLVED state. The 'answerer' attribute will be the question owner,
the 'date_solved' date of the message, but the 'answer' attribute
will None.

    >>> print self_answer_message.action.name
    CONFIRM
    >>> print self_answer_message.new_status.name
    SOLVED

    >>> print question.status.name
    SOLVED
    >>> print question.answerer.displayname
    No Privileges Person
    >>> question.date_solved == now_plus_one_hour
    True
    >>> question.answer is None
    True

The question owner can still specify which message helped him solved
his problem. The confirmAnswer() method is used when the question
owner chooses another user's answer as a best answer. The status
will remain SOLVED. The 'answerer' attribute will be the message
owner, and the 'answer' will be the message. The question's
'date_solved' attribute will be the date of the answer message.

    >>> confirm_message = question.confirmAnswer(
    ...     "Thanks Marilize for your help. I don't think I'll put Ubuntu "
    ...     "Ubuntu on my Mac.",
    ...     datecreated=now_plus_one_hour, answer=alt_answer_message)
    >>> print confirm_message.action.name
    CONFIRM
    >>> print confirm_message.new_status.name
    SOLVED
    >>> print confirm_message.owner.displayname
    No Privileges Person

    >>> print question.status.name
    SOLVED
    >>> print question.answerer.displayname
    Marilize Coetzee
    >>> question.answer == alt_answer_message
    True
    >>> question.date_solved == now_plus_one_hour
    True


== 3) The question expires ==

Another case is when nobody comes to answer the message, either because
the question is too complex or too vague. These questions can be expired
by using the expireQuestion() method. (See answer-tracker-expiration.txt
for the documentation of the cron script handling this task.)

    >>> login('no-priv@canonical.com')
    >>> question = ubuntu.newQuestion(**new_question_args)
    >>> expire_message = question.expireQuestion(
    ...     sample_person, "There was no activity on this question for two "
    ...     "weeks and this question was expired. If you are still having "
    ...     "this problem you should reopen the question and provide more "
    ...     "information about your problem.",
    ...     datecreated=two_weeks_from_now)
    >>> print expire_message.action.name
    EXPIRE
    >>> print expire_message.new_status.name
    EXPIRED

The question is moved to the EXPIRED state and the 'datelastresponse'
attribute is updated to the message creation date.

    >>> print question.status.name
    EXPIRED
    >>> question.datelastresponse == two_weeks_from_now
    True

If the user comes back and provide more information, the question will be
reopened.

    >>> much_later = now + timedelta(days=30)
    >>> reopen_message = question.reopen(
    ...     "I'm installing on PowerMac 7200/120 with 32 Megs of RAM. After "
    ...     "I insert the CD and restart the computer, it boots straight "
    ...     "into Mac OS/9 instead of booting the installer.",
    ...     datecreated=much_later)
    >>> print reopen_message.action.name
    REOPEN

The question status is changed back to OPEN and the 'datelastquery'
attribute is updated.

    >>> print question.status.name
    OPEN
    >>> question.datelastquery == much_later
    True


== 4) The question is invalid ==

Another scenario to handle is the case where the user posts a message
that isn't really appropriate for the Answer Tracker like a SPAM
message or a request for Ubuntu CDs.

    >>> spam_question = ubuntu.newQuestion(
    ...     no_priv, 'CDs', 'Please send 10 Ubuntu Dapper CDs.',
    ...     datecreated=now)

The reject() method is used for such purpose. Only an answer contact,
a product or distribution owner, or an administrator can reject a question.

The canReject() method can be used to test if a user is allowed to
reject the question. It takes as parameter the user who would reject the
question:

    >>> spam_question.canReject(no_priv)
    False
    >>> spam_question.canReject(marilize)
    False

    # Answer contact
    >>> spam_question.canReject(sample_person)
    True
    >>> spam_question.canReject(ubuntu.owner)
    True

    # Administrator
    >>> spam_question.canReject(stub)
    True

    >>> login(marilize.preferredemail.email)
    >>> spam_question.reject(
    ...     marilize, 'Use https://shipit.launchpad.net/ to order CD')
    Traceback (most recent call last):
      ...
    Unauthorized: ...

The reject() method takes a comment explaining the reason behind the
rejection.

    >>> login('test@canonical.com')
    >>> reject_message = spam_question.reject(
    ...     sample_person, 'Use https://shipit.launchpad.net/ to order CD',
    ...     datecreated=now_plus_one_hour)
    >>> print reject_message.action.name
    REJECT
    >>> print reject_message.new_status.name
    INVALID

After rejection, the question is marked as invalid and the
'datelastresponse' attribute is updated.

    >>> print spam_question.status.name
    INVALID
    >>> spam_question.datelastresponse == now_plus_one_hour
    True

The rejection message is also considered as answering the message, so the
date_solved, answerer and answer attributes are also updated.

    >>> spam_question.answer == reject_message
    True
    >>> print spam_question.answerer.displayname
    Sample Person
    >>> spam_question.date_solved == now_plus_one_hour
    True

== Other scenarios ==

Many other scenarios are possible and some of those are probably more
common than the ones we exposed. For example, it is likely that a user
will answer directly a question (without asking for other
information first). Or that the question user won't come back to confirm
that an answer solved his problem. Another likely scenario is where
the question will expire in the NEEDSINFO state when the question owner
doesn't reply to the request for more information. All of these
scenarios are covered by this API. It is not necessary to cover all
these various possibilities here.
(The ../interfaces/ftests/test_question_workflow.py functional test
exercices all the various possible transitions.)

== Changing the question status ==

It is not possible to change the status attribute directly:

    >>> login('foo.bar@canonical.com')
    >>> question = ubuntu.newQuestion(**new_question_args)
    >>> question.status = QuestionStatus.INVALID
    Traceback (most recent call last):
      ...
    ForbiddenAttribute...

A user which has launchpad.Admin permission on the question, can set the
question status to an arbitrary value by using the setStatus() method.
That method takes as parameters the new status and a comment explaining
the status change.

    >>> old_datelastquery = question.datelastquery
    >>> login(stub.preferredemail.email)
    >>> status_change_message = question.setStatus(
    ...      stub, QuestionStatus.INVALID, 'Changed status to INVALID',
    ...     datecreated=now_plus_one_hour)

The method returns the IQuestionMessage recording the change:

    >>> print status_change_message.action.name
    SETSTATUS
    >>> print status_change_message.new_status.name
    INVALID
    >>> print question.status.name
    INVALID

The status change updates the datelastresponse attribute:

    >>> question.datelastresponse == now_plus_one_hour
    True
    >>> question.datelastquery == old_datelastquery
    True

If an answer was present on the question, the status change also clears
the answer and date_solved attributes.

    >>> msg = question.setStatus(stub, QuestionStatus.OPEN, 'Status change.')
    >>> answer_message = question.giveAnswer(sample_person, 'Install BootX.')

    >>> login('no-priv@canonical.com')
    >>> msg = question.confirmAnswer('This worked.', answer=answer_message)
    >>> question.date_solved is not None
    True
    >>> question.answer == answer_message
    True

    >>> login(stub.preferredemail.email)
    >>> status_change_message = question.setStatus(
    ...     stub, QuestionStatus.OPEN, 'Reopen the question',
    ...     datecreated=now_plus_one_hour)

    >>> question.date_solved is None
    True
    >>> question.answer is None
    True

But when the status is changed by a user who doesn't have the
launchpad.Admin permission, an Unauthorized error is thrown:

    >>> login('test@canonical.com')
    >>> question.setStatus(sample_person, QuestionStatus.EXPIRED, 'Expire.')
    Traceback (most recent call last):
      ...
    Unauthorized...

== Adding Comments Without Changing the Status ==

There is an addComment() method that can be use to add a message to the
question without changing its status.

    >>> login('no-priv@canonical.com')
    >>> old_status = question.status
    >>> old_datelastresponse = question.datelastresponse
    >>> old_datelastquery = question.datelastquery
    >>> comment = question.addComment(
    ...     no_priv, 'This is a comment.',
    ...     datecreated=now_plus_two_hours)

    >>> print comment.action.name
    COMMENT
    >>> comment.new_status == old_status
    True

This method does not update the datelastresponse and datelastquery
attributes.

    >>> question.datelastresponse == old_datelastresponse
    True
    >>> question.datelastquery == old_datelastquery
    True

== Events ==

Each of the workflow methods will trigger a SQLObjectCreatedEvent for
the message they create and a SQLObjectModifiedEvent for the question.

    # Register an event listener that will print event it receives.
    >>> from canonical.launchpad.event.interfaces import (
    ...     ISQLObjectCreatedEvent, ISQLObjectModifiedEvent)
    >>> from canonical.launchpad.interfaces import IQuestion
    >>> from canonical.launchpad.ftests.event import TestEventListener
    >>> def print_event(object, event):
    ...     print "Received %s on %s" % (
    ...         event.__class__.__name__.split('.')[-1],
    ...         object.__class__.__name__.split('.')[-1])
    >>> questionmessage_event_listener = TestEventListener(
    ...     IQuestionMessage, ISQLObjectCreatedEvent, print_event)
    >>> question_event_listener = TestEventListener(
    ...     IQuestion, ISQLObjectModifiedEvent, print_event)

Changing the status triggers the event:

    >>> login(stub.preferredemail.email)
    >>> msg = question.setStatus(stub, QuestionStatus.EXPIRED, 'Status change.')
    Received SQLObjectCreatedEvent on QuestionMessage
    Received SQLObjectModifiedEvent on Question

Example of a workflow method that triggers the events:

    >>> msg = question.reject(stub, 'Close this question.')
    Received SQLObjectCreatedEvent on QuestionMessage
    Received SQLObjectModifiedEvent on Question

Even only adding a comment without changing the status will send
these events.

    >>> login('test@canonical.com')
    >>> msg = question.addComment(sample_person, 'A comment')
    Received SQLObjectCreatedEvent on QuestionMessage
    Received SQLObjectModifiedEvent on Question

    # Cleanup
    >>> questionmessage_event_listener.unregister()
    >>> question_event_listener.unregister()

== Reopenings ==

Whenever a question considered answered (in the SOLVED or INVALID state)
is reopened, a QuestionReopening is created.

    # Let's register an event listener to notify us whenever a
    # QuestionReopening is created.
    >>> from canonical.launchpad.interfaces import IQuestionReopening
    >>> reopening_event_listener = TestEventListener(
    ...     IQuestionReopening, ISQLObjectCreatedEvent, print_event)

The most common use case is when a user confirms a solution, and then
comes back to say that it doesn't work in fact.

    >>> login('no-priv@canonical.com')
    >>> question = ubuntu.newQuestion(**new_question_args)
    >>> answer_message = question.giveAnswer(
    ...    sample_person, "You need some setup on the Mac side. "
    ...    "Follow the instructions at "
    ...     "https://help.ubuntu.com/community/Installation/OldWorldMacs",
    ...     datecreated=now_plus_one_hour)
    >>> confirm_message = question.confirmAnswer(
    ...     "I've installed BootX and the installer now boot properly.",
    ...     answer=answer_message, datecreated=now_plus_two_hours)
    >>> reopen_message = question.reopen(
    ...     "Actually, altough the installer boots properly. I'm not able "
    ...     "to pass beyond the partitioning.",
    ...     datecreated=now_plus_three_hours)
    Received SQLObjectCreatedEvent on QuestionReopening

The reopening record is available through the reopenings attribute.

    >>> list(question.reopenings)
    [<QuestionReopening...>]
    >>> reopening = question.reopenings[0]
    >>> verifyObject(IQuestionReopening, reopening)
    True

The reopening contain the date of the reopening in the datecreated
attribute and the person who made the reopening in the reopener
attribute.

    >>> reopening.datecreated == now_plus_three_hours
    True
    >>> print reopening.reopener.displayname
    No Privileges Person

It contains the question prior answerer, datecreated, as well as the
prior status in the priorstate attribute:

    >>> print reopening.answerer.displayname
    Sample Person
    >>> reopening.date_solved == now_plus_two_hours
    True
    >>> print reopening.priorstate.name
    SOLVED

Another example of a reopening, would be when the question status is set
back to OPEN after having been rejected.

    >>> login('test@canonical.com')
    >>> question = ubuntu.newQuestion(**new_question_args)
    >>> reject_message = question.reject(
    ...     sample_person, 'This is a frivoulous question.',
    ...     datecreated=now_plus_one_hour)

    >>> login(stub.preferredemail.email)
    >>> status_change_message = question.setStatus(
    ...     stub, QuestionStatus.OPEN, 'Disregard previous rejection. '
    ...     'Sample Person was having a bad day.',
    ...     datecreated=now_plus_two_hours)
    Received SQLObjectCreatedEvent on QuestionReopening

    >>> reopening = question.reopenings[0]
    >>> print reopening.reopener.name
    stub
    >>> reopening.datecreated == now_plus_two_hours
    True
    >>> print reopening.answerer.displayname
    Sample Person
    >>> reopening.date_solved == now_plus_one_hour
    True
    >>> print reopening.priorstate.name
    INVALID

    # Cleanup
    >>> reopening_event_listener.unregister()

== Using an IMessage as Explanation ==

In all the workflow methods, it is possible to pass an IMessage instead of
a string.

    >>> from canonical.launchpad.interfaces import IMessageSet
    >>> login('test@canonical.com')
    >>> messageset = getUtility(IMessageSet)
    >>> question = ubuntu.newQuestion(**new_question_args)
    >>> reject_message = messageset.fromText(
    ...     'Reject', 'Because I feel like it.', sample_person)
    >>> question_message = question.reject(sample_person,reject_message)
    >>> print question_message.subject
    Reject
    >>> print question_message.text_contents
    Because I feel like it.
    >>> question_message.rfc822msgid == reject_message.rfc822msgid
    True

The IMessage owner must be the same than the person passed to the workflow
method.

    >>> login(stub.preferredemail.email)
    >>> question.setStatus(stub, QuestionStatus.OPEN, reject_message)
    Traceback (most recent call last):
      ...
    AssertionError...
