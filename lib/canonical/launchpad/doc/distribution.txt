Distributions
=============

From the DerivationOverview spec
<https://launchpad.canonical.com/DerivationOverview>:

    A distribution of GNU/Linux comprises a set of packages, an installer,
    possibly a live-CD, some amount of metadata associated with the arrangement
    of those elements and also a lot of information on managing it.

In Launchpad, one distribution is mapped to one row in the Distribution table.
To retrieve a distribution, use the IDistributionSet utility. If you've already
used IPersonSet to retrieve a Person, or IBugTaskSet to retrieve a task, this
syntax should look familiar.

The IDistributionSet utility is accessed in the usual fashion:

    >>> from zope.component import getUtility
    >>> from zope.interface.verify import verifyObject
    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> from canonical.lp.dbschema import (
    ...     PackagePublishingPocket, MirrorSpeed, MirrorContent,
    ...     MirrorPulseType)
    >>> distroset = getUtility(IDistributionSet)

To retrieve a specific distribution, use IDistributionSet.get:

    >>> ubuntu = distroset.get(1)
    >>> print ubuntu.name
    ubuntu

Or, to grab one by name, use:

    >>> gentoo = distroset.getByName("gentoo")

Let's make sure a distribution object properly implements its interfaces.

    >>> IDistribution.providedBy(gentoo)
    True
    >>> verifyObject(IDistribution, gentoo)
    True


Once you've got a distribution, you can retrieve a source package if you
have a SourcePackageName object for it.

    >>> from canonical.launchpad.database.sourcepackagename import (
    ...                                          SourcePackageName)
    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSourcePackage,
    ...     IDistributionSourcePackageRelease)

    >>> evo = SourcePackageName.byName("evolution")
    >>> evo_ubuntu = ubuntu.getSourcePackage(evo)
    >>> print evo_ubuntu.name
    evolution

    >>> IDistributionSourcePackage.providedBy(evo_ubuntu)
    True

    >>> from canonical.launchpad.database.sourcepackagerelease import (
    ...                                           SourcePackageRelease)
    >>> sourcepackagerelease = SourcePackageRelease.selectOneBy(
    ...     sourcepackagenameID=evo.id, version='1.0')
    >>> sourcepackagerelease.name
    u'evolution'

    >>> evo_ubuntu_rel = ubuntu.getSourcePackageRelease(
    ...                    sourcepackagerelease)
    >>> IDistributionSourcePackageRelease.providedBy(evo_ubuntu_rel)
    True

You can also get a release by name:

    >>> hoary = ubuntu.getRelease("hoary")
    >>> print hoary.name
    hoary

Or by version:

    >>> v504 = ubuntu.getRelease("5.04")
    >>> print v504.name
    hoary

You can list development distroreleases:

    >>> devdists = ubuntu.getDevelopmentReleases()
    >>> for devdist in devdists:
    ...     print devdist.name
    hoary

Guessing package names
======================

IDistribution allows us to retrieve packages by name, returning a tuple
of Source/BinaryPackageName instances published within this
distribution:

    >>> from canonical.launchpad.interfaces import (
    ...     ISourcePackageName, IBinaryPackageName)
    >>> source_name, bin_name = ubuntu.guessPackageNames('pmount')
    >>> ISourcePackageName.providedBy(source_name)
    True
    >>> IBinaryPackageName.providedBy(bin_name)
    True
    >>> source_name.name, bin_name.name
    (u'pmount', u'pmount')

Prevents wrong usage by and assertion error:

    >>> name_tuple = ubuntu.guessPackageNames(ubuntu)
    Traceback (most recent call last):
    ...
    AssertionError: Expected string. Got: <Distribution ...>

Raises NotFoundError for following conditions:

    >>> name_tuple = ubuntu.guessPackageNames('@#$')
    Traceback (most recent call last):
    ...
    NotFoundError: 'Invalid package name: @#$'

    >>> name_tuple = ubuntu.guessPackageNames('zeca')
    Traceback (most recent call last):
    ...
    NotFoundError: 'Unknown package: zeca'

    >>> name_tuple = ubuntu.guessPackageNames('1234')
    Traceback (most recent call last):
    ...
    NotFoundError: 'Unknown package: 1234'

It also raises NotFoundError on distributions with no releases:

    >>> source_name, bin_name = gentoo.guessPackageNames('pmount')
    Traceback (most recent call last):
    ...
    NotFoundError: u"Gentoo has no releases; 'pmount' was never published in it"

Even if we add a release to Gentoo, no packages have ever been published
in it, and therefore guessPackageNames will still fail:

    >>> from canonical.launchpad.interfaces import IDistroReleaseSet
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> distroreleaseset = getUtility(IDistroReleaseSet)
    >>> gentoo_two = distroreleaseset.new(gentoo, 'gentoo-two', 'Gentoo Two',
    ...                                   'Gentoo Two Dot Oh', 'Gentoo 2', 'G2',
    ...                                   '2.0', None, gentoo.owner)
    >>> source_name, bin_name = gentoo.guessPackageNames('pmount')
    Traceback (most recent call last):
    ...
    NotFoundError: u'Package pmount not published in Gentoo'

It also works if we look for a package name which is the name of both
binary and source packages but for which only the source is published:

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> debian = getUtility(ILaunchpadCelebrities).debian
    >>> source_name, bin_name = debian.guessPackageNames('alsa-utils')
    >>> print bin_name
    None
    >>> source_name.name
    u'alsa-utils'

Distribution Sorting
====================

If you ask for all the distributions in the DistributionSet you should get
Ubuntu first and the rest alphabetically:

    >>> for item in distroset:
    ...     print item.name
    ubuntu
    kubuntu
    debian
    gentoo
    guadalinex
    redhat
    ubuntutest


Searching for DistributionSourcePackages
----------------------------------------

The distribution also allows you to look for source packages that match
a certain string through the magic of fti. For instance:

    >>> packages = ubuntu.searchSourcePackages("mozilla")
    >>> print len(packages)
    1

The search also matches on exact package names which fti doesn't like,
and even on substrings:

    >>> packages = ubuntu.searchSourcePackages("linux-source-2.6.15")
    >>> print len(packages)
    1
    >>> packages = ubuntu.searchSourcePackages("nux-sour")
    >>> print len(packages)
    1


Finding distroreleases and pockets from distribution names
----------------------------------------------------------

A distribution knows what distroreleases it has. Those distroreleases have
pockets which have suffixes used by the archive publisher. Because we sometimes
need to talk about distroreleases such as ubuntu/hoary-security we need some
way to decompose that into the distrorelease and the pocket. Distribution
can do that for us.

If we ask for a totally unknown distrorelease, we raise NotFoundError
    >>> ubuntu.getDistroReleaseAndPocket('unknown')
    Traceback (most recent call last):
    ...
    NotFoundError: 'unknown'

If we ask for a plain distrorelease, it should come back with the RELEASE
pocket as the pocket.
    >>> dr, pocket = ubuntu.getDistroReleaseAndPocket('hoary')
    >>> print dr.name
    hoary
    >>> print pocket.name
    RELEASE

If we ask for a security pocket in a known distrorelease it should come out
on the other side.
    >>> dr, pocket = ubuntu.getDistroReleaseAndPocket('hoary-security')
    >>> print dr.name
    hoary
    >>> print pocket.name
    SECURITY

Find the backports pocket, too:
    >>> dr, pocket = ubuntu.getDistroReleaseAndPocket('hoary-backports')
    >>> print dr.name
    hoary
    >>> print pocket.name
    BACKPORTS

If we ask for a valid distrorelease which doesn't have a given pocket it should
raise NotFoundError for us
    >>> ubuntu.getDistroReleaseAndPocket('hoary-bullshit')
    Traceback (most recent call last):
    ...
    NotFoundError: 'hoary-bullshit'



Upload related stuff
--------------------

When uploading to a distribution we need to query its uploaders. Each
uploader record is in fact a DistroComponentUploader record which
tells us what component is uploadable to by what person or group of
people.

   >>> for dcu in sorted(ubuntu.uploaders,
   ...                   key=lambda dcu: dcu.component.name):
   ...     assert dcu.distribution == ubuntu
   ...     print dcu.component.name
   ...     print dcu.uploader.displayname
   main
   Ubuntu Team
   restricted
   Ubuntu Team
   universe
   Ubuntu Team

When processing an upload we may want to find a file (E.g. if an
incomplete source is uploaded).

    >>> ubuntu.getFileByName('mozilla-firefox_0.9_i386.deb').getURL()
    'http://localhost:58000/40/mozilla-firefox_0.9_i386.deb'
    >>> ubuntu.getFileByName(
    ...     'mozilla-firefox_0.9_i386.deb', source=False).getURL()
    'http://localhost:58000/40/mozilla-firefox_0.9_i386.deb'
    >>> ubuntu.getFileByName('mozilla-firefox_0.9_i386.deb', binary=False)
    Traceback (most recent call last):
    ...
    NotFoundError: 'mozilla-firefox_0.9_i386.deb'
    >>> ubuntu.getFileByName('', source=False, binary=False)
    Traceback (most recent call last):
    ...
    AssertionError: searching in an explicitly empty space is pointless


Launchpad Usage
---------------

A distribution can specify if it uses Malone or Rosetta officially.
Ubuntu uses both Malone and Rosetta:

    >>> ubuntu = getUtility(ILaunchpadCelebrities).ubuntu
    >>> ubuntu.official_malone
    True
    >>> ubuntu.official_rosetta
    True

While Debian uses neither:

    >>> debian.official_malone
    False
    >>> debian.official_rosetta
    False

Gentoo only uses Malone

    >>> print gentoo.official_malone
    True
    >>> print gentoo.official_rosetta
    False



Specification Listings
======================

We should be able to get lists of specifications in different states
related to a distro.

Basically, we can filter by completeness, and by whether or not the spec is
informational.

 >>> kubuntu = distroset.getByName("kubuntu")

 >>> from canonical.lp.dbschema import SpecificationFilter

First, there should be one informational spec for kubuntu, but it is
complete so it will not show up unless we explicitly ask for complete specs:

 >>> filter = [SpecificationFilter.INFORMATIONAL]
 >>> kubuntu.specifications(filter=filter).count()
 0
 >>> filter = [SpecificationFilter.INFORMATIONAL,
 ...           SpecificationFilter.COMPLETE]
 >>> kubuntu.specifications(filter=filter).count()
 1


There are 2 completed specs for Kubuntu:

 >>> filter = [SpecificationFilter.COMPLETE]
 >>> for spec in kubuntu.specifications(filter=filter):
 ...    print spec.name, spec.is_complete
 thinclient-local-devices True
 usplash-on-hibernation True


And there are four incomplete specs:

 >>> filter = [SpecificationFilter.INCOMPLETE]
 >>> for spec in kubuntu.specifications(filter=filter):
 ...    print spec.name, spec.is_complete
 cluster-installation False
 revu False
 kde-desktopfile-langpacks False
 krunch-desktop-plan False


If we ask for all specs, we get them in the order of priority.

 >>> filter = [SpecificationFilter.ALL]
 >>> for spec in kubuntu.specifications(filter=filter):
 ...    print spec.priority.title, spec.name
 Essential cluster-installation
 High revu
 Medium thinclient-local-devices
 Low usplash-on-hibernation
 Undefined kde-desktopfile-langpacks
 Not krunch-desktop-plan


And if we ask just for specs, we get the incomplete ones.

 >>> for spec in kubuntu.specifications():
 ...     print spec.name, spec.is_complete
 cluster-installation False
 revu False
 kde-desktopfile-langpacks False
 krunch-desktop-plan False

We can filter for specifications that contain specific text:

 >>> for spec in kubuntu.specifications(filter=['package']):
 ...     print spec.name
 revu

We can get only valid specs (those that are not obsolete or superseded):

 >>> from canonical.lp.dbschema import SpecificationStatus
 >>> from canonical.launchpad.ftests import login
 >>> login('mark@hbd.com')
 >>> for spec in kubuntu.specifications():
 ...     if spec.name in ['cluster-installation', 'revu']:
 ...         spec.status = SpecificationStatus.OBSOLETE
 ...     if spec.name in ['krunch-desktop-plan']:
 ...         spec.status = SpecificationStatus.SUPERSEDED
 ...     shim = spec.updateLifecycleStatus(spec.owner)
 >>> flush_database_updates()
 >>> for spec in kubuntu.valid_specifications:
 ...     print spec.name
 kde-desktopfile-langpacks


