= RESTful Web Services =

LAZR builds on Zope conventions to make it easy to expose your model
objects as RESTful HTTP resources. I'll demonstrate these features by
defining a model for managing recipes, and then publishing the model
objects as resources through a web service.

# XXX leonardr 2008-04-23 bug=221037: This test should be moved to
# launchpad/doc and made to run without layers. It registers resource
# classes that pollute generated WADL documents in the pagetests.

== Example model objects ==

Here's the interface for a simple set of model objects. This is the
kind of model object you'd find in any Zope application, with no
special knowledge of web services. The model is of a group of
cookbooks. Each cookbook has a known person as the author. Each
cookbook contains multiple recipes. A recipe is a recipe _for_ a dish,
and two or more cookbooks may provide different recipes for the same
dish. Users may comment on cookbooks and on individual recipes.

    # All classes defined in this test are new-style classes.
    >>> __metaclass__ = type

    >>> from zope.interface import Interface, Attribute
    >>> from zope.schema import Int, Text, TextLine, Object

    >>> class IAuthor(Interface):
    ...     name = TextLine(title=u"Name", required=True)

    >>> class ICommentTarget(Interface):
    ...     comments = Attribute('List of comments about this object.')

    >>> class IComment(Interface):
    ...     target = Attribute('The object containing this comment.')
    ...     text = TextLine(title=u"Text", required=True)

    >>> class ICookbook(ICommentTarget):
    ...     name = TextLine(title=u"Name", required=True)
    ...     author = Object(schema=IAuthor)
    ...     recipes = Attribute("List of recipes published in this cookbook.")

    >>> class IDish(Interface):
    ...     name = TextLine(title=u"Name", required=True)
    ...     recipes = Attribute("List of recipes for this dish.")

    >>> class IRecipe(ICommentTarget):
    ...     id = Int(title=u"Unique ID", required=True)
    ...     dish = Object(schema=IDish)
    ...     cookbook = Object(schema=ICookbook)
    ...     instructions = Text(title=u"How to prepare the recipe.",
    ...         required=True)

Here's the interface for the 'set' objects that manage the authors,
cookbooks, and dishes. The inconsistent naming is intentional.

    >>> class IAuthorSet(Interface):
    ...     def getAllAuthors(self):
    ...         "Get all authors."
    ...
    ...     def getAuthor(self, name):
    ...         "Retrieve a single author by name."

    >>> class ICookbookSet(Interface):
    ...     def getAll(self):
    ...         "Get all cookbooks."
    ...
    ...     def get(self, name):
    ...         "Retrieve a single cookbook by name."
    ...
    ...     def findRecipes(self, name):
    ...         "Find recipes with a given name, across cookbooks."

    >>> class IDishSet(Interface):
    ...     def getAll(self):
    ...         "Get all dishes."
    ...
    ...     def get(self, name):
    ...         "Retrieve a single dish by name."


Here are simple implementations of IAuthor, IComment, ICookbook, IDish,
and IRecipe.

    >>> from zope.interface import implements
    >>> from zope.security.checker import CheckerPublic
    >>> from canonical.lazr.security import protect_schema

    >>> class Author:
    ...     implements(IAuthor)
    ...     def __init__(self, name):
    ...         self.name = name
    >>> protect_schema(Author, IAuthor, write_permission=CheckerPublic)

    >>> class Comment(object):
    ...     implements(IComment)
    ...     def __init__(self, target, text):
    ...         self.target = target
    ...         self.text = text
    ...         self.target.comments.append(self)
    >>> protect_schema(Comment, IComment, write_permission=CheckerPublic)

    >>> class Cookbook:
    ...     implements(ICookbook)
    ...     def __init__(self, name, author):
    ...         self.name = name
    ...         self.author = author
    ...         self.recipes = []
    ...         self.comments = []
    >>> protect_schema(Cookbook, ICookbook, write_permission=CheckerPublic)

    >>> class Dish:
    ...     implements(IDish)
    ...     def __init__(self, name):
    ...         self.name = name
    ...         self.recipes = []
    >>> protect_schema(Dish, IDish, write_permission=CheckerPublic)

    >>> class Recipe:
    ...     implements(IRecipe)
    ...     def __init__(self, id, cookbook, dish, instructions):
    ...         self.id = id
    ...         self.cookbook = cookbook
    ...         self.cookbook.recipes.append(self)
    ...         self.dish = dish
    ...         self.dish.recipes.append(self)
    ...         self.instructions = instructions
    ...         self.comments = []
    >>> protect_schema(Recipe, IRecipe, write_permission=CheckerPublic)

Here are the "model objects" themselves:

    >>> A1 = Author(u"Julia Child")
    >>> A2 = Author(u"Irma S. Rombauer")
    >>> A3 = Author(u"James Beard")
    >>> AUTHORS = [A1, A2, A3]

    >>> C1 = Cookbook(u"Mastering the Art of French Cooking", A1)
    >>> C2 = Cookbook(u"The Joy of Cooking", A2)
    >>> C3 = Cookbook(u"James Beard's American Cookery", A3)
    >>> COOKBOOKS = [C1, C2, C3]

    >>> D1 = Dish("Roast chicken")
    >>> C1_D1 = Recipe(1, C1, D1, u"You can always judge...")
    >>> C2_D1 = Recipe(2, C2, D1, u"Draw, singe, stuff, and truss...")
    >>> C3_D1 = Recipe(3, C3, D1, u"A perfectly roasted chicken is...")

    >>> D2 = Dish("Baked beans")
    >>> C2_D2 = Recipe(4, C2, D2, "Preheat oven to...")
    >>> C3_D2 = Recipe(5, C3, D2, "Without doubt the most famous...")

    >>> D3 = Dish("Foies de voilaille en aspic")
    >>> C1_D3 = Recipe(6, C1, D3, "Chicken livers sauteed in butter...")

    >>> COM1 = Comment(C2_D1, "Clear and concise.")
    >>> COM2 = Comment(C2, "A kitchen staple.")

Here's a simple CookbookSet with a predefined list of cookbooks.

    >>> from zope.component import provideUtility
    >>> class CookbookSet:
    ...     implements(ICookbookSet)
    ...     def __init__(self):
    ...         self.cookbooks = COOKBOOKS
    ...
    ...     def newCookbook(self, author_name, title):
    ...         authors = AuthorSet()
    ...         author = authors.getAuthor(author_name)
    ...         if author is None:
    ...             author = authors.newAuthor(author_name)
    ...         cookbook = Cookbook(title, author)
    ...         self.cookbooks.append(cookbook)
    ...         return cookbook
    ...
    ...     def getAll(self):
    ...         return self.cookbooks
    ...
    ...     def get(self, name):
    ...         match = [c for c in self.cookbooks if c.name == name]
    ...         if len(match) > 0:
    ...             return match[0]
    ...         return None
    ...
    ...     def findRecipes(self, name):
    ...         """Find recipes for a given dish across cookbooks."""
    ...         matches = []
    ...         for c in self.cookbooks:
    ...             for r in c.recipes:
    ...                 if r.dish.name == name:
    ...                     matches.append(r)
    ...                     break
    ...         # A somewhat arbitrary and draconian bit of error handling
    ...         # for the sake of demonstration.
    ...         if len(matches) == 0:
    ...             raise ValueError("No matches for %s" % name)
    ...         return matches
    >>> protect_schema(CookbookSet, ICookbookSet)
    >>> provideUtility(CookbookSet(), ICookbookSet)

Here's a simple AuthorSet with predefined authors.

    >>> class AuthorSet:
    ...     implements(IAuthorSet)
    ...     def __init__(self):
    ...         self.authors = AUTHORS
    ...
    ...     def newAuthor(self, name):
    ...         author = Author(name)
    ...         self.authors.append(author)
    ...         return author
    ...
    ...     def getAllAuthors(self):
    ...         return self.authors
    ...
    ...     def getAuthor(self, name):
    ...         match = [p for p in self.authors if p.name == name]
    ...         if len(match) > 0:
    ...             return match[0]
    ...         return None
    >>> protect_schema(AuthorSet, IAuthorSet)
    >>> provideUtility(AuthorSet(), IAuthorSet)

Finally, a simple DishSet with predefined dishes.

    >>> class DishSet:
    ...     implements(IDishSet)
    ...     def __init__(self):
    ...         self.dishes = [D1, D2, D3]
    ...
    ...     def getAll(self):
    ...         return self.dishes
    ...
    ...     def get(self, name):
    ...         match = [d for d in self.dishes if d.name == name]
    ...         if len(match) > 0:
    ...             return match[0]
    ...         return None
    >>> protect_schema(DishSet, IDishSet)
    >>> provideUtility(DishSet(), IDishSet)

The web service uses the standard Navigation components to map URLs to
components to publish (see navigation.txt) and the standard
ICanonicalUrlData to map content object back to URL (see
canonical_url.txt).

The navigation for these components:

    >>> from urllib import unquote
    >>> from canonical.launchpad.webapp.publisher import (
    ...     Navigation, stepthrough)
    >>> from zope.component import provideAdapter
    >>> from zope.publisher.interfaces.browser import (
    ...     IBrowserPublisher, IDefaultBrowserLayer)

    >>> def register_navigation(navigation, for_):
    ...     provideAdapter(navigation, [for_, IDefaultBrowserLayer],
    ...         IBrowserPublisher)

    >>> class DishSetNavigation(Navigation):
    ...     def traverse(self, name):
    ...         return self.context.get(unquote(name))
    >>> register_navigation(DishSetNavigation, IDishSet)

    >>> class AuthorSetNavigation(Navigation):
    ...     def traverse(self, name):
    ...         return self.context.getAuthor(unquote(name))
    >>> register_navigation(AuthorSetNavigation, IAuthorSet)

    >>> class CookbookSetNavigation(Navigation):
    ...     def traverse(self, name):
    ...         return self.context.get(unquote(name))
    >>> register_navigation(CookbookSetNavigation, ICookbookSet)

    >>> class CookbookNavigation(Navigation):
    ...     @stepthrough('comments')
    ...     def traverse_comments(self, name):
    ...         try:
    ...             return self.context.comments[int(name)-1]
    ...         except (IndexError, TypeError, ValueError):
    ...             return None
    ...
    ...     @stepthrough('recipes')
    ...     def traverse_recipes(self, name):
    ...         name = unquote(name)
    ...         for recipe in self.context.recipes:
    ...             if recipe.dish.name == name:
    ...                 return recipe
    ...         return None
    >>> register_navigation(CookbookNavigation, ICookbook)

    >>> class RecipeNavigation(Navigation):
    ...     @stepthrough('comments')
    ...     def traverse_comments(self, name):
    ...         try:
    ...             return self.context.comments[int(name)-1]
    ...         except (IndexError, TypeError, ValueError):
    ...             return None
    >>> register_navigation(RecipeNavigation, IRecipe)

    >>> class RootNavigation(Navigation):
    ...     top_level_names = {
    ...         'dishes': DishSet(),
    ...         'cookbooks': CookbookSet(),
    ...         'authors': AuthorSet()}
    ...
    ...     def traverse(self, name):
    ...         return self.top_level_names.get(name)

The canonical URLs for these components:

    >>> from urllib import quote
    >>> from canonical.launchpad.webapp.interfaces import ICanonicalUrlData
    >>> class BaseUrlData(object):
    ...     inside = None
    ...     def __init__(self, context):
    ...         self.context = context
    ...         self.rootsite = None
    ...
    ...     @property
    ...     def path(self):
    ...         return quote(self.context.name)

    >>> class AuthorUrlData(BaseUrlData):
    ...     @property
    ...     def inside(self):
    ...         return AuthorSet()
    >>> provideAdapter(AuthorUrlData, [IAuthor], ICanonicalUrlData)

    >>> class DishUrlData(BaseUrlData):
    ...     @property
    ...     def inside(self):
    ...         return DishSet()
    >>> provideAdapter(DishUrlData, [IDish], ICanonicalUrlData)

    >>> class RecipeUrlData(BaseUrlData):
    ...     @property
    ...     def inside(self):
    ...         return self.context.cookbook
    ...     @property
    ...     def path(self):
    ...         return quote(u"recipes/%s" % str(self.context.dish.name))
    >>> provideAdapter(RecipeUrlData, [IRecipe], ICanonicalUrlData)

    >>> class CookbookUrlData(BaseUrlData):
    ...     @property
    ...     def inside(self):
    ...         return CookbookSet()
    >>> provideAdapter(CookbookUrlData, [ICookbook], ICanonicalUrlData)

    >>> class DishSetUrlData(BaseUrlData):
    ...     path = 'dishes'
    >>> provideAdapter(DishSetUrlData, [IDishSet], ICanonicalUrlData)

    >>> class CookbookSetUrlData(BaseUrlData):
    ...     path = 'cookbooks'
    >>> provideAdapter(CookbookSetUrlData, [ICookbookSet], ICanonicalUrlData)

    >>> class AuthorSetUrlData(BaseUrlData):
    ...     path = 'authors'
    >>> provideAdapter(AuthorSetUrlData, [IAuthorSet], ICanonicalUrlData)

    >>> class CommentUrlData(BaseUrlData):
    ...     @property
    ...     def path(self):
    ...         return "comments/%d" % (
    ...             self.context.target.comments.index(self.context)+1)
    ...     @property
    ...     def inside(self):
    ...         return self.context.target
    >>> provideAdapter(CommentUrlData, [Comment], ICanonicalUrlData)


== Defining the resources ==

LAZR provides an interface, IEntry, used by an individual model object
exposed through a specific resource. This interface defines only one
attribute 'schema' which should contain a schema describing the data
fields available in the entry.  The same kind of fields defined by a
model interface like IRecipe.  It is expected that the entry adapter
also provides that schema itself.

If there's not much to an interface, you can expose it through the web
service exactly as it's defined, by defining a class that inherits
from both the interface and IEntry. Since IAuthor and IComment are so
simple, we can define IAuthorEntry and ICommentEntry this way:

    >>> from canonical.lazr.interfaces import IEntry
    >>> class IAuthorEntry(IAuthor, IEntry):
    ...     """The part of an author we expose through the web service."""

    >>> from canonical.lazr.interfaces import IEntry
    >>> class ICommentEntry(IComment, IEntry):
    ...     """The part of a comment we expose through the web service."""

That usually doesn't work, though, because we usually don't want to
expose to the web service the same data model we expose
internally. Usually there are fields we don't want to expose,
synthetic fields we do want to expose, fields we want to expose as a
different type under a different name, and so on. This is why we have
IEntry in the first place: the IEntry interface defines the interface
we _do_ want to expose through the web service.

The reason we can't just define IDishEntry(IDish, IEntry) is that
IDish defines the "recipes" collection as an Attribute. Attribute is
about as generic as "object", and doesn't convey any information about
what kind of object is in the collection, or even that "recipes" is a
collection at all. To expose the corresponding field to the web
service we use CollectionField.

    >>> from canonical.lazr.rest.schema import CollectionField
    >>> class IDishEntry(IEntry):
    ...     "The part of a dish that we expose through the web service."
    ...     recipes = CollectionField(value_type=Object(schema=IRecipe))


In the following code block we define an interface that exposes the
underlying Recipe's name but not its ID. References to associated
objects (like the recipe's cookbook) are represented with the
zope.schema.Object type: this makes it possible to serve a link from a
recipe to its cookbook.

    >>> class IRecipeEntry(IEntry):
    ...     "The part of a recipe that we expose through the web service."
    ...     cookbook = Object(schema=ICookbook)
    ...     dish = Object(schema=IDish)
    ...     instructions = Text(title=u"Name", required=True)
    ...     comments = CollectionField(value_type=Object(schema=IComment))

    >>> class ICookbookEntry(IEntry):
    ...     name = TextLine(title=u"Name", required=True)
    ...     author = Object(schema=IAuthor)
    ...     recipes = CollectionField(value_type=Object(schema=IRecipe))
    ...     comments = CollectionField(value_type=Object(schema=IComment))


== Implementing the resources ==

Here's the implementation of IAuthorEntry: a simple decorator on the
original model object. It subclasses Entry, a simple base class that
defines a constructor. (See lazr/doc/decorates.txt for more on
decorates().)

    >>> from zope.component import adapts
    >>> from zope.interface.verify import verifyObject
    >>> from canonical.lazr import decorates
    >>> from canonical.lazr.rest import Entry

    >>> class AuthorEntry(Entry):
    ...     """An author, as exposed through the web service."""
    ...     adapts(IAuthor)
    ...     decorates(IAuthorEntry)
    ...     schema = IAuthorEntry

    >>> verifyObject(IAuthorEntry, AuthorEntry(A1))
    True

The "schema" attribute points to the interface class that defines the
attributes exposed through the web service. Above, "schema" is
IAuthorEntry, which exposes only "name".

IEntry also defines an invariant that enforce that it can be
adapted to the interface defined in the schema attribute. This
is usually not a problem, since the schema is usually the interface
itself.

    >>> IAuthorEntry.validateInvariants(AuthorEntry(A1))

But the invariant will complain if that doesn't isn't true.

    >>> class InvalidAuthorEntry(Entry):
    ...     adapts(IAuthor)
    ...     decorates(IAuthorEntry)
    ...     schema = ICookbookEntry

    >>> verifyObject(IAuthorEntry, InvalidAuthorEntry(A1))
    True
    >>> IAuthorEntry.validateInvariants(InvalidAuthorEntry(A1))
    Traceback (most recent call last):
      ...
    Invalid: InvalidAuthorEntry doesn't provide its ICookbookEntry schema.

Other entries are defined similarly.

# XXX flacoste 2008/03/17 Update this example to show how adapters can
# be used to resolve the impedance mismatch between the web-service
# visible interface and the internal data model.)

    >>> class CookbookEntry(Entry):
    ...     """A cookbook, as exposed through the web service."""
    ...     adapts(ICookbook)
    ...     decorates(ICookbookEntry)
    ...     schema = ICookbookEntry

    >>> class DishEntry(Entry):
    ...     """A dish, as exposed through the web service."""
    ...     adapts(IDish)
    ...     decorates(IDishEntry)
    ...     schema = IDishEntry

    >>> class CommentEntry(Entry):
    ...     """A comment, as exposed through the web service."""
    ...     adapts(IComment)
    ...     decorates(ICommentEntry)
    ...     schema = ICommentEntry

    >>> class RecipeEntry(Entry):
    ...     adapts(IRecipe)
    ...     decorates(IRecipeEntry)
    ...     schema = IRecipeEntry


We need to register these entries as an adapter from (eg.) IAuthor to
(eg.) IAuthorEntry. In ZCML a registration would look like this.

    <adapter
        for="my.app.interfaces.IAuthor"
        provides="my.app.interfaces.IAuthorEntry"
        factory="my.app.rest.AuthorEntry"
        />

Since we're in the middle of a Python test we need to do the equivalent
in Python code:

    >>> provideAdapter(AuthorEntry, [IAuthor], IAuthorEntry)
    >>> provideAdapter(CookbookEntry, [ICookbook], ICookbookEntry)
    >>> provideAdapter(DishEntry, [IDish], IDishEntry)
    >>> provideAdapter(CommentEntry, [IComment], ICommentEntry)
    >>> provideAdapter(RecipeEntry, [IRecipe], IRecipeEntry)

LAZR also defines an interface and a base class for collections of
objects. I'll use it to expose the AuthorSet collection and other
top-level collections through the web service. A collection must
define a method called find(), which returns the model objects in the
collection.

    >>> from canonical.lazr.rest import Collection
    >>> from canonical.lazr.interfaces import ICollection

    >>> class AuthorCollection(Collection):
    ...     """A collection of authors, as exposed through the web service."""
    ...
    ...     def find(self):
    ...        """Find all the authors."""
    ...        return self.context.getAllAuthors()
    ...
    >>> provideAdapter(AuthorCollection, [IAuthorSet], ICollection)

    >>> verifyObject(ICollection, AuthorCollection(AuthorSet()))
    True

    >>> class CookbookCollection(Collection):
    ...     """A collection of cookbooks, as exposed through the web service.
    ...     """
    ...
    ...     def find(self):
    ...        """Find all the cookbooks."""
    ...        return self.context.getAll()
    >>> provideAdapter(CookbookCollection, [ICookbookSet], ICollection)

    >>> class DishCollection(Collection):
    ...     """A collection of dishes, as exposed through the web service."""
    ...
    ...     def find(self):
    ...        """Find all the dishes."""
    ...        return self.context.getAll()
    >>> provideAdapter(DishCollection, [IDishSet], ICollection)

Like Entry, Collection is a simple base class that defines a
constructor.

We need to define a collection of the recipes associated with a
cookbook. We say that the collection of recipes is scoped to a
cookbook. Scoped collections adapters are looked for based on the type
of the scope, and the type of the entries contained in the scoped
collection. There is a default ScopedCollection adapter that work in all
cases where the scoped collection is available as an iterable attribute
of the context.

    >>> from zope.component import getMultiAdapter
    >>> from canonical.lazr.interfaces import IScopedCollection

    >>> getMultiAdapter((C1, C1_D1), IScopedCollection)
    <canonical.lazr.rest.resource.ScopedCollection...>

The default adapter will also work just fine with the comments scoped
collection.


== Custom operations ==

The CookbookSet class defines a method called 'findRecipes'. This is
exposed through the cookbook collection resource as a custom operation
called 'find_recipes'. Each custom operation is implemented as a class
that implementsIResourceGETOperation.

    >>> from canonical.lazr.rest import ResourceGETOperation
    >>> from zope.schema import TextLine
    >>> from zope.publisher.interfaces.http import IHTTPApplicationRequest
    >>> from canonical.lazr.interfaces import IResourceGETOperation
    >>> class FindRecipesOperation(ResourceGETOperation):
    ...    """An operation that searches for recipes across cookbooks."""
    ...    params = [ TextLine(__name__='name') ]
    ...
    ...    def call(self, name):
    ...        try:
    ...            return self.context.findRecipes(name)
    ...        except ValueError, e:
    ...            self.request.response.setStatus(400)
    ...            return str(e)

To register the class we just defined as implementing the
'find_recipes' operation, we need to register it as a named adapter
providing IResourceGETOperation for the ICookbookSet interface.

    >>> provideAdapter(FindRecipesOperation,
    ...                [ICookbookSet, IHTTPApplicationRequest],
    ...                IResourceGETOperation, "find_recipes")

The same underlying method is exposed through the recipe entry
resource as a custom operation called 'find_similar_recipes'.

    >>> class FindSimilarRecipesOperation(ResourceGETOperation):
    ...    """Finds recipes with the same name."""
    ...    params = []
    ...
    ...    def call(self):
    ...        try:
    ...            return CookbookSet().findRecipes(self.context.dish.name)
    ...        except AssertionError, e:
    ...            self.request.response.setStatus(400)
    ...            return str(e)

    >>> provideAdapter(FindSimilarRecipesOperation,
    ...                [IRecipe, IHTTPApplicationRequest],
    ...                IResourceGETOperation, "find_similar_recipes")

Named GET operations are read-only operations like searches, but
resources can also expose named write operations, through POST. Here's
a named factory operation for creating a new cookbook.

    >>> from canonical.lazr.rest import ResourcePOSTOperation
    >>> class CookbookFactoryOperation(ResourcePOSTOperation):
    ...    """An operation that creates a new cookbook."""
    ...    params = (
    ...        TextLine(__name__='author_name'),
    ...        TextLine(__name__='title'),
    ...    )
    ...
    ...    def call(self, author_name, title):
    ...        cookbook = CookbookSet().newCookbook(author_name, title)
    ...        self.request.response.setStatus(201)
    ...        self.request.response.setHeader(
    ...            "Location", canonical_url(cookbook))
    ...        return cookbook

    >>> from canonical.lazr.interfaces import IResourcePOSTOperation
    >>> provideAdapter(CookbookFactoryOperation,
    ...                [ICookbookSet, IHTTPApplicationRequest],
    ...                IResourcePOSTOperation, "create_cookbook")


== Resource objects ==

LAZR's Resource objects are the objects that actually handle incoming
HTTP requests. There are a few very common types of HTTP resources,
and LAZR defines classes for some of them. For instance, there's the
"collection" resource that responds to GET (to get the items in the
collection) and POST (to invoke named operations on the
collection). LAZR implements this as a CollectionResource which uses
the HTTP arguments to drive Collection methods like find().

Of course, a CollectionResource has to expose a collection _of_
something. That's why each CollectionResource is associated with some
concrete implementation of ICollection, like AuthorCollection. All you
have to do is define the behaviour of the collection, and
CollectionResource takes care of exposing the collection through HTTP.

Similarly, you can implement RecipeEntry to the IEntry interface, and
expose it through the web as an EntryResource.


== The Service Root Resource ==

How are these Resource objects connected to the web? Through the
ServiceRootResource. This is a special resource that represents the
root of the object tree.

    >>> from canonical.launchpad.webapp.interfaces import (
    ...    ILaunchpadApplication)
    >>> from canonical.lazr.interfaces import IServiceRootResource
    >>> from canonical.lazr.rest import ServiceRootResource
    >>> class IMyWebServiceApplication(ILaunchpadApplication,
    ...                                IServiceRootResource):
    ...     """Marker interface for the web service."""
    >>> class MyServiceRootResource(ServiceRootResource):
    ...     implements(IMyWebServiceApplication)
    >>> register_navigation(RootNavigation, IMyWebServiceApplication)

    >>> from canonical.launchpad.webapp.servers import WebServicePublication
    >>> class MyWebServicePublication(WebServicePublication):
    ...    def getApplication(self, request):
    ...        return MyServiceRootResource()

If you call the service root resource, and pass in an HTTP request, it
will act as though you had performed a GET on the URL
'http://api.launchpad.net/beta/'.

    >>> from canonical.launchpad.webapp.servers import WebServiceTestRequest
    >>> from cStringIO import StringIO

    >>> def create_web_service_request(
    ...     path_info, method='GET', body=None, environ=None):
    ...     test_environ = {
    ...         'SERVER_URL': 'http://api.launchpad.dev',
    ...         'HTTP_HOST': 'api.launchpad.dev',
    ...         'PATH_INFO': path_info,
    ...     }
    ...     if environ is not None:
    ...         test_environ.update(environ)
    ...     if body is None:
    ...         body_instream = body
    ...     else:
    ...         test_environ['CONTENT_LENGTH'] = len(body)
    ...         body_instream = StringIO(body)
    ...     request = WebServiceTestRequest(
    ...         body_instream=body_instream, environ=test_environ,
    ...         method=method)
    ...     request.setPublication(MyWebServicePublication(None))
    ...     # Set the "current" request.
    ...     login(ANONYMOUS, request)
    ...     request.processInputs()
    ...     return request

    >>> app = MyServiceRootResource()
    >>> from canonical.launchpad.interfaces import IOpenLaunchBag
    >>> getUtility(IOpenLaunchBag).add(app)
    >>> request = create_web_service_request('/beta/')
    >>> ignore = request.traverse(app)

The response document is a JSON document full of links to the
top-level collections of authors, cookbooks, and dishes. It's the
'home page' for the web service.

    # XXX leonardr 2008-04-24 bug=221037: It also includes top-level
    # collections from the Launchpad web service. This part of the
    # test can be simplified once the test is moved to another layer.
    >>> import simplejson
    >>> response = app(request)
    >>> representation = simplejson.loads(response)

    >>> representation["AuthorCollection_collection_link"]
    u'http://api.launchpad.dev/beta/authors'

    >>> representation["CookbookCollection_collection_link"]
    u'http://api.launchpad.dev/beta/cookbooks'

    >>> representation["DishCollection_collection_link"]
    u'http://api.launchpad.dev/beta/dishes'

The standard canonical_url() function can be used to generate URLs to
content objects published on the web service. It works for the web
service root also.

    >>> from canonical.launchpad.webapp import canonical_url
    >>> ICanonicalUrlData.providedBy(app)
    True
    >>> canonical_url(app)
    u'http://api.launchpad.dev/beta/'


== Collection resources ==

The default root navigation defined in our model contains the top-level
Set objects that should be published. When these sets are published on
the web service, they will we wrapped in the appropriate
CollectionResource.

The following example is equivalent to requesting
'http://api.launchpad.net/cookbooks/'. The code will traverse to the
CookbookSet published normally at '/cookbooks' and it will be wrapped
into a CollectionResource.

    >>> request = create_web_service_request('/beta/cookbooks')
    >>> collection = request.traverse(app)
    >>> collection
    <canonical.lazr.rest.resource.CollectionResource object ...>

Calling the collection resource yields a JSON document, which can be
parsed with standard tools.

    >>> representation = simplejson.loads(collection())

=== Pagination ===

Collections are paginated and served one page at a time. This
particular collection is small enough to fit on one page; it's only
got three entries.

    >>> sorted(representation.keys())
    [u'entries', u'start', u'total_size']
    >>> len(representation['entries'])
    3
    >>> representation['total_size']
    3

But if we ask for a page size of two, we can see how pagination
works. Here's page one, with two cookbooks on it.

    >>> request = create_web_service_request(
    ...     '/beta/cookbooks', environ={'QUERY_STRING' : 'ws_size=2'})
    >>> collection = request.traverse(app)
    >>> representation = simplejson.loads(collection())

    >>> sorted(representation.keys())
    [u'entries', u'next_collection_link', u'start', u'total_size']
    >>> representation['next_collection_link']
    u'http://api.launchpad.dev/beta/cookbooks?ws_start=2&ws_size=2'
    >>> len(representation['entries'])
    2
    >>> representation['total_size']
    3

Follow the 'next_collection_link' and you'll end up at page two, which
has the last cookbook on it.

    >>> request = create_web_service_request(
    ...     '/beta/cookbooks',
    ...     environ={'QUERY_STRING' : 'ws_start=2&ws_size=2'})
    >>> collection = request.traverse(app)
    >>> representation = simplejson.loads(collection())

    >>> sorted(representation.keys())
    [u'entries', u'prev_collection_link', u'start', u'total_size']
    >>> representation['prev_collection_link']
    u'http://api.launchpad.dev/beta/cookbooks?ws_start=0&ws_size=2'
    >>> len(representation['entries'])
    1


=== Custom operations ===

A collection may also expose a number of custom operations through
GET. The cookbook collection exposes a custom GET operation called
'find_recipes', which searches for recipes with a given name across
cookbooks.

    >>> request = create_web_service_request(
    ...    '/beta/cookbooks',
    ...    environ={'QUERY_STRING' :
    ...             'ws_op=find_recipes&name=Roast%20chicken'})
    >>> operation_resource = request.traverse(app)
    >>> chicken_recipes = simplejson.loads(operation_resource())
    >>> sorted([c['instructions'] for c in chicken_recipes['entries']])
    [u'A perfectly roasted chicken is...',
     u'Draw, singe, stuff, and truss...',
     u'You can always judge...']

Custom operations may include custom error checking. Error messages
are passed along to the client.

    >>> request = create_web_service_request(
    ...    '/beta/cookbooks',
    ...    environ={'QUERY_STRING' :
    ...             'ws_op=find_recipes&name=NoSuchRecipe'})
    >>> operation_resource = request.traverse(app)
    >>> print operation_resource()
    No matches for NoSuchRecipe

Collections may also support named POST operations. These operations
are often factory operations. Here we create a new cookbook for an
existing author:

    >>> body = ("ws_op=create_cookbook&title=Beard%20on%20Bread&"
    ...         "author_name=James%20Beard")
    >>> request = create_web_service_request(
    ...     '/beta/cookbooks', 'POST', body,
    ...     {'CONTENT_TYPE' : 'application/x-www-form-urlencoded'})
    >>> operation_resource = request.traverse(app)
    >>> result = operation_resource()

    >>> request.response.getStatus()
    201
    >>> request.response.getHeader('Location')
    'http://api.launchpad.dev/beta/cookbooks/Beard%20on%20Bread'

Here we create a cookbook for a new author.

    >>> body = ("ws_op=create_cookbook&title=Everyday%20Greens&"
    ...         "author_name=Deborah%20Madison")
    >>> request = create_web_service_request(
    ...     '/beta/cookbooks', 'POST', body,
    ...     {'CONTENT_TYPE' : 'application/x-www-form-urlencoded'})
    >>> operation_resource = request.traverse(app)
    >>> result = operation_resource()
    >>> request.response.getStatus()
    201
    >>> request.response.getHeader('Location')
    'http://api.launchpad.dev/beta/cookbooks/Everyday%20Greens'

The new Author object is created implicitly and is published as a
resource afterwards.

    >>> path = '/beta/authors/Deborah%20Madison'
    >>> request = create_web_service_request(path)
    >>> author = request.traverse(app)
    >>> simplejson.loads(author())['name']
    u'Deborah Madison'


== Entry resources ==

The collection resource is a list of entries. Each entry has some
associated information (like 'name'), a 'self_link' (the URL to the
entry's resource), and possibly links to associated resources.

    >>> import operator
    >>> request = create_web_service_request('/beta/cookbooks')
    >>> collection = request.traverse(app)
    >>> representation = simplejson.loads(collection())
    >>> entries = sorted(representation['entries'],
    ...                  key=operator.itemgetter('name'))
    >>> entries[0]['name']
    u'Beard on Bread'
    >>> entries[0]['self_link']
    u'http://api.launchpad.dev/beta/cookbooks/Beard%20on%20Bread'

Each cookbook, for instance, has a link to its author.

    >>> entries[0]['author_link']
    u'http://api.launchpad.dev/beta/authors/James%20Beard'

Calling the CollectionResource object makes it process the incoming
request. Since this is a GET request, calling the resource publishes
the resource to the web. A CollectionResource is made up of a bunch of
EntryResources, and the base EntryResource class knows how to use the
entry schema class (in this case, IRecipeEntry) to publish a JSON
document.

The same way collections are wrapped into CollectionResource, navigating
to an object that has an IEntry adapter, will wrap it into an
EntryResource.

For instance, requesting "/cookbooks/The%20Joy%20of%20Cooking" will wrap
the "Joy of Cooking" cookbook object into an EntryResource.

    >>> request = create_web_service_request(
    ...     quote('/beta/cookbooks/The Joy of Cooking'))
    >>> joy_resource = request.traverse(app)
    >>> joy_resource
    <canonical.lazr.rest.resource.EntryResource object ...>

    >>> joy = simplejson.loads(joy_resource())
    >>> sorted(joy.items())
    [(u'author_link',
      u'http://api.launchpad.dev/beta/authors/Irma%20S.%20Rombauer'),
     (u'comments_collection_link',
      u'http://api.launchpad.dev/beta/cookbooks/The%20Joy%20of%20Cooking/comments'),
     (u'name', u'The Joy of Cooking'),
     (u'recipes_collection_link',
      u'http://api.launchpad.dev/beta/cookbooks/The%20Joy%20of%20Cooking/recipes'),
     (u'self_link',
      u'http://api.launchpad.dev/beta/cookbooks/The%20Joy%20of%20Cooking')]

You can also traverse from an entry to an item in a scoped collection:

    >>> request = create_web_service_request(
    ...     quote('/beta/cookbooks/The Joy of Cooking/recipes/Roast chicken'))
    >>> chicken_recipe_resource = request.traverse(app)
    >>> chicken_recipe = simplejson.loads(chicken_recipe_resource())
    >>> sorted(chicken_recipe.items())
    [(u'comments_collection_link',
      u'http://api...Joy%20of%20Cooking/recipes/Roast%20chicken/comments'),
    (u'cookbook_link',
     u'http://api.launchpad.dev/beta/cookbooks/The%20Joy%20of%20Cooking'),
    (u'dish_link', u'http://api.launchpad.dev/beta/dishes/Roast%20chicken'),
    (u'instructions', u'Draw, singe, stuff, and truss...'),
    (u'self_link',
     u'http://api.../The%20Joy%20of%20Cooking/recipes/Roast%20chicken')]

Another example traversing to a comment:

    >>> roast_chicken_comments_url = quote(
    ... '/beta/cookbooks/The Joy of Cooking/recipes/Roast chicken/comments')
    >>> request = create_web_service_request(roast_chicken_comments_url)
    >>> comments_resource = request.traverse(app)

    >>> comments = simplejson.loads(comments_resource())
    >>> [c['text'] for c in comments['entries']]
    [u'Clear and concise.']

    >>> request = create_web_service_request(
    ...     roast_chicken_comments_url + '/1')
    >>> comment_one_resource = request.traverse(app)
    >>> comment_one = simplejson.loads(comment_one_resource())
    >>> sorted(comment_one.items())
    [(u'self_link',
      u'http://api...Joy%20of%20Cooking/recipes/Roast%20chicken/comments/1'),
     (u'text', u'Clear and concise.')]

An entry may expose a number of custom operations through GET. The
recipe entry exposes a custom GET operation called
'find_similar_recipes', which searches for recipes with the same name
across cookbooks.

    >>> request = create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking/recipes/Roast%20chicken',
    ...     environ={'QUERY_STRING' : 'ws_op=find_similar_recipes'})
    >>> operation_resource = request.traverse(app)
    >>> chicken_recipes = simplejson.loads(operation_resource())
    >>> sorted([c['instructions'] for c in chicken_recipes['entries']])
    [u'A perfectly roasted chicken is...',
     u'Draw, singe, stuff, and truss...',
     u'You can always judge...']


== Requesting non available resources ==

If the user tries to traverse to a nonexistent object, the result is a
NotFound exception.

Requesting a non-existent top-level collection:

    >>> create_web_service_request('/beta/nosuchcollection').traverse(app)
    Traceback (most recent call last):
    ...
    NotFound: ... name: u'nosuchcollection'

Requesting a non-existent cookbook:

    >>> create_web_service_request('/beta/cookbooks/104').traverse(app)
    Traceback (most recent call last):
    ...
    NotFound: ... name: u'104'

Requesting an attribute which isn't exposed as a collection:

    >>> create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking/name').traverse(app)
    Traceback (most recent call last):
    ...
    NotFound: ... name: u'name'

Requesting a non-existent comment:

    >>> create_web_service_request(
    ...  '/beta/cookbooks/The%20Joy%20of%20Cooking/comments/10').traverse(app)
    Traceback (most recent call last):
    ...
    NotFound: ... name: u'10'


== Manipulating entries ==

Most entry resources support write operations by responding to PATCH
requests. The entity-body of a PATCH request should be a JSON document
with new values for some of the entry's attributes. Basically, a set
of assertions about what the object *should* look like.

Here, we modify the name of one of the cookbooks.

    >>> headers = {'CONTENT_TYPE' : 'application/json'}
    >>> body = '{"name" : "The Joy of Cooking (revised)"}'

    >>> patch_request = create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking', body=body,
    ...     environ=headers, method='PATCH')
    >>> joy_resource_patch = patch_request.traverse(app)
    >>> joy_resource_patch()
    ''

    >>> patch_request.response.getHeader('Location')
    'http://api.../cookbooks/The%20Joy%20of%20Cooking%20%28revised%29'

The new name is reflected in the cookbook's representation, and the
cookbook's URL has changed as well.

    >>> request = create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking%20%28revised%29')
    >>> joy_resource = request.traverse(app)
    >>> joy = simplejson.loads(joy_resource())
    >>> joy['name']
    u'The Joy of Cooking (revised)'

An entry that responds to PATCH will also respond to PUT. With PUT you
modify the document you got in response to a GET request, and send the
whole thing back to the server, whereas with PATCH you're creating a
new document that describes a subset of the entry's state.

Here, we use PUT to change the cookbook's name back to what it was
before. Note that we send the entire dictionary back to the server.

    >>> joy['name'] = 'The Joy of Cooking'
    >>> body = simplejson.dumps(joy)
    >>> put_request = create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking%20%28revised%29',
    ...     body=body, environ=headers, method='PUT')

    >>> joy_resource_put = put_request.traverse(app)
    >>> joy_resource_put()
    ''

The cookbook's URL has changed back to what it was before.

    >>> put_request.response.getStatus()
    301
    >>> put_request.response.getHeader('Location')
    'http://api.launchpad.dev/beta/cookbooks/The%20Joy%20of%20Cooking'

So has the cookbook's name.

    >>> joy_resource = create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking').traverse(app)
    >>> joy = simplejson.loads(joy_resource())
    >>> joy['name']
    u'The Joy of Cooking'

It's also possible to change the relationships between objects. Here,
we change a cookbook's author. Since all objects are identified by
their URLs, we make the change by modifying the cookbook's
'author_link' field to point to another author.

    >>> joy['author_link'] = u'http://api.launchpad.dev/beta/authors/Julia%20Child'
    >>> resource = create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking',
    ...     body=simplejson.dumps(joy), environ=headers,
    ...     method='PUT').traverse(app)
    >>> resource()
    ''

    >>> joy = simplejson.loads(joy_resource())
    >>> joy['author_link']
    u'http://api.launchpad.dev/beta/authors/Julia%20Child'


= Cleanup =

The final step is to unregister the adapters registered for this test,
so that they don't show up in other tests as parts of the site.

    >>> from zope.app import zapi
    >>> def unregister(required, provided, name=''):
    ...     manager = zapi.getGlobalSiteManager()
    ...     manager.adapters.register(required, provided, name, None)
    ...     del manager._registrations[(tuple(required), provided, name)]
    >>> unregister([IAuthor], IAuthorEntry)
    >>> unregister([ICookbook], ICookbookEntry)
    >>> unregister([IDish], IDishEntry)
    >>> unregister([IComment], ICommentEntry)
    >>> unregister([IRecipe], IRecipeEntry)

    >>> unregister([IAuthorSet], ICollection)
    >>> unregister([ICookbookSet], ICollection)
    >>> unregister([IDishSet], ICollection)

    >>> unregister([ICookbookSet, IHTTPApplicationRequest],
    ...                   IResourcePOSTOperation, 'create_cookbook')
    >>> unregister([ICookbookSet, IHTTPApplicationRequest],
    ...                    IResourceGETOperation, "find_recipes")
    >>> unregister([IRecipe, IHTTPApplicationRequest],
    ...                   IResourceGETOperation, "find_similar_recipes")
