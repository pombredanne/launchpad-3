= Introduction =

All collections published by the Launchpad web service work pretty
much the same way. This document illustrates the general features of
entries, using Launchpad's collections of people/teams and bugs as
examples.


== Collections and pagination ===

A collection responds to GET by serving one page of the objects in the
collection.

  >>> people_collection = webservice.get("/beta/people").jsonBody()
  >>> people_collection['total_size']
  63
  >>> people_collection['next_collection_link']
  u'http://api.launchpad.dev/beta/people?ws_start=5&ws_size=5'
  >>> people_collection.get('prev_collection_link') is None
  True

  >>> from operator import itemgetter
  >>> people_entries = sorted(
  ...     people_collection['entries'], key=itemgetter('name'))
  >>> len(people_entries)
  5
  >>> people_entries[0]['name']
  u'andrelop'
  >>> people_entries[0]['self_link']
  u'http://api.launchpad.dev/beta/~andrelop'
  >>> people_entries[-1]['name']
  u'spiv'

You can get other pages of the collection by following links:

  >>> result = webservice.get("/beta/people?ws_start=5&ws_size=5")
  >>> second_batch = result.jsonBody()
  >>> second_batch['next_collection_link']
  u'http://api.launchpad.dev/beta/people?ws_start=10&ws_size=5'
  >>> second_batch['prev_collection_link']
  u'http://api.launchpad.dev/beta/people?ws_start=0&ws_size=5'

  >>> people_entries = sorted(
  ...     second_batch['entries'], key=itemgetter('name'))
  >>> people_entries[0]['name']
  u'bug-watch-updater'

You can also get a larger batch than the default:

  >>> big_batch = webservice.get("/beta/people?ws_size=50").jsonBody()
  >>> len(big_batch['entries'])
  50
  >>> big_batch.get('next_collection_link')
  u'http://api.launchpad.dev/beta/people?ws_start=50&ws_size=50'

  >>> bigger_batch = webservice.get("/beta/people?ws_size=75").jsonBody()
  >>> len(bigger_batch['entries'])
  63
  >>> bigger_batch.get('next_collection_link') is None
  True

But requesting a batch size higher than the maximum configured value
results in a 400 error.

    >>> print webservice.get("/beta/people?ws_start=0&ws_size=1000")
    HTTP/1.1 400 Bad Request
    ...
    Content-Type: text/plain...
    <BLANKLINE>
    Maximum for "ws_size" parameter is ...


== Visibility ==

A user without permission to see items in a collection will, of
course, not see those items. The 'salgado' user can see all bugs on the
site.

  >>> salgado_output = webservice.get("/beta/bugs?ws_size=50").jsonBody()
  >>> salgado_output['total_size']
  15
  >>> len(salgado_output['entries'])
  15

But the 'no-priv' user can't see bug number 14, which is private.

  >>> nopriv_output = user_webservice.get(
  ...     "/beta/bugs?ws_size=100").jsonBody()
  >>> nopriv_output['total_size']
  14
  >>> len(nopriv_output['entries'])
  14

Things are a little different for a user who has permission to see
private data, but is using an OAuth key that restricts the client to
operating on public data.

  >>> public_output = public_webservice.get(
  ...     "/beta/bugs?ws_size=50").jsonBody()
  >>> public_output['total_size']
  15
  >>> len(public_output['entries'])
  14

What happened there? This web service request was made by a user who
can see all 15 bugs, but the user used an OAuth token that only allows
access to public data. The actual bugs are filtered against the OAuth
token at a fairly high level, but the number of visible bugs comes
from low-level code that only respects the user who made the
request. The user can see 15 bugs, but the token can only see the 14
public bugs.

This is not an ideal solution--the numbers are off, and a batch may
contain fewer than 'ws_size' entries--but it keeps unauthorized
clients from seeing private data.


== Element lookup ==

The elements of a collection can be looked up by unique identifier:

  >>> admins_team = webservice.get("/beta/~admins").jsonBody()
  >>> for key, value in sorted(admins_team.items()):
  ...     print "%s: %s" % (key, value)
  admins_collection_link: http://.../~admins/admins
  confirmed_email_addresses_collection_link:
      http://.../~admins/confirmed_email_addresses
  date_created: 2005-06-06T08:59:51.571899+00:00
  deactivated_members_collection_link: http://.../~admins/deactivated_members
  default_membership_period: None
  default_renewal_period: None
  display_name: Launchpad Administrators
  expired_members_collection_link: http://.../~admins/expired_members
  hide_email_addresses: False
  homepage_content: None
  invited_members_collection_link: http://.../~admins/invited_members
  irc_nicknames_collection_link: http://.../~admins/irc_nicknames
  is_team: True
  is_valid: True
  jabber_ids_collection_link: http://.../~admins/jabber_ids
  karma: 0
  languages_collection_link: http://.../~admins/languages
  mailing_list_auto_subscribe_policy: Ask me when I join a team
  member_memberships_collection_link: http://.../~admins/member_memberships
  members_collection_link: http://.../~admins/members
  mugshot_link: http://.../~admins/mugshot
  name: admins
  open_membership_invitations_collection_link:
      http://.../~admins/open_membership_invitations
  participants_collection_link: http://.../~admins/participants
  preferred_email_address_link: None
  proposed_members_collection_link: http://.../~admins/proposed_members
  renewal_policy: invite them to apply for renewal
  self_link: http://.../~admins
  subscription_policy: Moderated Team
  team_description: Launchpad Administrators
  team_memberships_collection_link: http://.../~admins/team_memberships
  team_owner_link: http://.../~sabdfl
  teams_indirectly_participated_in_collection_link:
      http://.../~admins/teams_indirectly_participated_in
  teams_participated_in_collection_link:
      http://.../~admins/teams_participated_in
  timezone: None
  visibility: Public
  wiki_names_collection_link: http://.../~admins/wiki_names

A collection may be scoped to an element:

  >>> result = webservice.get("/beta/~admins/members")
  >>> team_members = sorted(
  ...     result.jsonBody()['entries'], key=itemgetter('name'))
  >>> len(team_members)
  5
  >>> team_members[0]['name']
  u'carlos'
  >>> team_members[-1]['name']
  u'spiv'

  >>> result = webservice.get("/beta/~spiv/members")
  >>> list(result.jsonBody()['entries'])
  []


== Custom operations ==

A collection may expose custom named operations in response to GET
requests. A named operation may do anything consistent with the nature
of a GET request, but it's usually used to serve search results. The
custom operation to be invoked is named in the query string's
'ws_op' argument. Here's a custom operation on the collection of
people, called 'people'.

  >>> def search_people(text, start=0):
  ...     return webservice.get(
  ...         "/beta/people?ws_op=find&text=%s&ws_start=%s" %
  ...             (text, start)).jsonBody()

A custom operation that returns a list of objects is paginated, just
like a collection.

  >>> s_people = search_people("s")
  >>> s_people['total_size']
  8
  >>> s_people['next_collection_link']
  u'http://api.launchpad.dev/beta/people?ws_op=find&text=s&ws_start=5&ws_size=5'
  >>> sorted(p['name'] for p in s_people['entries'])
  [u'keybuk', u'salgado', u'sigurd-ubuntu', u'sjoerd', u'stevea']

  >>> s_people_batch_2 = search_people("s", 5)
  >>> sorted(p['name'] for p in s_people_batch_2['entries'])
  [u'skacel', u'stub', u'ubuntu-team']

Just as a collection may be empty, a custom operation may return an
empty list of results:

  >>> empty_list = search_people("nosuchperson")
  >>> empty_list['total_size']
  0
  >>> [p['name'] for p in empty_list['entries']]
  []

Custom operations may have custom error handling.

  >>> print webservice.get("/beta/people?ws_op=find&text=")
  HTTP/1.1 400 Bad Request
  ...
  text: Required input is missing.

A collection may also expose named operations in response to POST
requests. These operations are usually factories. Here's a helper
method that creates a new team by invoking a factory operation on
the collection of people.

  >>> def create_team(name, display_name):
  ...     return webservice.named_post(
  ...         "/beta/people", "create_team", {},
  ...         name=name, display_name=display_name)

  >>> print webservice.get('/beta/~serviceteam')
  HTTP/1.1 404 Not Found
  ...

  >>> print create_team("serviceteam", "Service Team")
  HTTP/1.1 201 Created
  ...
  Location: http://api.launchpad.dev/beta/~serviceteam
  <BLANKLINE>

  >>> print webservice.get('/beta/~serviceteam')
  HTTP/1.1 200 Ok
  ...

  >>> print create_team("serviceteam2", "Service Team")
  HTTP/1.1 201 Created
  ...
  Location: http://api.launchpad.dev/beta/~serviceteam2
  <BLANKLINE>

  >>> print webservice.get('/beta/~serviceteam2')
  HTTP/1.1 200 Ok
  ...

Standard team-creation rules apply. For instance, you can't create a
team with a name that's taken.

  >>> print create_team("serviceteam", "Name already taken")
  HTTP/1.1 400 Bad Request
  ...
  name: serviceteam is already in use by another person or team.

A POST request has no meaning right now unless it specifies a custom
operation.

  >>> print webservice.post("/beta/people", 'text/plain', '')
  HTTP/1.1 400 Bad Request
  ...
  No operation name given.

You can't invoke a nonexistent operation:

  >>> print webservice.named_post("/beta/people", "nosuchop", {})
  HTTP/1.1 400 Bad Request
  ...
  No such operation: nosuchop
