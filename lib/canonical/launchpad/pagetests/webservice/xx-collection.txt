= Introduction =

All collections published by the Launchpad web service work pretty
much the same way. This document illustrates the general features of
entries, using Launchpad's collections of people/teams and bugs as
examples.


== Collections and pagination ===

A collection responds to GET by serving one page of the objects in the
collection.

  >>> bugs_collection = webservice.get("/bugs").jsonBody()
  >>> bugs_collection['resource_type_link']
  u'http://.../#bugs'
  >>> bugs_collection['total_size']
  15
  >>> bugs_collection['next_collection_link']
  u'http://.../bugs?ws.start=5&ws.size=5'
  >>> bugs_collection.get('prev_collection_link') is None
  True

  >>> from operator import itemgetter
  >>> bugs_entries = sorted(
  ...     bugs_collection['entries'], key=itemgetter('title'))
  >>> len(bugs_entries)
  5
  >>> bugs_entries[0]['title']
  u'Copy, Cut and Delete operations should work on selections'
  >>> bugs_entries[0]['self_link']
  u'http://.../bugs/12'
  >>> bugs_entries[-1]['title']
  u'jokosher exposes personal details in its actions portlet'

There are no XHTML representations available for collections.

  >>> print webservice.get('/bugs', 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  Content-Type: application/json
  ...

You can get other pages of the collection by following links:

  >>> result = webservice.get("/bugs?ws.start=5&ws.size=5")
  >>> second_batch = result.jsonBody()
  >>> second_batch['next_collection_link']
  u'http://.../bugs?ws.start=10&ws.size=5'
  >>> second_batch['prev_collection_link']
  u'http://.../bugs?ws.start=0&ws.size=5'

  >>> bugs_entries = sorted(
  ...     second_batch['entries'], key=itemgetter('title'))
  >>> bugs_entries[0]['title']
  u'A test bug'

You can also get a larger batch than the default:

  >>> big_batch = webservice.get("/bugs?ws.size=10").jsonBody()
  >>> len(big_batch['entries'])
  10
  >>> big_batch.get('next_collection_link')
  u'http://.../bugs?ws.start=10&ws.size=10'

  >>> bigger_batch = webservice.get("/bugs?ws.size=20").jsonBody()
  >>> len(bigger_batch['entries'])
  15
  >>> bigger_batch.get('next_collection_link') is None
  True

But requesting a batch size higher than the maximum configured value
results in a 400 error.

    >>> print webservice.get("/bugs?ws.start=0&ws.size=1000")
    HTTP/1.1 400 Bad Request
    ...
    Content-Type: text/plain...
    <BLANKLINE>
    Maximum for "ws.size" parameter is ...


== Visibility ==

A user without permission to see items in a collection will, of
course, not see those items. The 'salgado' user can see all bugs on the
site.

  >>> salgado_output = webservice.get("/bugs?ws.size=50").jsonBody()
  >>> salgado_output['total_size']
  15
  >>> len(salgado_output['entries'])
  15

But the 'no-priv' user can't see bug number 14, which is private.

  >>> nopriv_output = user_webservice.get(
  ...     "/bugs?ws.size=100").jsonBody()
  >>> nopriv_output['total_size']
  14
  >>> len(nopriv_output['entries'])
  14

Things are a little different for a user who has permission to see
private data, but is using an OAuth key that restricts the client to
operating on public data.

  >>> public_output = public_webservice.get(
  ...     "/bugs?ws.size=50").jsonBody()
  >>> public_output['total_size']
  15
  >>> len(public_output['entries'])
  14

What happened there? This web service request was made by a user who
can see all 15 bugs, but the user used an OAuth token that only allows
access to public data. The actual bugs are filtered against the OAuth
token at a fairly high level, but the number of visible bugs comes
from low-level code that only respects the user who made the
request. The user can see 15 bugs, but the token can only see the 14
public bugs.

This is not an ideal solution--the numbers are off, and a batch may
contain fewer than 'ws.size' entries--but it keeps unauthorized
clients from seeing private data.


== Element lookup ==

The elements of a collection can be looked up by unique identifier:

  >>> from canonical.lazr.testing.webservice import pprint_entry
  >>> admins_team = webservice.get("/~admins").jsonBody()
  >>> pprint_entry(admins_team)
  admins_collection_link: u'http://.../~admins/admins'
  archive_link: None
  confirmed_email_addresses_collection_link:
      u'http://.../~admins/confirmed_email_addresses'
  date_created: u'2005-06-06T08:59:51.571899+00:00'
  deactivated_members_collection_link: u'http://.../~admins/deactivated_members'
  default_membership_period: None
  default_renewal_period: None
  display_name: u'Launchpad Administrators'
  expired_members_collection_link: u'http://.../~admins/expired_members'
  hardware_submissions_collection_link: u'http://.../~admins/hardware_submissions'
  hide_email_addresses: False
  homepage_content: None
  invited_members_collection_link: u'http://.../~admins/invited_members'
  irc_nicknames_collection_link: u'http://.../~admins/irc_nicknames'
  is_team: True
  is_valid: True
  jabber_ids_collection_link: u'http://.../~admins/jabber_ids'
  karma: 0
  languages_collection_link: u'http://.../~admins/languages'
  latitude: None
  longitude: None
  mailing_list_auto_subscribe_policy: u'Ask me when I join a team'
  members_collection_link: u'http://.../~admins/members'
  members_details_collection_link: u'http://.../~admins/members_details'
  memberships_details_collection_link: u'http://.../~admins/memberships_details'
  mugshot_link: u'http://.../~admins/mugshot'
  name: u'admins'
  open_membership_invitations_collection_link:
      u'http://.../~admins/open_membership_invitations'
  participants_collection_link: u'http://.../~admins/participants'
  preferred_email_address_link: None
  proposed_members_collection_link: u'http://.../~admins/proposed_members'
  renewal_policy: u'invite them to apply for renewal'
  resource_type_link: u'http://.../#team'
  self_link: u'http://.../~admins'
  sub_teams_collection_link: u'http://.../~admins/sub_teams'
  subscription_policy: u'Moderated Team'
  super_teams_collection_link: u'http://.../~admins/super_teams'
  team_description: u'Launchpad Administrators'
  team_owner_link: u'http://.../~sabdfl'
  time_zone: None
  visibility: u'Public'
  wiki_names_collection_link: u'http://.../~admins/wiki_names'

A collection may be scoped to an element:

  >>> result = webservice.get("/~admins/members").jsonBody()
  >>> result['resource_type_link']
  u'http://.../#person-page-resource'
  >>> team_members = sorted(
  ...     result['entries'], key=itemgetter('name'))
  >>> len(team_members)
  5
  >>> team_members[0]['name']
  u'carlos'
  >>> team_members[-1]['name']
  u'spiv'

  >>> result = webservice.get("/~spiv/members")
  >>> list(result.jsonBody()['entries'])
  []


== Custom operations ==

A collection may expose custom named operations in response to GET
requests. A named operation may do anything consistent with the nature
of a GET request, but it's usually used to serve search results. The
custom operation to be invoked is named in the query string's
'ws.op' argument. Here's a custom operation on the collection of
people, called 'people'.

  >>> def search_people(text, start=0):
  ...     return webservice.get(
  ...         "/people?ws.op=find&text=%s&ws.start=%s" %
  ...             (text, start)).jsonBody()

A custom operation that returns a list of objects is paginated, just
like a collection.

  >>> s_people = search_people("s")
  >>> s_people['total_size']
  8
  >>> s_people['next_collection_link']
  u'http://.../people?text=s&ws.op=find&ws.start=5&ws.size=5'
  >>> sorted(p['name'] for p in s_people['entries'])
  [u'keybuk', u'salgado', u'sigurd-ubuntu', u'sjoerd', u'stevea']

  >>> s_people_batch_2 = search_people("s", 5)
  >>> sorted(p['name'] for p in s_people_batch_2['entries'])
  [u'skacel', u'stub', u'ubuntu-team']

Just as a collection may be empty, a custom operation may return an
empty list of results:

  >>> empty_list = search_people("nosuchperson")
  >>> empty_list['total_size']
  0
  >>> [p['name'] for p in empty_list['entries']]
  []

Custom operations may have custom error handling.

  >>> print webservice.get("/~ubuntu-team?ws.op=getMembersByStatus")
  HTTP/1.1 400 Bad Request
  ...
  status: Required input is missing.

A collection may also expose named operations in response to POST
requests. These operations are usually factories. Here's a helper
method that creates a new team by invoking a factory operation on
the collection of people.

  >>> def create_team(name, display_name):
  ...     return webservice.named_post(
  ...         "/people", "newTeam", {},
  ...         name=name, display_name=display_name)

  >>> print webservice.get('/~serviceteam')
  HTTP/1.1 404 Not Found
  ...

  >>> print create_team("serviceteam", "Service Team")
  HTTP/1.1 201 Created
  ...
  Location: http://.../~serviceteam
  ...

  >>> print webservice.get('/~serviceteam')
  HTTP/1.1 200 Ok
  ...

  >>> print create_team("serviceteam2", "Service Team")
  HTTP/1.1 201 Created
  ...
  Location: http://.../~serviceteam2
  ...

  >>> print webservice.get('/~serviceteam2')
  HTTP/1.1 200 Ok
  ...

Standard team-creation rules apply. For instance, you can't create a
team with a name that's taken.

  >>> print create_team("serviceteam", "Name already taken")
  HTTP/1.1 400 Bad Request
  ...
  name: serviceteam is already in use by another person or team.

A POST request has no meaning right now unless it specifies a custom
operation.

  >>> print webservice.post("/people", 'text/plain', '')
  HTTP/1.1 400 Bad Request
  ...
  No operation name given.

You can't invoke a nonexistent operation:

  >>> print webservice.named_post("/people", "nosuchop", {})
  HTTP/1.1 400 Bad Request
  ...
  No such operation: nosuchop
