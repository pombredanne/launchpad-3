= Incomplete bugs =

Bugs can have their status set to 'Incomplete', to indicate that more
information is required before they can be confirmed.

No Privileges Person opens a bug and sets its status to 'Incomplete'.

    >>> user_browser.open(
    ...     'http://bugs.launchpad.dev/jokosher/+bug/11/+editstatus')
    >>> user_browser.getControl('Status').value = ['Incomplete']
    >>> user_browser.getControl('Save Changes').click()
    >>> print extract_text(
    ...     find_tags_by_class(user_browser.contents, 'statusINCOMPLETE')[0])
    Incomplete

No Privileges Person can now search for the bug using the advanced
search form.

    >>> user_browser.open(
    ...     'http://bugs.launchpad.dev/jokosher/+bugs?advanced=1')

Bugs that have been marked 'Incomplete' but for which no new information
was supplied (through comments) are 'Incomplete (without response)'.

    >>> user_browser.getControl(name='field.status:list').value = (
    ...     ['INCOMPLETE_WITHOUT_RESPONSE'])
    >>> user_browser.getControl('Search', index=1).click()
    >>> find_tag_by_id(user_browser.contents, 'buglisting').findChild('a')
    <a href="/jokosher/+bug/11">...</a>

Bugs that have been marked incomplete and for which new information was
supplied are 'Incomplete (with response)'.

    >>> user_browser.open('http://bugs.launchpad.dev/jokosher/+bugs?advanced=1')
    >>> user_browser.getControl(name='field.status:list').value = (
    ...     ['INCOMPLETE_WITH_RESPONSE'])
    >>> user_browser.getControl('Search', index=1).click()

The bug No Privileges Person examined earlier does not have any new
information, so he does not see it in the list.

    >>> print find_tag_by_id(user_browser.contents, 'buglisting')
    None

No Privileges Person can supply new information by posting a new
comment for the bug.

    >>> user_browser.open('http://bugs.launchpad.dev/jokosher/+bug/11')
    >>> user_browser.getControl(name='field.comment').value = (
    ...     'More information here.')
    >>> user_browser.getControl('Save Changes', index=1).click()

    >>> import transaction
    >>> transaction.commit()

He tries again to find that bug using the advanced search form.

    >>> user_browser.open('http://bugs.launchpad.dev/jokosher/+bugs?advanced=1')
    >>> user_browser.getControl(name='field.status:list').value = (
    ...     ['INCOMPLETE_WITH_RESPONSE'])
    >>> user_browser.getControl('Search', index=1).click()
    >>> find_tag_by_id(user_browser.contents, 'buglisting').findChild('a')
    <a href="/jokosher/+bug/11">...</a>

The bug is there, since he supplied new information in a comment. No
Privileges Person makes sure that it no longer is in the list of
incomplete bugs without response.

    >>> user_browser.open('http://bugs.launchpad.dev/jokosher/+bugs?advanced=1')
    >>> user_browser.getControl(name='field.status:list').value = (
    ...     ['INCOMPLETE_WITH_RESPONSE'])
    >>> user_browser.getControl('Search', index=1).click()
    >>> ('<a href="/jokosher/+bug/11">' in
    ...     find_tag_by_id(user_browser.contents, 'buglisting'))
    False


== Bugs that can expire display a notice ==

Projects that use Launchpad to track bugs will expire 'Incomplete'
bugs after the configured expiration age has passed. The rules
for expiration are documented in `docs/bugtask-expiration.txt`.
A notice is displayed on all bugs that can expire to state that
additional action is required to confirm the bug.

Jokosher uses Launchpad to track bugs, so a notice is displayed
stating that the bug report will be marked for expiration.

    >>> user_browser.open('http://bugs.launchpad.dev/jokosher/+bug/11')
    >>> print extract_text(
    ...     find_tag_by_id(user_browser.contents, 'can-expire'))
    This bug report will be marked for expiration in 59 days if no further
    activity occurs.
    (find out why)

    >>> user_browser.getLink('find out why').url
    'https://help.launchpad.net/BugStatuses'

If the time by which a bug should have been expired has passed but the
bug has not yet been expired, a different message will be displayed,
detailing the amount of time that has passed since the bug's expiration
date. We alter the date_last_updated field of bug 11 to demonstrate this.

    >>> from datetime import timedelta
    >>> from zope.component import getUtility
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.ftests import login, logout
    >>> from canonical.launchpad.interfaces import IBugSet
    >>> login('test@canonical.com')

    >>> bug_11 = getUtility(IBugSet).get(11)
    >>> time_delta = timedelta(days=100)
    >>> bug_11.date_last_updated = bug_11.date_last_updated - time_delta
    >>> flush_database_updates()
    >>> logout()

    >>> user_browser.open('http://bugs.launchpad.dev/jokosher/+bug/11')
    >>> print extract_text(
    ...     find_tag_by_id(user_browser.contents, 'can-expire'))
    This bug report has been marked for expiration, since there has been
    no activity for the last 41 days.
    (find out why)

    >>> user_browser.getLink('find out why').url
    'https://help.launchpad.net/BugStatuses'

== The expirable bug search ==

Users can view a list of expirable bugs via a link on the project's
bug page. To see the behaviour of the bug listing, we need another
expirable bug. No Privileges Person marks another bug as incomplete.

    >>> user_browser.open('http://bugs.launchpad.dev/jokosher/+bug/12')
    >>> user_browser.getControl('Status').value = ['Incomplete']
    >>> user_browser.getControl('Save Changes', index=0).click()

The project's bug page reports the number of bugs that will expire if
they are not confirmed. No Privileges Person sees that Jokosher has 2
bugs that can expire.

    >>> user_browser.getLink('Bugs').click()
    >>> user_browser.title
    'Bugs in Jokosher Audio Editor'

    >>> expirable_bugs_link = user_browser.getLink(
    ...     'incomplete bugs can expire')
    >>> expirable_bugs_link.text
    '2 incomplete bugs can expire'

The link is to the expirable bugs page. No Privileges Person can see
the bug he set to Incomplete previously. He cannot see the search form
or the file-a-bug link because this is a specialized search.

    >>> expirable_bugs_link.click()
    >>> user_browser.title
    'Bugs that can expire in Jokosher Audio Editor'

    >>> contents = find_main_content(user_browser.contents)
    >>> print extract_text(contents.find(
    ...     'td', {'class' : 'batch-navigation-index'}))
    1 ... 2  of 2 results

    >>> buglisting = contents.find('table', id='buglisting')
    >>> for tr in buglisting.tbody.findAll('tr'):
    ...     print extract_text(tr)
    11  Make Jokosher use autoaudiosink  ...
    12  Copy, Cut and Delete operations should work  ...

    >>> user_browser.getControl('Search')
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> user_browser.getLink('Report a bug')
    Traceback (most recent call last):
    ...
    LinkNotFoundError

The listing is sorted in order of most inactive to least inactive. The
bugs at the top of the list will expire before the ones at the bottom.
When No Privileges Person adds a comment to the oldest bug, it is
pushed to the bottom of the list.

    >>> user_browser.getLink('Make Jokosher use autoaudiosink').click()
    >>> user_browser.getControl('Comment', index=1).value = "bump"
    >>> user_browser.getControl('Save Changes', index=1).click()
    >>> user_browser.getLink('Bugs').click()
    >>> user_browser.getLink('incomplete bugs can expire').click()
    >>> contents = find_main_content(user_browser.contents)
    >>> buglisting = contents.find('table', id='buglisting')
    >>> print extract_text(buglisting.thead)
    Summary  Date last updated

    >>> for tr in buglisting.tbody.findAll('tr'):
    ...     print extract_text(tr)
    12  Copy, Cut and Delete operations should work  ...
    11  Make Jokosher use autoaudiosink  ...

When No Privileges Person confirms the bug, the notice is removed.
He sees that the number on expirable bugs is updated when he returns
Jokosher's bug page.

    >>> user_browser.getLink('Make Jokosher use autoaudiosink').click()
    >>> user_browser.getControl('Status').value = ['Confirmed']
    >>> user_browser.getControl('Save Changes', index=0).click()
    >>> print find_tag_by_id(user_browser.contents, 'can-expire')
    None

    >>> user_browser.getLink('Bugs').click()
    >>> expirable_bugs_link = user_browser.getLink(
    ...     'incomplete bug can expire')
    >>> expirable_bugs_link.text
    '1 incomplete bug can expire'

    >>> expirable_bugs_link.click()
    >>> contents = find_main_content(user_browser.contents)
    >>> buglisting = contents.find('table', id='buglisting')
    >>> for tr in buglisting.tbody.findAll('tr'):
    ...     print extract_text(tr)
    12  Copy, Cut and Delete operations should work ...


== Incomplete bugs that do not expire ==

Debian does not use launchpad to track bugs, so its incomplete bugs
cannot expire. No Privileges Person sets a Debian bug to Incomplete,
and does not see the expiration notice.

    >>> user_browser.open(
    ...     'http://bugs.launchpad.dev/debian/+source/mozilla-firefox/+bug/8')
    >>> user_browser.getControl('Status').value = ['Incomplete']
    >>> user_browser.getControl('Save Changes', index=0).click()
    >>> print find_tag_by_id(user_browser.contents, 'can-expire')
    None

If No Privileges Person hacks the URL to see a listing of Debian's
expirable bugs he reads that Debian does not use bug expiration.

    >>> user_browser.open('http://bugs.launchpad.dev/debian/+expirable-bugs')
    >>> print extract_text(find_main_content(user_browser.contents).p)
    This project has not enabled bug expiration. No bugs can expire.
    Project administrator's may choose to enable bug expiration by
    updating the project's details.
