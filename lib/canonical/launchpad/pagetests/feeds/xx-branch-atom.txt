= Atom Feeds For Branches =

Atom feeds produce XML not HTML.  Therefore we must parse the output as XML
using BeautifulStoneSoup instead of BeautifulSoup or the helper functions.

    >>> from BeautifulSoup import BeautifulStoneSoup as BSS
    >>> from BeautifulSoup import SoupStrainer
    >>> from canonical.launchpad.ftests.feeds_helper import (
    ...     parse_entries, parse_ids, parse_links, validate_feed)

Login as the Sample Person.

    >>> browser = setupBrowser(auth='Basic test@canonical.com:test')

== Create some specific branches to use for this test ==

    >>> from canonical.launchpad.ftests import ANONYMOUS, login, logout
    >>> login(ANONYMOUS)
    >>> from canonical.launchpad.testing import (
    ...     LaunchpadObjectFactory, time_counter)
    >>> from datetime import datetime, timedelta
    >>> import pytz
    >>> factory = LaunchpadObjectFactory()
    >>> owner = factory.makePerson(name='mike', displayname='Mike Murphy')
    >>> project = factory.makeProject(name='oh-man')
    >>> product1 = factory.makeProduct(name='fooix', project=project)
    >>> product2 = factory.makeProduct(name='fooey', project=project)
    >>> date_generator = time_counter(
    ...     datetime(2007, 12, 1, tzinfo=pytz.UTC), timedelta(days=1))
    >>> branch = factory.makeBranch(
    ...     owner=owner, product=product1, name='first',
    ...     date_created=date_generator.next())
    >>> branch = factory.makeBranch(
    ...     owner=owner, product=product2, name='second',
    ...     date_created=date_generator.next())
    >>> branch = factory.makeBranch(
    ...     owner=owner, product=product1, name='third',
    ...     date_created=date_generator.next())
    >>> branch = factory.makeBranch(
    ...     owner=owner, product=product2, name='fourth',
    ...     date_created=date_generator.next())
    >>> logout()


== Feed for a person's branches ==

The feed for a person's branches will show the most recent 25 branches
which will include an entry for each branch.

    >>> anon_browser.open('http://feeds.launchpad.dev/~mike/branches.atom')
    >>> validate_feed(anon_browser.contents,
    ...               anon_browser.headers['content-type'],
    ...               anon_browser.url)
    No Errors
    >>> BSS(anon_browser.contents).title.contents
    [u'Branches for Mike Murphy']
    >>> ids = parse_ids(anon_browser.contents)

Ignore the date associated with the id of 'mike' as this is the date created
of the person, which will be different each time the test is run.

    >>> for id_ in ids:
    ...     print id_
    <id>tag:launchpad.net,...:/code/~mike</id>
    <id>tag:launchpad.net,2007-12-04:/code/~mike/fooey/fourth</id>
    <id>tag:launchpad.net,2007-12-03:/code/~mike/fooix/third</id>
    <id>tag:launchpad.net,2007-12-02:/code/~mike/fooey/second</id>
    <id>tag:launchpad.net,2007-12-01:/code/~mike/fooix/first</id>

Ensure the self link is correct and there is only one.

    >>> links = parse_links(anon_browser.contents, rel="self")
    >>> for link in links:
    ...     print link
    <link rel="self" href="http://feeds.launchpad.dev/~mike/branches.atom" />

The <update> field for the feed will be the most recent value for the
updated field in all of the entries.

    >>> strainer = SoupStrainer('updated')
    >>> updated_dates = [extract_text(tag) for tag in BSS(anon_browser.contents,
    ...                  parseOnlyThese=strainer)]
    >>> feed_updated = updated_dates[0]
    >>> entry_dates = sorted(updated_dates[1:], reverse=True)
    >>> assert feed_updated == entry_dates[0], (
    ...     "Feed <update> value is not the same as latest entry.")

Even though we are logged in, all access via feeds.launchpad.dev are
forced to be anonymous, so the owner's email is hidden:

    >>> 'foo@localhost' in anon_browser.contents
    False
    >>> 'email address hidden' in browser.contents
    True

If an anonymous user fetches the same feed the email addresses will
still be hidden:

    >>> anon_browser.open('http://feeds.launchpad.dev/~name12/branches.atom')
    >>> validate_feed(anon_browser.contents,
    ...              anon_browser.headers['content-type'], anon_browser.url)
    No Errors
    >>> BSS(anon_browser.contents).title.contents
    [u'Branches for Sample Person']
    >>> 'foo@localhost' in anon_browser.contents
    False
    >>> 'email address hidden' in anon_browser.contents
    True

If a branch is marked private it will not be displayed.  The Landscape
developers team has two branches which are both private.

    >>> browser.open('http://code.launchpad.dev/~landscape-developers')
    >>> table = find_tag_by_id(browser.contents, 'branchtable')
    >>> for row in table.tbody.fetch('tr'):
    ...     print extract_text(row)
    ...     print row.first('img').get('title')
    ~name12/landscape/feature-x  New  ...
    Private
    ~landscape-developers/landscape/trunk  New  ...
    Private

If we look at the feed for landscape developers there will be no
branches listed, just an id for the feed.

    >>> browser.open('http://feeds.launchpad.dev/~landscape-developers/branches.atom')
    >>> validate_feed(browser.contents,
    ...              browser.headers['content-type'], browser.url)
    No Errors
    >>> BSS(browser.contents).title.contents
    [u'Branches for Landscape Developers']
    >>> ids = parse_ids(browser.contents)
    >>> for id_ in ids:
    ...     print id_
    <id>tag:launchpad.net,2006-07-11:/code/~landscape-developers</id>


== Feed for a product's branches ==

The feed for a product's branches will show the most recent 25 branches
which will include an entry for each branch.

    >>> browser.open('http://feeds.launchpad.dev/firefox/branches.atom')
    >>> validate_feed(browser.contents,
    ...              browser.headers['content-type'], browser.url)
    No Errors
    >>> BSS(browser.contents).title.contents
    [u'Branches for Mozilla Firefox']
    >>> ids = parse_ids(browser.contents)
    >>> for id_ in ids:
    ...     print id_
    <id>tag:launchpad.net,2004-09-24:/code/firefox</id>
    <id>tag:launchpad.net,2006-10-16:/code/~sabdfl/firefox/release-0.8</id>
    <id>tag:launchpad.net,2006-10-16:/code/~sabdfl/firefox/release-0.9</id>
    <id>tag:launchpad.net,2006-10-16:/code/~sabdfl/firefox/release--0.9.1</id>
    <id>tag:launchpad.net,2006-10-16:/code/~sabdfl/firefox/release-0.9.2</id>
    <id>tag:launchpad.net,2006-10-16:/code/~name12/firefox/main</id>

    >>> links = parse_links(browser.contents, rel="self")
    >>> for link in links:
    ...     print link
    <link rel="self" href="http://feeds.launchpad.dev/firefox/branches.atom" />

The <update> field for the feed will be the most recent value for the
updated field in all of the entries.

    >>> strainer = SoupStrainer('updated')
    >>> updated_dates = [extract_text(tag) for tag in BSS(browser.contents,
    ...                  parseOnlyThese=strainer)]
    >>> feed_updated = updated_dates[0]
    >>> entry_dates = sorted(updated_dates[1:], reverse=True)
    >>> assert feed_updated == entry_dates[0], (
    ...     "Feed <update> value is not the same as latest entry.")


== Feed for a project's branches ==

The feed for a project's branches will show the most recent 25 branches
which will include an entry for each branch.

    >>> browser.open('http://feeds.launchpad.dev/mozilla/branches.atom')
    >>> validate_feed(browser.contents,
    ...              browser.headers['content-type'], browser.url)
    No Errors
    >>> BSS(browser.contents).title.contents
    [u'Branches for the Mozilla Project']
    >>> ids = parse_ids(browser.contents)
    >>> for id_ in ids:
    ...     print id_
    <id>tag:launchpad.net,2004-09-24:/code/mozilla</id>
    <id>tag:launchpad.net,2006-10-16:/code/~sabdfl/firefox/release-0.8</id>
    <id>tag:launchpad.net,2006-10-16:/code/~sabdfl/firefox/release-0.9</id>
    <id>tag:launchpad.net,2006-10-16:/code/~sabdfl/firefox/release--0.9.1</id>
    <id>tag:launchpad.net,2006-10-16:/code/~sabdfl/firefox/release-0.9.2</id>
    <id>tag:launchpad.net,2006-10-16:/code/~stevea/thunderbird/main</id>
    <id>tag:launchpad.net,2006-10-16:/code/~name12/firefox/main</id>

    >>> links = parse_links(browser.contents, rel="self")
    >>> for link in links:
    ...     print link
    <link rel="self" href="http://feeds.launchpad.dev/mozilla/branches.atom" />

The <update> field for the feed will be the most recent value for the
updated field in all of the entries.

    >>> strainer = SoupStrainer('updated')
    >>> updated_dates = [extract_text(tag) for tag in BSS(browser.contents,
    ...                  parseOnlyThese=strainer)]
    >>> feed_updated = updated_dates[0]
    >>> entry_dates = sorted(updated_dates[1:], reverse=True)
    >>> assert feed_updated == entry_dates[0], (
    ...     "Feed <update> value is not the same as latest entry.")


== Feed for a single branch ==

A single branch can have an Atom feed with each revision being a
different entry.

    >>> url = 'http://feeds.launchpad.dev/~sabdfl/firefox/release--0.9.1/branch.atom'
    >>> browser.open(url)
    >>> validate_feed(browser.contents,
    ...              browser.headers['content-type'], browser.url)
    No Errors
    >>> BSS(browser.contents).title.contents
    [u'Latest Revisions for Branch Mozilla Firefox 0.9.1']
    >>> print browser.url
    http://feeds.launchpad.dev/~sabdfl/firefox/release--0.9.1/branch.atom

The first <id> in a feed identifies the feed.  Each entry then has its
own <id>, which in the case of a single branch feed will be identical.

    >>> soup = BSS(browser.contents, parseOnlyThese=SoupStrainer('id'))
    >>> ids = parse_ids(browser.contents)
    >>> for id_ in ids:
    ...     print id_
    <id>tag:launchpad.net,2006-10-16:/code/~sabdfl/firefox/release--0.9.1</id>
    <id>tag:launchpad.net,2005-03-09:/code/~sabdfl/firefox/release--0.9.1/revision/1</id>
    >>> links = parse_links(browser.contents, rel="self")
    >>> for link in links:
    ...     print link
    <link rel="self" href="http://feeds.launchpad.dev/~sabdfl/firefox/release--0.9.1/branch.atom" />
    >>> strainer = SoupStrainer('updated')
    >>> updated_dates = [extract_text(tag) for tag in BSS(browser.contents,
    ...                  parseOnlyThese=strainer)]
    >>> assert updated_dates[0] == updated_dates[1]
    ...     "Feed <update> value is not the same as latest entry.")
