= Staging migration =

Every once in a while we copy production's database over to staging so that
testing can be done there on the real database, but without any chance of
messing up the real site.  When this happens, we also need to synchronize
production's Mailman directories so that the mailing lists all stay consistent
(well, within the limits of the inherent race conditions).  To do this, we use
scripts/mlist-sync.py.


== Synchronization ==

It's actually fairly difficult to recreate what happens during the staging
sync, but we can get close.  Start off by creating a few mailing lists.  When
the mailing lists are created, messages get sent to the members of the team
informing them of their new list.  We can ignore these.

    >>> from canonical.launchpad.ftests import (
    ...     login, logout, mailinglists_helper)

    >>> login('foo.bar@canonical.com')
    >>> team_one = mailinglists_helper.new_team('staging-one')
    >>> team_two = mailinglists_helper.new_team('staging-two')
    >>> transaction.commit()
    >>> logout()
    >>> browser = Browser('no-priv@canonical.com:test')

    >>> from canonical.launchpad.mailman.testing import helpers
    >>> helpers.apply_for_list(browser, 'staging-one')
    >>> helpers.apply_for_list(browser, 'staging-two')

    >>> list_one = helpers.review_list('staging-one')
    >>> list_two = helpers.review_list('staging-two')

Anne subscribes to two mailing lists.  Bart and Cris both subscribe to only
one of the mailing lists.

    >>> helpers.subscribe('Anne', 'staging-one')
    >>> helpers.subscribe('Anne', 'staging-two')
    >>> helpers.subscribe('Bart', 'staging-one')
    >>> helpers.subscribe('Cris', 'staging-two')

A bunch of messages are sent to the mailing lists.

    >>> smtpd.reset()
    >>> from Mailman.Post import inject
    >>> inject('staging-one', """\
    ... From: anne.person@example.com
    ... To: staging-one@lists.launchpad.dev
    ... Subject: hello
    ... Message-ID: <first-injection>
    ...
    ... Hello team!
    ... """)

    # Wait for all recipients to receive the message.
    >>> for index in range(3):
    ...     smtpd_watcher.wait_for_mbox_delivery('first-injection')

    >>> inject('staging-two', """\
    ... From: anne.person@example.com
    ... To: staging-two@lists.launchpad.dev
    ... Subject: hello
    ... Message-ID: <second-injection>
    ...
    ... Hello team!
    ... """)

    # Wait for all recipients to receive the message.
    >>> for index in range(3):
    ...     smtpd_watcher.wait_for_mbox_delivery('second-injection')

    >>> inject('staging-one', """\
    ... From: bart.person@example.com
    ... To: staging-one@lists.launchpad.dev
    ... Subject: hello
    ... Message-ID: <third-injection>
    ...
    ... Hello team!
    ... """)

    # Wait for all recipients to receive the message.
    >>> for index in range(3):
    ...     smtpd_watcher.wait_for_mbox_delivery('third-injection')

    >>> inject('staging-two', """\
    ... From: cris.person@example.com
    ... To: staging-two@lists.launchpad.dev
    ... Subject: hello
    ... Message-ID: <fourth-injection>
    ...
    ... Hello team!
    ... """)

    # Wait for all recipients to receive the message.
    >>> for index in range(3):
    ...     smtpd_watcher.wait_for_mbox_delivery('fourth-injection')

    >>> from operator import itemgetter
    >>> for message in sorted(smtpd.getMessages(), key=itemgetter('sender')):
    ...     print message['sender']
    staging-one-bounces+anne.person=example.com@lists.launchpad.dev
    staging-one-bounces+anne.person=example.com@lists.launchpad.dev
    staging-one-bounces+archive=mail-archive.dev@lists.launchpad.dev
    staging-one-bounces+archive=mail-archive.dev@lists.launchpad.dev
    staging-one-bounces+bart.person=example.com@lists.launchpad.dev
    staging-one-bounces+bart.person=example.com@lists.launchpad.dev
    staging-two-bounces+anne.person=example.com@lists.launchpad.dev
    staging-two-bounces+anne.person=example.com@lists.launchpad.dev
    staging-two-bounces+archive=mail-archive.dev@lists.launchpad.dev
    staging-two-bounces+archive=mail-archive.dev@lists.launchpad.dev
    staging-two-bounces+cris.person=example.com@lists.launchpad.dev
    staging-two-bounces+cris.person=example.com@lists.launchpad.dev

Give one of the mailing lists a contact address, to further simulate what the
sync script has to deal with.

    >>> from canonical.launchpad.ftests import login, logout
    >>> from canonical.launchpad.interfaces import (
    ...     EmailAddressStatus, IEmailAddressSet, IPersonSet)
    >>> from zope.component import getUtility
    >>> login('foo.bar@canonical.com')
    >>> team = getUtility(IPersonSet).getByName('staging-two')
    >>> email = getUtility(IEmailAddressSet).new(
    ...     'contact@example.com', team, EmailAddressStatus.VALIDATED)
    >>> team.setContactAddress(email)
    >>> logout()
    >>> transaction.commit()

Now we need to simulate the difference between the staging and production
databases.  To do this, we'll use a helper, but first we need to stop Mailman.

    >>> from canonical.launchpad.mailman import runmailman
    >>> from canonical.testing.layers import LayerProcessController
    >>> runmailman.stop_mailman(
    ...     quiet=True, config=LayerProcessController.appserver_config)
    >>> qrunner_watcher.wait_for_shutdown()

In a typical synchronization situation, the production Launchpad database is
copied to staging at a different time than when the production Mailman data is
copied.  Synchronization does not happen directly to staging's Mailman
directory, but instead, it's rsync'd to a temporary location on staging, and
then sync'd by this script from the local temporary location.  This ensures
that the final sync happens pretty quickly and is not dependent on any
connection between production and staging, but it means that the Mailman data
may not exactly match the state of the Launchpad database.

For example, it's is possible that a mailing list exists in Launchpad but not
in the Mailman data if the Mailman data was copied first.  Because of the way
we operationally copy data from production to staging, this generally won't
happen, so we don't handle it.

The reverse is also possible -- there could be a mailing list in Mailman
that's not in Launchpad if the Mailman data was copied second (because the
list was created between the time the Launchpad database was copied and the
Mailman data was copied).  In this case, we just delete the list from Mailman.
That way if the list is created in Launchpad on staging, the Mailman list will
also be created.

    >>> from canonical.launchpad.mailman.testing import sync
    >>> sync_details = sync.prepare_for_sync()

Our simulation now has a staging database that has been copied, but the
Mailman data has not yet been copied.  Let's take a look at what staging's
Mailman and Launchpad data looks like, before the Mailman data is sync'd.
Note that fake-team is created by the prepare_for_sync() helper and
illustrates a mailing list that exists in Mailman but not in Launchpad.

    >>> sync.dump_list_info()
    fake-team
        lists.launchpad.dev http://lists.launchpad.dev/mailman/
        No Launchpad team: fake-team
    staging-one
        lists.prod.launchpad.dev http://lists.prod.launchpad.dev/
        staging-one@lists.prod.launchpad.dev
    staging-two
        lists.prod.launchpad.dev http://lists.prod.launchpad.dev/
        contact@example.com
        staging-two@lists.prod.launchpad.dev

Do the Mailman synchronization by calling the script.  We must set the
LPCONFIG environment variable for the script to find the correct
launchpad.conf file.

    >>> import os
    >>> import sys
    >>> from subprocess import *
    >>> proc = Popen(
    ...     ('scripts/mlist-sync.py', '--hostname',
    ...      'lists.prod.launchpad.dev', sync_details.source_dir),
    ...     stdout=PIPE, stderr=PIPE,
    ...     cwd=LayerProcessController.appserver_config.root,
    ...     env=dict(LPCONFIG='testrunner-appserver',
    ...              PYTHONPATH=os.pathsep.join(sys.path)))
    >>> stdout, stderr = proc.communicate()

    # Ignore stdout and stderr, but print the return code.  stdout should be
    # completely empty and stderr really is uninteresting unless things are
    # broken.  It's also problematic because of the way log files are printed
    # (breaking doctest ellipses).
    >>> proc.returncode
    0

    # This is useful for debugging when things go wrong.
    >>> assert proc.returncode == 0, stderr

If the script ran correctly, Mailman should only know about the two mailing
lists we created above, and not the fake-team list.  Also, the host_name and
web_page_url attributes for these lists should not point to 'prod'.

    >>> from canonical.database.sqlbase import rollback
    >>> rollback()
    >>> sync.dump_list_info()
    staging-one
        lists.launchpad.dev http://lists.launchpad.dev/mailman/
        staging-one@lists.launchpad.dev
    staging-two
        lists.launchpad.dev http://lists.launchpad.dev/mailman/
        contact@example.com
        staging-two@lists.launchpad.dev


== Clean up ==

    >>> sync_details.cleanup()
    >>> runmailman.start_mailman(
    ...     quiet=True, config=LayerProcessController.appserver_config)
    >>> qrunner_watcher.wait_for_restart()
