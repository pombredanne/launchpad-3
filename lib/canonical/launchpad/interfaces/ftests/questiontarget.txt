= IQuestionTarget Interface =

Launchpad includes an answer tracker. Questions are associated to
objects implementing IQuestionTarget. This file documents that interface
and can be used to validate implementation of this interface on a
particular object. (This object is made available through the 'target'
variable which is defined outside of this file, usually by a
LaunchpadFunctionalTestCase. This instance shouldn't have any questions
associated with it at the start of the test.)

    # Some parts of the IQuestionTarget interface are only accessible
    # to a registered user.
    >>> login('no-priv@canonical.com')

    >>> from zope.component import getUtility
    >>> from zope.interface.verify import verifyObject
    >>> from canonical.launchpad.interfaces import IQuestionTarget

    >>> verifyObject(IQuestionTarget, target)
    True

== newQuestion() ==

Questions are always owned by a registered user.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> sample_person = getUtility(IPersonSet).getByEmail(
    ...     'test@canonical.com')

The newQuestion() method is used to create question that will be associated
with the target. It takes as parameters the question's owner, title and
description. It also takes an optional parameter 'datecreated' parameter
which defaults to UTC_NOW.

    # Let's define now to a know value.
    >>> from datetime import datetime, timedelta
    >>> from pytz import UTC
    >>> now = datetime.now(UTC)

    >>> question = target.newQuestion(sample_person, 'New question',
    ...     'Question description', datecreated=now)
    >>> print question.title
    New question
    >>> print question.description
    Question description
    >>> question.owner == sample_person
    True
    >>> question.datecreated == now
    True
    >>> question.datelastquery == now
    True

The created question starts in the 'Open' status and should have the owner
subscribed to the question.

    >>> question.status.title
    'Open'

    >>> sample_person in [s.person for s in question.subscriptions]
    True

Question can be written in any languages supported in Launchpad. The
language of the request is available in the 'language' attribute. By
default, requests are assumed to be written in English:

    >>> print question.language.code
    en

It is possible to create question in another language than English. One
just need to pass the language in which the question is written in the
language parameter.

    >>> from canonical.launchpad.interfaces import ILanguageSet
    >>> french = getUtility(ILanguageSet)['fr']
    >>> question = target.newQuestion(sample_person, "De l'aide S.V.P.",
    ...     "Pouvez-vous m'aider?", language=french,
    ...     datecreated=now + timedelta(seconds=30))
    >>> print question.language.code
    fr

Anonymous users cannot use newQuestion():

    >>> login(ANONYMOUS)
    >>> question = target.newQuestion(sample_person, 'This will fail',
    ...     'Failed?')
    Traceback (most recent call last):
      ...
    Unauthorized...

== getQuestion() ==

The getQuestion() method is used to retrieve a question by id for a
particular target.

    >>> target.getQuestion(question.id) == question
    True

If you pass in a non-existent id or a question for a different target, the
method must return None.

    >>> target.getQuestion(2) is None
    True
    >>> target.getQuestion(12345) is None
    True

== Creating some additional questions ==

For the following methods, we will require some more questions. Create five
new questions. Odd questions will be owned by foo_bar and even questions will be
owned by sample_person.

    >>> login('no-priv@canonical.com')
    >>> foo_bar = getUtility(IPersonSet).getByEmail('foo.bar@canonical.com')
    >>> questions = []
    >>> for num in range(5):
    ...     if num % 2:
    ...         owner = foo_bar
    ...     else:
    ...         owner = sample_person
    ...     description = ('Support request description%d.\n'
    ...         'This request index is %d.') % (num, num)
    ...     questions.append(target.newQuestion(
    ...         owner, 'Question title%d' % num, description,
    ...         datecreated=now+timedelta(minutes=num+1)))

For more variety, we will set the status of the last to INVALID and the
fourth one to ANSWERED.

    >>> login('foo.bar@canonical.com')
    >>> foo_bar = getUtility(IPersonSet).getByEmail('foo.bar@canonical.com')
    >>> message = questions[-1].reject(
    ...     foo_bar, 'Invalid question.', datecreated=now+timedelta(hours=1))
    >>> message = questions[3].giveAnswer(
    ...     sample_person, 'This is your answer.',
    ...     datecreated=now+timedelta(hours=1))

Also add a reply from the owner on the first of these.

    >>> login('test@canonical.com')
    >>> message = questions[0].giveInfo(
    ...     'I think I forgot something.', datecreated=now+timedelta(hours=4))

And create another one that will also have the word 'new' in its
description.

    >>> question = target.newQuestion(sample_person, 'Another question',
    ...     'Another new question that is actually very new.',
    ...     datecreated=now+timedelta(hours=1))
    >>> login(ANONYMOUS)

    # Flush those changes to the database.
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()

== searchQuestions() ==

The searchQuestions() method is used to search for questions.

=== search_text ===

The search_text parameter will select the questions that contain the
passed in text. (The standard text searching algorithm is used, see
textsearching.txt.)

    >>> for t in target.searchQuestions(search_text='new'):
    ...     print t.title
    New question
    Another question

The results here are sorted by relevancy. (In the last questions, 'New'
appeared in the description which makes it less relevant than when the
word appears in the title.)

=== status ===

The searchQuestions() method can also filter questions by status:

    >>> from canonical.launchpad.interfaces import QuestionStatus
    >>> for t in target.searchQuestions(status=QuestionStatus.OPEN):
    ...     print t.title
    Another question
    Question title2
    Question title1
    Question title0
    De l'aide S.V.P.
    New question

In this previous example, because there is no sort text, the
default sort order is from newest to oldest.

    >>> for t in target.searchQuestions(status=QuestionStatus.INVALID):
    ...     print t.title
    Question title4

You can also pass in a list of status, and you can also use the
search_text and status parameters at the same time. This will search
OPEN and INVALID questions with the word 'index'

    >>> for t in target.searchQuestions(search_text='request index',
    ...         status=(QuestionStatus.OPEN, QuestionStatus.INVALID)):
    ...     print t.title
    Question title4
    Question title2
    Question title1
    Question title0

=== sort ===

You can control the sort order by passing one of the constants defined
in QuestionSort. (We already saw the NEWEST_FIRST and RELEVANCY sort
order).

You can sort also from oldest to newest using the OLDEST_FIRST constant:

    >>> from canonical.launchpad.interfaces import QuestionSort

    >>> for t in target.searchQuestions(search_text='new',
    ...                               sort=QuestionSort.OLDEST_FIRST):
    ...     print t.title
    New question
    Another question

You can sort by status, (the status order is OPEN, NEEDSINFO, ANSWERED,
SOLVED, EXPIRED, INVALID), this also sorts from newest to oldest as a
secondary key.

    >>> for t in target.searchQuestions(search_text='request index',
    ...                               status=None,
    ...                               sort=QuestionSort.STATUS):
    ...     print t.status.title, t.title
    Open Question title2
    Open Question title1
    Open Question title0
    Answered Question title3
    Invalid Question title4

(In the previous example, we used status=None to search for all
statuses, by default INVALID and EXPIRED questions are excluded.)

If there is no search_text and the requested sort order is RELEVANCY,
the questions will be sorted NEWEST_FIRST.

    >>> for t in target.searchQuestions(sort=QuestionSort.RELEVANCY):
    ...     print t.title
    Another question
    Question title3
    Question title2
    Question title1
    Question title0
    De l'aide S.V.P.
    New question

('Question title4' is not shown in this case because it has INVALID as
its status.)

The RECENT_OWNER_ACTIVITY sort order sorts first questions which recently
received a new message by their owner. (It effectively sorts
descending on the datelastquery attribute.)

    >>> for t in target.searchQuestions(sort=QuestionSort.RECENT_OWNER_ACTIVITY):
    ...     print t.title
    Question title0
    Another question
    Question title3
    Question title2
    Question title1
    De l'aide S.V.P.
    New question

(Question title0 sorts first because it had a message from its owner
after the others were created.)

=== owner ===

You can also find question owner by a particular user by using the owner
parameter.

    >>> for t in target.searchQuestions(owner=foo_bar):
    ...     print t.title
    Question title3
    Question title1

=== language ===

The language criteria can be used to select only questions written in a
particular language.

    >>> english = getUtility(ILanguageSet)['en']
    >>> for t in target.searchQuestions(language=french):
    ...     print t.title
    De l'aide S.V.P.

    >>> for t in target.searchQuestions(language=[english, french]):
    ...     print t.title
    Another question
    Question title3
    Question title2
    Question title1
    Question title0
    De l'aide S.V.P.
    New question

=== needs_attention_from ===

You can also search among the questions that needs the attention of
somebody. A question needs the attention of a user if he owns it and that
it is in the NEEDSINFO or ANSWERED state. Questions on which the user gave
an answer or requested for more information and that are back in the
OPEN state are also included.

    # One of Sample Person's question gets to need attention from Foo Bar.
    >>> login('foo.bar@canonical.com')
    >>> message = questions[0].requestInfo(
    ...     foo_bar, 'Do you have a clue?',
    ...     datecreated=now+timedelta(hours=1))
    >>> login('test@canonical.com')
    >>> message = questions[0].giveInfo(
    ... 'I do, now please help me.', datecreated=now+timedelta(hours=2))

    # Another one of Foo Bar's question needs attention.
    >>> message = questions[1].requestInfo(
    ...     sample_person, 'And you, do you have a clue?',
    ...     datecreated=now+timedelta(hours=1))

    # Flush those changes to the database.
    >>> flush_database_updates()
    >>> login(ANONYMOUS)

    >>> for t in target.searchQuestions(needs_attention_from=foo_bar):
    ...     print t.status.title, t.title, t.owner.displayname
    Answered Question title3 Foo Bar
    Needs information Question title1 Foo Bar
    Open Question title0 Sample Person

=== unsupported ===

The 'unsupported' criteria is used to select questions that are in a
language that is not spoken by any of the Support Contacts.

    >>> for t in target.searchQuestions(unsupported=True):
    ...     print t.title
    De l'aide S.V.P.

== findSimilarQuestions() ==

The method findSimilarQuestions() can be use to find questions similar to a
sentence. The questions don't have to contain all the words of the sentence,
just some.

    >>> for t in target.findSimilarQuestions('new questions with a title'):
    ...     print t.title
    New question
    Another question

In this case, it returned the same results than with the search 'new' because
all other words in the sentence are either common ('question', 'title') or stop
words ('with', 'a').

== Answer contacts ==

Target can have answer contacts. The list of answer contacts for a
target is available through the answer_contacts attribute.

    >>> list(target.answer_contacts)
    []

There is also a direct_answer_contacts which includes only the
answer contacts registered explicitly on the question target. (In
general, it will be equal to answer_contacts attribute, but some
IQuestionTarget implementations may inherit answer contacts
from other context. In these cases, that attribute would only contain
the answer contacts defined in the current IQuestionTarget context.)

    >>> list(target.direct_answer_contacts)
    []

You add an answer contact by using the addAnswerContact method. This
is only available to registered users.

    >>> name18 = getUtility(IPersonSet).getByName('name18')
    >>> target.addAnswerContact(name18)
    Traceback (most recent call last):
      ...
    Unauthorized...
    >>> login('no-priv@canonical.com')

This method will return True when the contact was added the list and
False when it was already on the list:

    >>> target.addAnswerContact(name18)
    True
    >>> [p.name for p in target.answer_contacts]
    [u'name18']
    >>> [p.name for p in target.direct_answer_contacts]
    [u'name18']
    >>> target.addAnswerContact(name18)
    False

An answer contact must have at least one language among his
preferred languages.

    >>> sample_person = getUtility(IPersonSet).getByName('name12')
    >>> sample_person.languages.count()
    0
    >>> target.addAnswerContact(sample_person)
    Traceback (most recent call last):
      ...
    AssertionError: An Answer Contact must speak a language...

Answer contacts can be removed by using the removeAnswerContact()
method. Like its counterpart, it returns True when the answer contact
was removed and False when the person wasn't on the answer contact
list.

    >>> target.removeAnswerContact(name18)
    True
    >>> list(target.answer_contacts)
    []
    >>> list(target.direct_answer_contacts)
    []
    >>> target.removeAnswerContact(name18)
    False

Only registered users can remove an answer contact:

    >>> login(ANONYMOUS)
    >>> target.removeAnswerContact(name18)
    Traceback (most recent call last):
      ...
    Unauthorized...

== Supported Languages ==

The supported languages for a given IQuestionTarget are given by
getSupportedLanguages(). The supported languages of a question target
include all languages spoken by at least one of its answer contacts,
with the exception of all English variations. English is the assumed
language for support when there are no answer contacts.

    >>> [lang.code for lang in target.getSupportedLanguages()]
    [u'en']

Let's add some answer contacts which speak different languages.

    >>> login('carlos@canonical.com')
    >>> carlos = getUtility(IPersonSet).getByName('carlos')
    >>> [lang.code for lang in carlos.languages]
    [u'ca', u'en', u'es']
    >>> target.addAnswerContact(carlos)
    True

Note that daf has en_GB as one of his preferred languages...

    >>> login('daf@canonical.com')
    >>> daf = getUtility(IPersonSet).getByName('daf')
    >>> [lang.code for lang in daf.languages]
    [u'en_GB', u'ja', u'cy']
    >>> target.addAnswerContact(daf)
    True

... but en_GB is not included in the target's supported languages,
because we convert all English variants to English.

    >>> import operator
    >>> [lang.code for lang in sorted(target.getSupportedLanguages(),
    ...                               key=operator.attrgetter('code'))]
    [u'ca', u'cy', u'en', u'es', u'ja']


== getAnswerContactsForLanguage() ==

Continuing from the previous section with Carlos and Daf, the
getAnswerContactsForLanguage() method returns a list of answer contacts
who support the specified language in their preferred languages. Daf
is in the list because he speaks an English variant, which is treated
as English.

    >>> spanish = getUtility(ILanguageSet)['es']
    >>> answer_contacts = target.getAnswerContactsForLanguage(spanish)
    >>> sorted([person.name for person in answer_contacts])
    [u'carlos']

    >>> answer_contacts = target.getAnswerContactsForLanguage(english)
    >>> sorted([person.name for person in answer_contacts])
    [u'carlos', u'daf']


== getQuestionLanguages() ==

The getQuestionLanguages() method returns the set of languages used by all
of the target's questions.

    >>> sorted([language.code for language in target.getQuestionLanguages()])
    [u'en', u'fr']


== pillar ==

The target knows the pillar (Product or Distribution) it belongs to.
The target may return itself, or the pillar object that is appropriate.
In the case of a Product or Distribution, the pillar is the
QuestionTarget. For SourcePackages and DistributionSourcePackages, the
pillar is package's Distribution.

    >>> from canonical.launchpad.interfaces import IDistribution, IProduct
    >>> (IDistribution.providedBy(target.pillar)
    ...     or IProduct.providedBy(target.pillar))
    True
    >>> # Verify that the target.pillar is the pillar in test.globs
    >>> target.pillar.name == pillar.name
    True


== Creating a question from a bug ==

The target can create a question from a bug, and link that bug to the
new question. The question owner is the same as the bug owner. The
question title and description are taken from the bug. The messages on
the bug are copied to the question.

    >>> from canonical.launchpad.interfaces import (
    ...     CreateBugParams, IBugSet, IProductSet)
    >>> jokosher = getUtility(IProductSet)['jokosher']
    >>> bug_params = CreateBugParams(
    ...     title="Print is broken", comment="blah blah blah",
    ...     owner=sample_person)
    >>> bug_params.setBugTarget(product=jokosher)
    >>> jokosher_bug = getUtility(IBugSet).createBug(bug_params)
    >>> bug_message = jokosher_bug.newMessage(
    ...     owner=sample_person, subject="Opps, my mistake",
    ...     content="This is really a question.")

    >>> target_question = target.createQuestionFromBug(jokosher_bug)

    >>> target_question.owner == jokosher_bug.owner
    True
    >>> target_question.title == jokosher_bug.title
    True
    >>> target_question.description == jokosher_bug.description
    True
    >>> question_message = target_question.messages[-1]
    >>> question_message.text_contents == bug_message.text_contents
    True
    
    >>> target_question.owner.displayname
    u'Sample Person'
    >>> target_question.title
    u'Print is broken'
    >>> target_question.description
    u'blah blah blah'
    >>> [bug_link.bug.title for bug_link in target_question.bug_links]
    [u'Print is broken']
    >>> target_question.messages[-1].text_contents
    u'This is really a question.'

The question language is always English because all bugs in Launchpad
are written in English.

    >>> target_question.language.code
    u'en'

