= Reconnecting Database Adapter =

Occasionally the database connections to Postgres may get dropped (due
to upgrades, network problems or bugs).  These outages should not
affect Launchpad for longer than the duration of the problem.

Therefore, Launchpad's main and session database connections must be
able to handle such outages.  We use a special "reconnecting database
connection" wrapper to implement this.

First import a few things for the test:

    >>> import psycopg
    >>> from canonical.config import config
    >>> from canonical.database.ftests import PortForwardTestSetup
    >>> from canonical.ftests.pgsql import PgTestSetup
    >>> from canonical.launchpad.webapp.adapter import (
    ...     ReconnectingDatabaseAdapter, ReconnectingConnection,
    ...     ReconnectingCursor, DisconnectionError)


Set up a port forwarder to the main Postgres database, so that we can
simulate connection drops:

    >>> portforward = PortForwardTestSetup()
    >>> portforward.setUp()


== ReconnectingConnection ==

The ReconnectingConnection class acts as a DB-API connection.  To
create a connection, we need to pass a connection factory function as
an argument to the constructor.  Lets create a reconnecting database
connection that goes through the port forwarding proxy:

    >>> def connection_factory():
    ...     dsn = 'dbname=%s host=localhost port=5555 user=%s' % (
    ...         PgTestSetup().dbname, config.launchpad.dbuser)
    ...     return psycopg.connect(dsn)
    >>> db = ReconnectingConnection(connection_factory)
    >>> db
    <...ReconnectingConnection ...>


This connection object can be used like any other connection:

    >>> cursor = db.cursor()
    >>> cursor.execute('SELECT 1')
    >>> for row in cursor.fetchall():
    ...     print row
    (1,)
    >>> db.rollback()
    >>> cursor.execute('SELECT 1')
    >>> cursor.fetchone()
    (1,)
    >>> db.commit()
    >>> cursor.execute('invalid sql that will abort the transaction')
    Traceback (most recent call last):
      ...
    ProgrammingError: ERROR:  syntax error at or near "invalid"...
    >>> db.rollback()


Unlike a regular database connection, this one can recover from a
database disconnection.  We will simulate a disconnect by temporarily
stopping the port forwarding proxy:

    >>> portforward.tearDown()
    >>> portforward.setUp()


If we now try to issue commands to the database, we get the
disconnection error from the database:

    >>> cursor.execute('SELECT 1')
    Traceback (most recent call last):
      ...
    DisconnectionError: no connection to the server


While it is possible to reconnect to the database again, we continue
to get DisconnectionError errors until a rollback() is issued:

    >>> cursor.fetchone()
    Traceback (most recent call last):
      ...
    DisconnectionError: Already disconnected
    >>> db.commit()
    Traceback (most recent call last):
      ...
    DisconnectionError: Already disconnected
    >>> db.rollback()


After the rollback, the connection is usable again:

    >>> cursor.execute('SELECT 1')
    >>> cursor.fetchone()
    (1,)


Database disconnections are also caught by other database operations,
such as committing the exception:

    >>> cursor.execute('SELECT 1')
    >>> cursor.fetchall()
    [(1,)]
    >>> portforward.tearDown()
    >>> portforward.setUp()
    >>> db.commit()
    Traceback (most recent call last):
      ...
    DisconnectionError: {<cursor ...>: 'server closed the connection unexpectedly...'}
    >>> db.rollback()

XXX: 20070424 jamesh
We should test that a DisconnectionError exception gets issued if we
disconnect while reading a result set, but it is hard to trigger with
simple queries since the first results have already been received by
the time execute() completes.


== ReconnectingDatabaseAdapter ==

ReconnectingDatabaseAdapter is a Zope database adapter that makes use
of ReconnectingConnection for its underlying connections.  We'll now
create such an adapter, going through the port forwarding proxy:

    >>> adapter = ReconnectingDatabaseAdapter(
    ...     'dbi://%s:@localhost:5555/%s' % (
    ...     config.launchpad.dbuser, PgTestSetup().dbname))


The resulting connection and cursor provide the expected interfaces:

    >>> from zope.app.rdb.interfaces import (
    ...     IManageableZopeDatabaseAdapter, IZopeConnection, IZopeCursor)

    >>> IManageableZopeDatabaseAdapter.providedBy(adapter)
    True
    >>> db = adapter()
    >>> IZopeConnection.providedBy(db)
    True
    >>> cursor = db.cursor()
    >>> IZopeCursor.providedBy(cursor)
    True

The resulting connection behaves the same as a normal database
connection:

    >>> cursor.execute('SELECT 1')
    >>> for row in cursor.fetchall():
    ...     print row
    [1]
    >>> db.rollback()


And it handles disconnections too:

    >>> cursor.execute('SELECT 1')
    >>> cursor.fetchone()
    [1]
    >>> portforward.tearDown()
    >>> portforward.setUp()
    >>> cursor.execute('SELECT 1')
    Traceback (most recent call last):
      ...
    DisconnectionError: server closed the connection unexpectedly
      This probably means the server terminated abnormally
      before or while processing the request.
    <BLANKLINE>
    SELECT 1


== Retrying of Database Disconnections ==

When a database disconnection occurs, it gets converted to a Retry
exception by the publication machinery:

    >>> import sys
    >>> from canonical.launchpad.webapp.publication import (
    ...     LaunchpadBrowserPublication)

    >>> publication = LaunchpadBrowserPublication(None)
    >>> try:
    ...     cursor.execute('SELECT 1')
    ... except DisconnectionError:
    ...     publication.handleException(None, None, sys.exc_info(),
    ...                                 retry_allowed=True)
    Traceback (most recent call last):
      ...
    Retry: ...


== Cleanup ==

    >>> portforward.tearDown()
