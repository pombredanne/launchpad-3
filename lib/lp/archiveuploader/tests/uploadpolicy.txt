== The uploader policies ==

When the uploader is invoked, it is given a policy to work in. This governs
such things as what tests get run at what stages of the upload, and whether or
not there is a build to be created, or one in existence to be used. These
policies are in the lp.archiveuploader package, in the uploadpolicy module,
and implement IArchiveUploadPolicy. They are registered as named utilities,
but since the policy themselves need to be changed according to user-specified
arguments, we register the classes as the component of the utilities, which
means a call to getUtility(IArchiveUploadPolicy, name) will return the class
itself rather than an instance of it.

  >>> from lp.archiveuploader.uploadpolicy import (
  ...     IArchiveUploadPolicy, findPolicyByName)
  >>> policy_cls = getUtility(IArchiveUploadPolicy, 'insecure')
  >>> policy_cls
  <class '...InsecureUploadPolicy'>

There's a helper function which returns an instance of the policy with the
given name, though, and it's preferred over using getUtility() directly.

  >>> insecure_policy = findPolicyByName('insecure')
  >>> insecure_policy
  <lp...InsecureUploadPolicy object...

Two of the policies defined so far are the insecure and buildd policies.

  >>> insecure_policy.name
  'insecure'
  >>> buildd_policy = findPolicyByName('buildd')
  >>> buildd_policy.name
  'buildd'
  >>> abstract_policy = findPolicyByName('abstract')
  Traceback (most recent call last):
  ...
  ComponentLookupError:...

There is a bunch of attributes which we expect to have and which can vary
from policy to policy.

  >>> insecure_policy.unsigned_changes_ok
  False
  >>> buildd_policy.unsigned_changes_ok
  True
  >>> insecure_policy.unsigned_dsc_ok
  False
  >>> buildd_policy.unsigned_dsc_ok
  True

The policies require certain values to be present in the options at times...

  >>> class MockAbstractOptions:
  ...     distro = 'ubuntu'
  ...     distroseries = None
  >>> class MockOptions(MockAbstractOptions):
  ...     builds = True

  >>> ab_opts = MockAbstractOptions()
  >>> bd_opts = MockOptions()

  >>> insecure_policy.setOptions(ab_opts)
  >>> insecure_policy.distro.name
  u'ubuntu'
  >>> buildd_policy.setOptions(ab_opts)
  >>> buildd_policy.setOptions(bd_opts)
  >>> buildd_policy.distro.name
  u'ubuntu'

Policies can think about distroseriess...

  >>> buildd_policy.setDistroSeriesAndPocket("hoary")
  >>> print buildd_policy.distroseries.name
  hoary

Policies can make decisions based on whether or not they want to
approve an upload automatically (I.E. move it straight to ACCEPTED
instead of UNAPPROVED)

  >>> from lp.registry.interfaces.distribution import IDistributionSet
  >>> from lp.registry.interfaces.series import SeriesStatus
  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
  >>> hoary = ubuntu['hoary']

  >>> class FakeUpload:
  ...   def __init__(self, ppa=False):
  ...       self.is_ppa = ppa

  >>> print hoary.status.name
  DEVELOPMENT

Uploads to the RELEASE pocket of not FROZEN distroseries are approved
by the insecure policy:

  >>> insecure_policy.setDistroSeriesAndPocket('hoary')
  >>> insecure_policy.autoApprove(FakeUpload())
  True

  >>> insecure_policy.autoApprove(FakeUpload(ppa=True))
  True

When the distroseries is FROZEN the uploads should wait in UNAPPROVED queue:

  >>> login('foo.bar@canonical.com')
  >>> hoary.status = SeriesStatus.FROZEN
  >>> from canonical.database.sqlbase import flush_database_updates
  >>> flush_database_updates()

  >>> insecure_policy.autoApprove(FakeUpload())
  False

PPA uploads continue to be auto-approved:

  >>> insecure_policy.autoApprove(FakeUpload(ppa=True))
  True

Reset the policy so that we can try again...

  >>> insecure_policy.policy = None
  >>> insecure_policy.distroseries = None

Uploads to the UPDATES pocket are not auto-approved by the insecure policy

  >>> insecure_policy.setDistroSeriesAndPocket('hoary-updates')
  >>> insecure_policy.autoApprove(FakeUpload())
  False

Despite of not being allowed yet (see UploadPolicy.checkUpload) PPA
uploads to post-release pockets would also be auto-approved:

  >>> insecure_policy.autoApprove(FakeUpload(ppa=True))
  True
