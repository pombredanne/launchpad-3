Filebug view classes
====================

The base class used for all the filebug pages is FileBugViewBase. It
contains enough functionality to file bug, the classes inheriting from
it only adds some more functionality, like adding fields, searching for
similar bug reports, etc.

    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest
    >>> from lp.bugs.browser.bugtarget import FileBugViewBase
    >>> from lp.registry.interfaces.distribution import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> ubuntu_firefox = ubuntu.getSourcePackage('mozilla-firefox')
    >>> bug_data = dict(
    ...     title='Test Title', comment='Test description.')

We define a helper method here so that we can instantiate
FileBugViewBase and use it without any errors occuring, since we're
bypassing most of the view machinery. We also define a mock widget class
for the same purpose.

    >>> class MockWidget:
    ...     def __init__(self, name):
    ...         self.name = name

    >>> def create_view(context, request):
    ...     view = FileBugViewBase(context, request)
    ...     view.widgets = {
    ...         'filecontent': MockWidget(name='filecontent')}
    ...     return view

The validate and action don't use the request when filing the bug, so we
can pass an empty request and pass the data dict to the methods
directly.

    >>> login('no-priv@canonical.com')
    >>> filebug_view = create_view(ubuntu_firefox, LaunchpadTestRequest())
    >>> filebug_view.validate(bug_data) is None
    True

    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'

    >>> filebug_view.added_bug.description
    u'Test description.'


URLs to additional FileBug elements
-----------------------------------

FileBugViewBase's inline_filebug_base_url returns the base URL for all
inline +filebug work.

    >>> from lp.registry.interfaces.product import IProductSet
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> filebug_view = create_initialized_view(
    ...     firefox, '+filebug')

This property returns the root URL of the current request, so in the
case of this test will return 127.0.0.1.

    >>> print filebug_view.inline_filebug_base_url
    http://127.0.0.1/

FileBugViewBase provides properties that return the URLs of further
useful parts of the +filebug process.

The inline_filebug_form_url property returns the URL of the inline
filebug form so that it may be loaded asynchronously.

    >>> print filebug_view.inline_filebug_form_url
    http://launchpad.dev/firefox/+filebug-inline-form

Similarly, the duplicate_search_url property returns the base URL for
the duplicate search view, which can be used to load the list of
possible duplicates for a bug asynchronously.

    >>> print filebug_view.duplicate_search_url
    http://launchpad.dev/firefox/+filebug-show-similar

For project groups, the URLs returned will refer to the default product
for those project groups.

    >>> from lp.registry.interfaces.projectgroup import IProjectGroupSet
    >>> gnome_project = getUtility(IProjectGroupSet).getByName('gnome')
    >>> gnome_filebug_view = create_initialized_view(
    ...     gnome_project, '+filebug')

    >>> print gnome_filebug_view.inline_filebug_form_url
    http://launchpad.dev/evolution/+filebug-inline-form

    >>> print gnome_filebug_view.duplicate_search_url
    http://launchpad.dev/evolution/+filebug-show-similar


Adding extra info to filed bugs
-------------------------------

It's possible for bug reporting tools to upload a file with debug
information to Launchpad, and pass that information to the filebug page.
When the data is uploaded a token is returned, which is appended to the
+filebug URL, resulting in a URL like '/.../+filebug/12345abcde'. The
+filebug view's publishTraverse method looks up the correct data from
using the token.

The uploaded debug information should be MIME multipart message, where
the Content-Disposition header tells Launchpad what to do with the
different parts.


First inline part
.................

The first inline part will be appended to the bug description.

    >>> debug_data = """MIME-Version: 1.0
    ... Content-type: multipart/mixed; boundary=boundary
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ... 
    ... This should be added to the description.
    ...
    ... --boundary--
    ... """
    >>> import transaction
    >>> from canonical.launchpad.interfaces.temporaryblobstorage import ITemporaryStorageManager
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)

We need to commit the transaction since the data will be stored in the
Librarian.

    >>> transaction.commit()

The data is processed by a ProcessApportBlobJob, which the filebug view
can then access to get the parsed data. We'll define a helper method for
processing the blob.

    >>> from zope.component import getUtility
    >>> from lp.bugs.interfaces.apportjob import IProcessApportBlobJobSource

    >>> def process_blob(token):
    ...     blob = getUtility(ITemporaryStorageManager).fetch(token)
    ...     job = getUtility(IProcessApportBlobJobSource).create(blob)
    ...     job.job.start()
    ...     job.run()
    ...     job.job.complete()
    >>> process_blob(token)

Now, if we pass the token to the filebug view, the extra_data attribute
will be set with the actual data.

    >>> filebug_view = create_initialized_view(ubuntu_firefox, '+filebug')
    >>> filebug_view.publishTraverse(
    ...     filebug_view.request, token) is filebug_view
    True

    >>> filebug_view.extra_data.extra_description
    u'This should be added to the description.'

    >>> filebug_view.validate(bug_data) is None
    True

    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'

    >>> print filebug_view.added_bug.description #doctest: -NORMALIZE_WHITESPACE
    Test description.
    <BLANKLINE>
    This should be added to the description.

A notification was added to inform the user about what happened.

    >>> for notification in filebug_view.request.response.notifications:
    ...     print notification.message
    <p class="last">Thank you for your bug report.</p>
    Additional information was added to the bug description.


Other inline parts
..................

If there are more than one inline part, those will be added as comments
to the bug.

    >>> debug_data = """MIME-Version: 1.0
    ... Content-type: multipart/mixed; boundary=boundary
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ... 
    ... This should be added to the description.
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ... 
    ... This should be added as a comment.
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ... 
    ... This should be added as another comment.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> process_blob(token)
    >>> filebug_view = create_initialized_view(ubuntu_firefox, '+filebug')
    >>> filebug_view.publishTraverse(filebug_view.request,
    ...     token) is filebug_view
    True

    >>> filebug_view.validate(bug_data) is None
    True

    >>> filebug_view.submit_bug_action.success(bug_data)

    >>> filebug_view.added_bug.title
    u'Test Title'

    >>> print filebug_view.added_bug.description #doctest: -NORMALIZE_WHITESPACE
    Test description.
    <BLANKLINE>
    This should be added to the description.

    >>> for comment in filebug_view.added_bug.messages[1:]:
    ...     print "Comment by %s: %s" % (
    ...         comment.owner.displayname, comment.text_contents)
    Comment by No Privileges Person: This should be added as a comment.
    Comment by No Privileges Person: This should be added as another comment.

Notifications were added to inform the user about what happened.

    >>> for notification in filebug_view.request.response.notifications:
    ...     print notification.message
    <p class="last">Thank you for your bug report.</p>
    Additional information was added to the bug description.
    A comment with additional information was added to the bug report.
    A comment with additional information was added to the bug report.


Attachments
...........

All the parts that have a 'Content-disposition: attachment' header will
get added as attachments to the bug. The attachment description can be
specified using a Content-description header, but it's not required.

    >>> debug_data = """MIME-Version: 1.0
    ... Content-type: multipart/mixed; boundary=boundary
    ...
    ... --boundary
    ... Content-disposition: attachment; filename='attachment1'
    ... Content-type: text/plain; charset=utf-8
    ... 
    ... This is an attachment.
    ...
    ... --boundary
    ... Content-disposition: attachment; filename='attachment2'
    ... Content-description: Attachment description.
    ... Content-type: text/plain; charset=ISO-8859-1
    ... 
    ... This is another attachment, with a description.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> process_blob(token)
    >>> filebug_view = create_initialized_view(ubuntu_firefox, '+filebug')
    >>> filebug_view.publishTraverse(filebug_view.request,
    ...     token) is filebug_view
    True

    >>> filebug_view.validate(bug_data) is None
    True

    >>> filebug_view.submit_bug_action.success(bug_data)

Since the attachments are stored in the Librarian, we need to commit the
transaction in order to access them.

    >>> transaction.commit()

    >>> filebug_view.added_bug.title
    u'Test Title'

    >>> print filebug_view.added_bug.description
    Test description.

The attachments got added, with the charsets preserved, and the one that
didn't specify a description got an autogenerated one.

    >>> for attachment in filebug_view.added_bug.attachments_unpopulated:
    ...     print "Filename: %s" % attachment.libraryfile.filename
    ...     print "Content type: %s" % attachment.libraryfile.mimetype
    ...     print "Description: %s" % attachment.title
    ...     print "Contents:\n%s" % attachment.libraryfile.read()
    ...     print
    Filename: attachment1
    Content type: text/plain; charset=utf-8
    Description: attachment1
    Contents:
    This is an attachment.
    <BLANKLINE>
    Filename: attachment2
    Content type: text/plain; charset=ISO-8859-1
    Description: Attachment description.
    Contents:
    This is another attachment, with a description.
    <BLANKLINE>

Notifications were added to inform the user about what happened.

    >>> for notification in filebug_view.request.response.notifications:
    ...     print notification.message
    <p class="last">Thank you for your bug report.</p>
    The file "attachment1" was attached to the bug report.
    The file "attachment2" was attached to the bug report.

The attachments are all added to the same comment.

    >>> for comment in filebug_view.added_bug.messages[1:]:
    ...     print "Comment by %s: %s attachment(s)" % (
    ...         comment.owner.displayname, comment.bugattachments.count())
    Comment by No Privileges Person: 2 attachment(s)


Private Bugs
............

We can specify whether a bug is private by providing Private field in
the message.

    >>> debug_data = """MIME-Version: 1.0
    ... Content-type: multipart/mixed; boundary=boundary
    ... Private: yes
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ... 
    ... This bug should be private.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> process_blob(token)
    >>> filebug_view = create_initialized_view(ubuntu_firefox, '+filebug')
    >>> filebug_view.publishTraverse(filebug_view.request,
    ...     token) is filebug_view
    True

    >>> filebug_view.extra_data.extra_description
    u'This bug should be private.'

    >>> filebug_view.extra_data.private
    True

    >>> filebug_view.validate(bug_data) is None
    True

    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'

    >>> print filebug_view.added_bug.description #doctest: -NORMALIZE_WHITESPACE
    Test description.
    <BLANKLINE>
    This bug should be private.

    >>> filebug_view.added_bug.private
    True

    >>> filebug_view.added_bug.security_related
    False

Since the bug was marked private before it was filed, only the bug
reporter has been subscribed to the bug and there should be no indirect
subscribers.

    >>> for subscriber in filebug_view.added_bug.getDirectSubscribers():
    ...     print subscriber.displayname
    No Privileges Person

    >>> filebug_view.added_bug.getIndirectSubscribers()
    []

The user will be notified that the bug has been marked as private.

    >>> print filebug_view.request.response.notifications[2].message
    This bug report has been marked private...

We can also specify that a bug is public via the same field.

    >>> debug_data = """MIME-Version: 1.0
    ... Content-type: multipart/mixed; boundary=boundary
    ... Private: no
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ... 
    ... This bug should be public.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> process_blob(token)
    >>> filebug_view = create_initialized_view(ubuntu_firefox, '+filebug')
    >>> filebug_view.publishTraverse(filebug_view.request,
    ...     token) is filebug_view
    True

    >>> filebug_view.extra_data.extra_description
    u'This bug should be public.'

    >>> filebug_view.extra_data.private
    False

    >>> filebug_view.validate(bug_data) is None
    True

    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'

    >>> print filebug_view.added_bug.description #doctest: -NORMALIZE_WHITESPACE
    Test description.
    <BLANKLINE>
    This bug should be public.

    >>> filebug_view.added_bug.private
    False

Since this bug is public, both the reporter and the bug supervisor have
been subscribed.

    >>> for subscriber in filebug_view.added_bug.getDirectSubscribers():
    ...     print subscriber.displayname
    No Privileges Person

    >>> for subscriber in filebug_view.added_bug.getIndirectSubscribers():
    ...     print subscriber.displayname
    Foo Bar
    Ubuntu Team


Subscriptions
.............

We can also subscribe someone to this bug when we file it by using a
Subscribe field in the message. Multiple people can be specified and
they can be identified by their Launchpad name or their e-mail address.

    >>> debug_data = """MIME-Version: 1.0
    ... Content-type: multipart/mixed; boundary=boundary
    ... Subscribers: ddaa test@canonical.com
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ... 
    ... Other people are interested in this bug.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> process_blob(token)
    >>> filebug_view = create_initialized_view(ubuntu_firefox, '+filebug')
    >>> filebug_view.publishTraverse(filebug_view.request,
    ...     token) is filebug_view
    True

    >>> filebug_view.extra_data.extra_description
    u'Other people are interested in this bug.'

    >>> for subscriber in filebug_view.extra_data.subscribers:
    ...     print subscriber
    ddaa
    test@canonical.com

    >>> filebug_view.validate(bug_data) is None
    True

    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'

    >>> print filebug_view.added_bug.description #doctest: -NORMALIZE_WHITESPACE
    Test description.
    <BLANKLINE>
    Other people are interested in this bug.

As well as the reporter, both Sample Person and David Allouche have been
subscribed to the bug.

    >>> for subscriber in filebug_view.added_bug.getDirectSubscribers():
    ...     print subscriber.displayname
    David Allouche
    No Privileges Person
    Sample Person

The user will be notified that Sample Person and David Allouche has been
subscribed to this bug.

    >>> for notification in filebug_view.request.response.notifications:
    ...     print notification.message
    <p class="last">Thank you for your bug report.</p>
    Additional information was added to the bug description.
    David Allouche has been subscribed to this bug.
    Sample Person has been subscribed to this bug.


Subscribers to Private bugs
...........................

The Private and Subscriber fields are intended to be used together to
subscribe certain people and teams to bugs when they are filed.

    >>> debug_data = """MIME-Version: 1.0
    ... Content-type: multipart/mixed; boundary=boundary
    ... Private: yes
    ... Subscribers: mark
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ... 
    ... This bug should be private, and Mark Shuttleworth subscribed.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> process_blob(token)
    >>> filebug_view = create_initialized_view(ubuntu_firefox, '+filebug')
    >>> filebug_view.publishTraverse(filebug_view.request,
    ...     token) is filebug_view
    True

    >>> filebug_view.extra_data.extra_description
    u'This bug should be private, and Mark Shuttleworth subscribed.'

    >>> filebug_view.extra_data.private
    True

    >>> for subscriber in filebug_view.extra_data.subscribers:
    ...     print subscriber
    mark

    >>> filebug_view.validate(bug_data) is None
    True

    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'

    >>> print filebug_view.added_bug.description #doctest: -NORMALIZE_WHITESPACE
    Test description.
    <BLANKLINE>
    This bug should be private, and Mark Shuttleworth subscribed.

    >>> filebug_view.added_bug.private
    True

    >>> filebug_view.added_bug.security_related
    False

As well as the reporter, Mark Shuttleworth should have been subscribed
to the bug.

    >>> for subscriber in filebug_view.added_bug.getDirectSubscribers():
    ...     print subscriber.displayname
    Mark Shuttleworth
    No Privileges Person

Since the bug is private, there should be no indirect subscribers.

    >>> filebug_view.added_bug.getIndirectSubscribers()
    []

The user will be notified that Mark Shuttleworth has been subscribed to
this bug and that the bug has been marked as private.

    >>> for notification in filebug_view.request.response.notifications:
    ...     print notification.message
    <p class="last">Thank you for your bug report.</p>
    Additional information was added to the bug description.
    Mark Shuttleworth has been subscribed to this bug.
    This bug report has been marked private...


publishTraverse()
-----------------

As already seen above, it's the FileBugViewBase's publishTraverse that
finds the right blob to use.

    >>> filebug_view = create_initialized_view(ubuntu_firefox, '+filebug')
    >>> filebug_view.publishTraverse(filebug_view.request,
    ...     token) is filebug_view
    True

    >>> filebug_view.extra_data_token == token
    True

    >>> filebug_view.extra_data is not None
    True

Since the view itself is returned, it will handle further traversals as
well, so if we call the method again, it represents a URL like
'.../+filebug/token/foo', which should raise a NotFound error.

    >>> filebug_view.publishTraverse(filebug_view.request, token)
    Traceback (most recent call last):
    ...
    NotFound:...


Not found tokens
................

If publishTraverse is called with a token that can't be found, a
NotFound error is raised.

    >>> filebug_view = create_initialized_view(ubuntu_firefox, '+filebug')
    >>> filebug_view.publishTraverse(filebug_view.request, 'no-such-token')
    Traceback (most recent call last):
    ...
    NotFound:...


Adding tags to filed bugs
-------------------------

    >>> bug_data = dict(
    ...     title=u'Test Title', comment=u'Test description.',
    ...     tags=[u'foo', u'bar'])

The validate and action don't use the request when filing the bug, so we
can pass an empty request and pass the data dict to the methods
directly.

    >>> login('no-priv@canonical.com')
    >>> filebug_view = create_initialized_view(ubuntu_firefox, '+filebug')
    >>> filebug_view.validate(bug_data) is None
    True

    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'

    >>> filebug_view.added_bug.description
    u'Test description.'

    >>> for tag in filebug_view.added_bug.tags:
    ...     print tag
    bar
    foo


Filing security bugs
--------------------

The base class allows security bugs to be filed.

    >>> bug_data = dict(
    ...     title=u'Security bug', comment=u'Test description.',
    ...     security_related=True)

    >>> filebug_view = create_initialized_view(ubuntu_firefox, '+filebug')
    >>> filebug_view.validate(bug_data) is None
    True

    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Security bug'

    >>> filebug_view.added_bug.security_related
    True


Extra fields for priviliged users
---------------------------------

Priviliged users are offered several extra options when filing bugs.

    >>> owner = factory.makePerson(name=u'bug-superdude')
    >>> person = factory.makePerson()
    >>> product = factory.makeProduct(owner=owner)

    >>> login_person(person)
    >>> filebug_view = create_initialized_view(product, '+filebug')
    >>> normal_fields = set(filebug_view.field_names)
    >>> login_person(owner)
    >>> filebug_view = create_initialized_view(product, '+filebug')
    >>> owner_fields = set(filebug_view.field_names)
    >>> product.setBugSupervisor(owner, owner)
    >>> supervisor_fields = set(filebug_view.field_names)

Priviliged users get all the same fields as normal users, plus a few extra.

    >>> owner_fields == supervisor_fields
    True
    >>> supervisor_fields.issuperset(normal_fields)
    True

    >>> for field in sorted(supervisor_fields - normal_fields):
    ...     print field
    assignee
    importance
    milestone
    status

Bugs can be filed with settings for all these extra fields.

    >>> from lp.bugs.interfaces.bugtask import (
    ...     BugTaskImportance, BugTaskStatus)

    >>> milestone = factory.makeMilestone(
    ...     product=product, name=u'bug-superdude-milestone')

    >>> bug_data = dict(
    ...     title=u'Extra Fields Bug', comment=u'Test description.',
    ...     assignee=owner, importance=BugTaskImportance.HIGH,
    ...     milestone=milestone, status=BugTaskStatus.TRIAGED)
    >>> print filebug_view.validate(bug_data)
    None

    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> [added_bugtask] = filebug_view.added_bug.bugtasks

    >>> print added_bugtask.status.title
    Triaged

    >>> print added_bugtask.importance.title
    High

    >>> print added_bugtask.assignee.name
    bug-superdude

    >>> print added_bugtask.milestone.name
    bug-superdude-milestone
