= Person Packages =

All packages maintained or uploaded by a given person can be seen on
that person's +related-software page, which is linked to from the
person's home page.

    >>> browser.open("http://launchpad.dev/~mark/+related-software")
    >>> print browser.title
    Software related to Mark Shuttleworth...

This page is just a summary of the user's packages and will only
display up to the most recent 30 items in each category.  However, it
has more links that take the user to batched listings in each category
where all items can be perused.

    >>> print extract_text(find_tag_by_id(browser.contents, 'navlinks'))
    Related software
    Maintained packages
    Uploaded packages
    Related PPA packages
    Related projects

    >>> print browser.getLink("Maintained packages").url
    http://launchpad.dev/~mark/+maintained-packages
    >>> print browser.getLink("Uploaded packages").url
    http://launchpad.dev/~mark/+uploaded-packages
    >>> print browser.getLink("PPA packages").url
    http://launchpad.dev/~mark/+ppa-packages
    >>> print browser.getLink("Related projects").url
    http://launchpad.dev/~mark/+related-projects

Each category on the summary page has a heading that shows how many
packages are being displayed.

    >>> browser.open("http://launchpad.dev/~mark/+related-software")
    >>> print extract_text(find_tag_by_id(browser.contents, 'packages'))
    Maintained packages
    Displaying first 5 packages out of 7 total
    ...
    Uploaded packages
    Displaying first 5 packages out of 6 total
    ...
    PPA packages
    1 package
    ...

name16, aka the esteemed Foo Bar, has 9 maintained packages in the sample
data.  The page lists columns of data, "Name", "Uploaded To" and "Version"
that link to a distributionsourcepackage, distroseriessourcepackage and
distrosourcepackagerelease respectively.

Following a link on any item in the name column will take us to a
distribution source package page.  We'll use "cnews" on the third
line here as it has working links in the sample data:

    >>> browser.open("http://launchpad.dev/~name16/+related-software")
    >>> link = browser.getLink("cnews")
    >>> print link
    <Link text='cnews' url='http://launchpad.dev/ubuntu/+source/cnews'>
    >>> link.click()
    >>> browser.title
    '...cnews... package : Ubuntu'

Same process for the second column should take us to a distribution series
source package page:

    >>> browser.open("http://launchpad.dev/~name16/+related-software")
    >>> link = browser.getLink(url="/ubuntu/hoary/+source/cnews")
    >>> print link
    <Link text='Ubuntu Hoary' url='http://launchpad.dev/ubuntu/hoary/+source/cnews'>
    >>> link.click()
    >>> browser.title
    '...cnews... package : Hoary (5.04) : Ubuntu'

Same again for the third column should take us to a distribution source
package release page:

    >>> browser.open("http://launchpad.dev/~name16/+related-software")
    >>> link = browser.getLink(url="/ubuntu/+source/cnews/cr.g7-37")
    >>> print link
    <Link text='cr.g7-37' url='http://launchpad.dev/ubuntu/+source/cnews/cr.g7-37'>
    >>> link.click()
    >>> browser.title
    '\xe2\x80\x9ccnews\xe2\x80\x9d package : Ubuntu'


== Batched listing pages ==

Following the navigation link to "Maintained packages" takes the user
to the page that lists maintained packages in batches.

    >>> browser.open("http://launchpad.dev/~mark/+related-software")
    >>> browser.getLink("Maintained packages").click()
    >>> print extract_text(find_tag_by_id(browser.contents, 'packages'))
    1...5 of 7 results
    ...
    Name        Uploaded to  Version   When        Failures   Bugs  Questions
    alsa-utils  Debian Sid   1.0.9a-4  2005-07-01  None       0     0
    ...

The Maintained packages page only has data if the person or team has
    Subscription policy:
maintained packages to show. No-priv does not maintain packages.

    >>> anon_browser.open("http://launchpad.dev/~no-priv")
    >>> print_tag_with_id(anon_browser.contents, 'ppas')
    Personal package archives
    PPA for No Privileges Person
    >>> anon_browser.open(
    ...     "http://launchpad.dev/~no-priv/+maintained-packages")
    >>> print extract_text(
    ...     find_tag_by_id(anon_browser.contents, 'packages'))
    Name...
    No Privileges Person does not maintain any packages.

The navigation link to "Uploaded packages" takes the user to the
page that lists uploaded packages in batches.

    >>> browser.getLink("Uploaded packages").click()
    >>> print extract_text(find_tag_by_id(browser.contents, 'packages'))
    1...5 of 6 results
    ...
    Name    Uploaded to          Version When        Failures   Bugs  Questions
    foobar  Ubuntu Breezy-autotest  1.0  2006-12-01  i386       0     0
    ...

The navigation link to "PPA packages" takes the user to the
page that lists PPA packages in batches.

    >>> browser.getLink("PPA packages").click()
    >>> print extract_text(find_tag_by_id(browser.contents, 'packages'))
    1...1 of 1 result
    ...
    Name      Uploaded to           Version  When        Failures
    iceweasel PPA for Mark...Warty  1.0      2006-04-11  None

And finally the Related projects navigation link takes the user to the
page that lists related projects in batches.

    >>> browser.getLink("Related projects").click()
    >>> print extract_text(find_tag_by_id(browser.contents, 'projects'))
    1...5 of 5 results
    ...
    Name           Bugs  Blueprints  Questions
    Ubuntu Linux   4     1           8
    ...


== Private PPA packages ==

Packages listed in the PPA section of this page are filtered so that
if the user is not allowed to see a private package they are not present
in the list.  Private packages are defined as those which are only
published in a private archive; if they are published in a private
archive *and* a non-private archive, they are deemed to be non-private
because if a package is not exclusively in a private PPA it cannot be
really private if someone can see it somewhere else.  This situation is
going to be very rare, however it does cover one important scenario: the
embargoed archive implementation.  Here, private security uploads and
builds will take place in a private archive and once verified will be
simply copied across archives to the primary Ubuntu archive.  At that
point it makes no sense to keep the package private any more, because
it's available to anyone anyway.

Let's make a helper function to print the PPA packages from the page:

    >>> def print_ppa_rows(browser):
    ...     rows = find_tags_by_class(browser.contents, "ppa_row")
    ...     for row in rows:
    ...         print extract_text(row)

And another helper function to set the private flag on a PPA:

    >>> def set_private(name, private=True):
    ...     admin_browser.open("http://launchpad.dev/~%s/+archive/ppa" % (
    ...         name))
    ...     admin_browser.getLink("Administer archive").click()
    ...     admin_browser.getControl(name="field.private").value = private
    ...     admin_browser.getControl(name="field.buildd_secret").value = "x"
    ...     admin_browser.getControl("Save").click()

Create some new source packages, source1 and source2, both created by cprov
so that they appear in his +packages page.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.ftests import login, logout
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from lp.soyuz.tests.test_publishing import (
    ...      SoyuzTestPublisher)
    >>> from lp.soyuz.interfaces.publishing import (
    ...     PackagePublishingStatus)

    >>> login("foo.bar@canonical.com")
    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> nopriv = getUtility(IPersonSet).getByName('no-priv')
    >>> mark = getUtility(IPersonSet).getByName('mark')
    >>> test_publisher = SoyuzTestPublisher()
    >>> test_publisher.prepareBreezyAutotest()
    >>> source1 = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='source1',
    ...     archive=cprov.archive)
    >>> source1.sourcepackagerelease.creator=cprov
    >>> source1_mark = source1.copyTo(
    ...     source1.distroseries, source1.pocket, mark.archive)
    >>> source2 = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='source2',
    ...     archive=nopriv.archive)
    >>> source2.sourcepackagerelease.creator=cprov

    >>> flush_database_updates()
    >>> logout()

"source1" is now published in cprov and mark's PPA.  "source2" is only
published in no-priv's PPA.

Make user_browser a known user that does not conflict with "no-priv":

    >>> user_browser = setupBrowser(auth='Basic test@canonical.com:test')

=== Cprov's +related-software page ===

So let's look at cprov's +related-software page which has two entries in
the PPA section:

    >>> user_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(user_browser)
    source1 PPA for Celso Providelo - Ubuntutest Breezy-autotest 666
        ...ago None - -
    source2 PPA for No Privileges Person - Ubuntutest Breezy-autotest 666
        ...ago None - -

Now, let's make the PPA for "No Privileges Person" private:

    >>> set_private("no-priv")

For unprivileged users, cprov's displayed PPA packages are now reduced
to the one in his own PPA because the other iceweasel is only published
in the newly-private PPA of the "no-priv" user.

The logged-in user's case:

    >>> user_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(user_browser)
    source1 PPA for Celso Providelo - Ubuntutest Breezy-autotest 666
        ...ago None - -

The not logged-in (anonymous) user's case:

    >>> anon_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(anon_browser)
    source1 PPA for Celso Providelo - Ubuntutest Breezy-autotest 666
        ...ago None - -

However no-priv himself and any Launchpad Administrator can still see
both packages:

    >>> nopriv_browser = setupBrowser(auth="Basic no-priv@canonical.com:test")
    >>> nopriv_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(nopriv_browser)
    source1 PPA for Celso Providelo - Ubuntutest Breezy-autotest 666
        ...ago None - -
    source2 PPA for No Priv... Person - Ubuntutest Breezy-autotest 666
        ...ago None - -

    >>> admin_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(admin_browser)
    source1 PPA for Celso Providelo - Ubuntutest Breezy-autotest 666
        ...ago None - -
    source2 PPA for No Priv... Person - Ubuntutest Breezy-autotest 666
        ...ago None - -

Let's make mark's archive private and view the page again.

    >>> set_private("mark")

    >>> user_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(user_browser)
    source1 PPA for Celso Providelo - Ubuntutest Breezy-autotest 666
        ...ago None - -

    >>> anon_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(anon_browser)
    source1 PPA for Celso Providelo - Ubuntutest Breezy-autotest 666
        ...ago None - -

Notice that the source1 package in mark's PPA is still appearing
because it is also published in some non-private archives, which
override the private nature of mark's archive.

Let's make cprov's archive private:

    >>> set_private("cprov")

It will now disppear from the listings because it's not published in any
public archives.

    >>> user_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(user_browser)

Now we'll publish it in the primary archive.

    >>> login("foo.bar@canonical.com")
    >>> from lp.soyuz.interfaces.archive import (
    ...     ArchivePurpose, IArchiveSet)
    >>> from lp.registry.interfaces.distribution import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> primary = getUtility(IArchiveSet).getByDistroPurpose(ubuntu,
    ...     ArchivePurpose.PRIMARY)
    >>> source1_ubuntu = source1.copyTo(
    ...     source1.distroseries, source1.pocket, primary)
    >>> source1_ubuntu.setPublished()
    >>> flush_database_updates()
    >>> logout()

This makes the package appear in the listings again because the primary
archive is public.

    >>> user_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(user_browser)
    source1 PPA for Celso Providelo - Ubuntutest Breezy-autotest 666
        ...ago None - -

    >>> anon_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(anon_browser)
    source1 PPA for Celso Providelo - Ubuntutest Breezy-autotest 666
        ...ago None - -

Even after the package is superseded, the package remains visibile in
the listings.

    >>> login("foo.bar@canonical.com")
    >>> discard = source1_ubuntu.supersede()
    >>> flush_database_updates()
    >>> logout()

    >>> user_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(user_browser)
    source1 PPA for Celso Providelo - Ubuntutest Breezy-autotest 666
        ...ago None - -

    >>> anon_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(anon_browser)
    source1 PPA for Celso Providelo - Ubuntutest Breezy-autotest 666
        ...ago None - -


== Packages deleted from a PPA ==

When a package is deleted from a PPA, in contrast to the archive index
it will continue to appear in the related-software packages list.  This
is to be consistent with the other lists on these pages and also helps
some MOTU users in reviewing candidates' packages.

First list the packages in the PPA.

    >>> admin_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(admin_browser)
    source1 PPA for Celso Providelo - Ubuntutest Breezy-autotest 666
        ...ago None - -
    source2 PPA for No Priv... Person - Ubuntutest Breezy-autotest 666
        ...ago None - -

Then delete the 'source2' package.

    >>> admin_browser.open(
    ...     "http://launchpad.dev/~no-priv/+archive/ppa/+delete-packages")
    >>> admin_browser.getControl(
    ...    name='field.selected_sources').value = ['%s' % source2.id]
    >>> admin_browser.getControl(
    ...     "Deletion comment").value = "Bug 184490"
    >>> admin_browser.getControl("Request Deletion").click()

    >>> messages = get_feedback_messages(admin_browser.contents)
    >>> for msg in messages:
    ...     print msg
    Source and binaries deleted by Foo Bar request:
    source2 666 in breezy-autotest
    Deletion comment: Bug 184490

    >>> def print_ppa_packages(contents):
    ...     packages = find_tags_by_class(contents, 'archive_package_row')
    ...     for pkg in packages:
    ...         print extract_text(pkg)
    ...     empty_section = find_tag_by_id(contents, 'empty-result')
    ...     if empty_section is not None:
    ...         print extract_text(empty_section)
    >>> print_ppa_packages(admin_browser.contents)

Now re-list the PPA's packages, 'source2' was deleted but still
appears.

    >>> admin_browser.open("http://launchpad.dev/~cprov/+related-software")
    >>> print_ppa_rows(admin_browser)
    source1 PPA for Celso Providelo - Ubuntutest Breezy-autotest 666
        ...ago None - -
    source2 PPA for No Priv... Person - Ubuntutest Breezy-autotest 666
        ...ago None - -

