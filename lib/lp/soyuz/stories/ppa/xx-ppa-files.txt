= Personal Package Archives Files =

PPA files are proxied via +archive/+files or +builds/+files in a way
we can decide between redirecting to the public librarian URL or
stream the restricted content in inline.

== Setup ==

Creating a complete source and binary publication on No Priv's private
PPA.

    >>> from zope.component import getUtility

    >>> from lp.soyuz.tests.test_publishing import (
    ...      SoyuzTestPublisher)
    >>> from lp.registry.interfaces.person import IPersonSet
    >>> from lp.soyuz.interfaces.publishing import (
    ...     PackagePublishingPocket)

Make the PPA private.

    >>> login('foo.bar@canonical.com')
    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> no_priv.archive.buildd_secret = 'x'
    >>> no_priv.archive.private = True

Initialise SoyuzTestPublisher.

    >>> test_publisher = SoyuzTestPublisher()
    >>> test_publisher.prepareBreezyAutotest()
    >>> test_publisher.addFakeChroots()

Publish a source.

    >>> test_source = test_publisher.getPubSource(
    ...     archive=no_priv.archive, sourcename='test-pkg',
    ...     version='1.0')
    >>> dsc_file = test_source.sourcepackagerelease.files[0].libraryfile

Include a source tarball.

    >>> tar_gz = test_publisher.addMockFile(
    ...     'test-pkg_1.0.tar.gz', filecontent='TAR', restricted=True)
    >>> unused = test_source.sourcepackagerelease.addFile(tar_gz)

Create a corresponding binary publication and its changesfile.

    >>> binary_pubs = test_publisher.getPubBinaries(
    ...     binaryname='test-bin', pub_source=test_source)
    >>> deb_file = binary_pubs[0].binarypackagerelease.files[0].libraryfile

    >>> [build] = test_source.getBuilds()
    >>> build.datebuilt = build.datecreated

Create a buildlog and a binary upload_log.

    >>> buildlog_name = (
    ...     'buildlog_ubuntu-breezy-autotest-i386.'
    ...     'test-pkg_1.0_FULLYBUILT.txt.gz')
    >>> buildlog = test_publisher.addMockFile(
    ...     buildlog_name, filecontent='bogus buildlog', restricted=True)
    >>> build.buildlog = buildlog

    >>> upload_log_name = 'upload_%d_log.txt' % build.id
    >>> upload_log = test_publisher.addMockFile(
    ...     upload_log_name, filecontent='bogus build upload_log',
    ...     restricted=True)
    >>> build.upload_log = upload_log

Create a subsequent source publication so a package diff can be provided.

    >>> another_test_source = test_publisher.getPubSource(
    ...     archive=no_priv.archive, sourcename='test-pkg',
    ...     version='1.1')
    >>> another_dsc_file = (
    ...     another_test_source.sourcepackagerelease.files[0].libraryfile)

    >>> package_diff  = test_source.sourcepackagerelease.requestDiffTo(
    ...     no_priv, another_test_source.sourcepackagerelease)
    >>> package_diff.diff_content = test_publisher.addMockFile(
    ...     'test-pkg_1.0_1.1.diff.gz', filecontent='bogus diff',
    ...     restricted=True)
    >>> package_diff.date_fulfilled = package_diff.date_requested

Commit everything.

    >>> from canonical.database.sqlbase import commit
    >>> commit()


== PPA file links ==

Links to files accessible via +files/ proxy in the PPA page.

    >>> ppa_links = [
    ...     ('(changesfile)',
    ...         another_test_source.sourcepackagerelease.upload_changesfile),
    ...     ]

    >>> ppa_1_0_links = [
    ...     ('test-pkg_1.0.dsc', dsc_file),
    ...     ('test-pkg_1.0.tar.gz', tar_gz),
    ...     ('test-bin_1.0_all.deb', deb_file),
    ...     ]

    >>> ppa_1_1_links = [
    ...     ('test-pkg_1.1.dsc', another_dsc_file),
    ...     ('1.0 to 1.1', package_diff.diff_content),
    ...     ]

Links to files accessible via +files/ proxy in the Build page.

    >>> builds_links = [
    ...     ('see the log', build.buildlog),
    ...     ]

    >>> build_links = [
    ...     ('test-bin_1.0_i386.changes', build.changesfile),
    ...     (buildlog_name, build.buildlog),
    ...     (upload_log_name, build.upload_log),
    ...     ]

    >>> logout()

Create a function to check the expected links.

    >>> from mechanize import LinkNotFoundError
    >>> def check_urls(browser, links, base_url):
    ...     for link, libraryfile in links:
    ...         try:
    ...             found_url = browser.getLink(link).url
    ...         except LinkNotFoundError:
    ...             print '%s: NOT FOUND' % libraryfile.filename
    ...             continue
    ...         found_url = found_url.replace('%7E', '~')
    ...         expected_url = '/'.join(
    ...             (base_url, '+files', libraryfile.filename))
    ...         if found_url == expected_url:
    ...             print '%s: OK' % libraryfile.filename
    ...         else:
    ...             print '%s: NOT OK (%s != %s)' % (
    ...                 libraryfile.filename, found_url, expected_url)

No Privileges user can access the files related with his PPA and its
builds.

    >>> no_priv_browser = setupBrowser(
    ...     auth='Basic no-priv@canonical.com:test')
    >>> no_priv_browser.open("http://launchpad.dev/~no-priv/+archive/ppa")

    >>> print no_priv_browser.title
    PPA for No Privileges Person

Source changesfiles are served on the PPA '+files' traversal.

    >>> check_urls(no_priv_browser, ppa_links,
    ...            'http://launchpad.dev/~no-priv/+archive/ppa')
    test-pkg_1.1_source.changes: OK

    >>> no_priv_browser.getLink('Copy packages').click()
    >>> check_urls(no_priv_browser, ppa_links,
    ...            'http://launchpad.dev/~no-priv/+archive/ppa')
    test-pkg_1.1_source.changes: OK

    >>> no_priv_browser.getLink('PPA').click()
    >>> no_priv_browser.getLink('Delete packages').click()
    >>> check_urls(no_priv_browser, ppa_links,
    ...            'http://launchpad.dev/~no-priv/+archive/ppa')
    test-pkg_1.1_source.changes: OK

Buildlogs are served on the Build '+files' traversal, when the PPA
builds list is presented.

    >>> no_priv_browser.getLink('PPA').click()
    >>> no_priv_browser.getLink('View build records').click()
    >>> no_priv_browser.getControl(name="build_state").value = ['built']
    >>> no_priv_browser.getControl("Update").click()

    >>> check_urls(no_priv_browser, builds_links,
    ...            'http://launchpad.dev/~no-priv/+archive/ppa/+build/31')
    buildlog_ubuntu-breezy-autotest-i386.test-pkg_1.0_FULLYBUILT.txt.gz: OK

    >>> no_priv_browser.getLink('PPA').click()

Source and binary files, in the expandable-row area, are served via
the PPA '+files' traversal.

    >>> expander_id = find_tags_by_class(
    ...     no_priv_browser.contents, 'expander')[1]['id']
    >>> no_priv_browser.getLink(id=expander_id).click()

    >>> check_urls(no_priv_browser, ppa_1_0_links,
    ...            'http://launchpad.dev/~no-priv/+archive/ppa')
    test-pkg_1.0.dsc:     OK
    test-pkg_1.0.tar.gz:  OK
    test-bin_1.0_all.deb: OK

Buildlog, upload_log and binary changesfile are served via the Build
'+files' traversal when the Build page is presented.

    >>> no_priv_browser.getLink('i386').click()
    >>> print no_priv_browser.title
    i386 build of test-pkg 1.0 in ubuntutest breezy-autotest RELEASE

    >>> check_urls(no_priv_browser, build_links,
    ...            'http://launchpad.dev/~no-priv/+archive/ppa/+build/31')
    test-bin_1.0_i386.changes:    OK
    buildlog_...txt.gz:           OK
    upload_..._log.txt:           OK

Package-diff files, in the expandable-row area, are served via the PPA
'+files' traversal.

    >>> no_priv_browser.open("http://launchpad.dev/~no-priv/+archive")

    >>> expander_id = find_tags_by_class(
    ...     no_priv_browser.contents, 'expander')[0]['id']
    >>> no_priv_browser.getLink(id=expander_id).click()

    >>> check_urls(no_priv_browser, ppa_1_1_links,
    ...            'http://launchpad.dev/~no-priv/+archive/ppa')
    test-pkg_1.1.dsc:         OK
    test-pkg_1.0_1.1.diff.gz: OK

Retrieve file information for using the direct HTTP browsing API.

    >>> login('foo.bar@canonical.com')
    >>> file_content = dsc_file.read()
    >>> file_size = str(dsc_file.content.filesize)
    >>> file_mimetype = dsc_file.mimetype
    >>> file_lp_url = str(
    ...     'http://launchpad.dev/~no-priv/+archive/ppa/+files/%s' %
    ...     dsc_file.filename)
    >>> logout()

Sample Person can't access the file.

    >>> browser.open(file_lp_url)
    Traceback (most recent call last):
    ...
    Unauthorized

The 'No Privileges' user, the PPA owner, can download the DSC file.

    >>> no_priv_browser.open(file_lp_url)

And its informations match the library file.

    >>> print file_content
    I do not care about sources.
    >>> print file_size
    28
    >>> print file_mimetype
    application/text

    >>> print no_priv_browser.contents
    I do not care about sources.
    >>> print no_priv_browser.headers['content-length']
    28
    >>> print no_priv_browser.headers['content-type']
    application/text

Gzipped package diffs ('.diff.gz') and buildlogs ('.txt.gz') are
treated differently from the other files. Since we want their contents
to be rendered inline by the browsers we override their 'content-encoding'
and 'content-type' to 'gzip' and 'text/plain', respectively.

    >>> login('foo.bar@canonical.com')

    >>> buildlog_content = buildlog.read()
    >>> buildlog_size = str(buildlog.content.filesize)
    >>> buildlog_lp_url = str(
    ...     'http://launchpad.dev/~no-priv/+archive/ppa/+build/%d/+files/%s' %
    ...     (build.id, buildlog.filename))

    >>> diff_content = package_diff.diff_content.read()
    >>> diff_size = str(package_diff.diff_content.content.filesize)
    >>> diff_lp_url = str(
    ...     'http://launchpad.dev/~no-priv/+archive/ppa/+files/%s' %
    ...     package_diff.diff_content.filename)

    >>> logout()

Restricted buildlogs are served with the pristine content and size,
but 'content-type' and 'content-encoding' are modified.

    >>> no_priv_browser.open(buildlog_lp_url)

    >>> print buildlog_content
    bogus buildlog
    >>> print buildlog_size
    14

    >>> print no_priv_browser.contents
    bogus buildlog
    >>> print no_priv_browser.headers['content-length']
    14

    >>> print no_priv_browser.headers['content-type']
    text/plain
    >>> print no_priv_browser.headers['content-encoding']
    gzip

The same happens for package diffs.

    >>> no_priv_browser.open(diff_lp_url)

    >>> print diff_content
    bogus diff
    >>> print diff_size
    10

    >>> print no_priv_browser.contents
    bogus diff
    >>> print no_priv_browser.headers['content-length']
    10

    >>> print no_priv_browser.headers['content-type']
    text/plain
    >>> print no_priv_browser.headers['content-encoding']
    gzip

When the PPA and the `LibraryFileAlias` become public, the +files/
proxy redirects to the public http url.

    >>> login('foo.bar@canonical.com')

    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> no_priv.archive.buildd_secret = ''
    >>> no_priv.archive.private = False

    >>> from zope.security.proxy import removeSecurityProxy
    >>> removeSecurityProxy(dsc_file).restricted = False

    >>> file_librarian_url = dsc_file.http_url

    >>> commit()
    >>> logout()

    >>> print file_librarian_url
    http://localhost:58000/.../test-pkg_1.0.dsc

    >>> print http(r"""
    ... GET %s HTTP/1.1
    ... """ % file_lp_url.replace('http://launchpad.dev', ''))
    HTTP/1.1 303 See Other
    ...
    Location: http://localhost:58000/.../test-pkg_1.0.dsc
    ...


== Compatibility URL Redirection ==

If a script or otherwise is trying to access +archive/+files, we make
sure that '+files' isn't understood as the PPA name, but instead
redirect to the files for the default named PPA.

    >>> file_lp_url_without_ppa_name = file_lp_url.replace('/ppa', '')
    >>> print file_lp_url_without_ppa_name
    http://launchpad.dev/~no-priv/+archive/+files/test-pkg_1.0.dsc

    >>> print http(r"""
    ... GET %s HTTP/1.1
    ... """ % file_lp_url_without_ppa_name.replace(
    ...     'http://launchpad.dev', ''))
    HTTP/1.1 301 Moved Permanently
    ...
    Location: http://localhost/~no-priv/+archive/ppa/+files/test-pkg_1.0.dsc
    ...

The same redirection happens for +archive/+build/blah urls:

    >>> buildlog_lp_url_without_ppa_name = buildlog_lp_url.replace(
    ...     '/ppa', '')
    >>> print buildlog_lp_url_without_ppa_name
    http://.../~no-priv/+archive/+build/31/+files/...

    >>> print http(r"""
    ... GET %s HTTP/1.1
    ... """ % buildlog_lp_url_without_ppa_name.replace(
    ...     'http://launchpad.dev', ''))
    HTTP/1.1 301 Moved Permanently
    ...
    Location: http://.../~no-priv/+archive/ppa/+build/31/+files/...
    ...


== Deleted library files ==

Unused PPA files get expired and deleted after a configurable period,
so Launchpad doesn't have to host them forever. They are also
immediately deleted in case of reported ToS violation.

We will attach an existing file (the 'test-pkg_1.0.dsc') to a deleted
LibraryFileContent.

    >>> from canonical.launchpad.database import LibraryFileContent
    >>> from canonical.launchpad.webapp.interfaces import (
    ...     IStoreSelector, MAIN_STORE, MASTER_FLAVOR)

    >>> login('foo.bar@canonical.com')

    >>> store = getUtility(IStoreSelector).get(MAIN_STORE, MASTER_FLAVOR)

    >>> deleted_content = LibraryFileContent(
    ...     filesize=1, sha1='f00', md5='f00', deleted=True)
    >>> ignore = store.add(deleted_content)

    >>> store.commit()

    >>> from zope.security.proxy import removeSecurityProxy
    >>> removeSecurityProxy(dsc_file).content = deleted_content

    >>> commit()

The librarian URL for a deleted file is None, by convention. See
`ILibraryFileAlias` for more information on this.

    >>> print dsc_file.http_url
    None

    >>> logout()

In this circumstance, when a file is deleted, the file reference
remains in the PPA page, but it's not a link anymore.

    >>> no_priv_browser.open("http://launchpad.dev/~no-priv/+archive/ppa")

    >>> expander_id = find_tags_by_class(
    ...     no_priv_browser.contents, 'expander')[1]['id']
    >>> no_priv_browser.getLink(id=expander_id).click()

    >>> check_urls(no_priv_browser, ppa_1_0_links,
    ...            'http://launchpad.dev/~no-priv/+archive/ppa')
    test-pkg_1.0.dsc:     NOT FOUND
    test-pkg_1.0.tar.gz:  OK
    test-bin_1.0_all.deb: OK

If by any chance, mostly bookmarked URLs, it gets accessed via the
LP proxy URL a proper NotFound error is raised, informing the correct
filename and the context archive.

    >>> print file_lp_url
    http://launchpad.dev/~no-priv/+archive/ppa/+files/test-pkg_1.0.dsc

    >>> no_priv_browser.open(file_lp_url)
    Traceback (most recent call last):
    ...
    DeletedProxiedLibraryFileAlias:
    Object: u'test-pkg_1.0.dsc', name: <Archive at ...>
