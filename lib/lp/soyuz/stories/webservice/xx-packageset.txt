= Package sets =

Package sets facilitate the grouping of packages for purposes like the
control of upload permissions, the calculation of build and runtime package
dependencies etc.

Initially, package sets will be used to enforce upload permissions to source
packages. Later they may be put to other uses as well.

Please note: the purpose of the tests that follow is merely to test the
correctness of exposing package sets on the web services API.

The actual package set *functionality* is tested in much greater detail
here:
    
    lib/lp/soyuz/doc/packageset.txt

Please refer to the tests contained in the file above if you are really
interested in package sets and the complete functionality they offer.

We start off by creating an 'umbrella' package set that will include all
source packages.

    >>> from zope.component import getUtility
    >>> from lp.registry.interfaces.person import IPersonSet

    >>> name12 = webservice.get("/~name12").jsonBody()
    >>> response = webservice.named_post(
    ...     '/package-sets', 'new', {},
    ...     name=u'umbrella', description=u'Contains all source packages',
    ...     owner=name12['self_link'])
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

Let's make sure the newly created package set is present.

    >>> login('foo.bar@canonical.com')
    >>> import operator
    >>> def sort_by_id(iterable):
    ...     return sorted(iterable, key=operator.attrgetter('id'))
    >>> def print_data(iterable):
    ...     for datum in sort_by_id(iterable):
    ...          print('%3d -> %s' % (datum.id, datum.name))

    >>> from lp.soyuz.interfaces.packageset import (
    ...     IPackagesetSet)
    >>> ps_factory = getUtility(IPackagesetSet)
    >>> print_data((ps_factory[u'umbrella'], ))
    1 -> umbrella

Can we access it via the webservice API as well?

    >>> logout()
    >>> umbrella = webservice.get("/package-sets/umbrella").jsonBody()
    >>> print umbrella['self_link']
    http://api.launchpad.dev/beta/package-sets/umbrella

`PackageSet`s can be looked up by name.

    >>> response = webservice.named_get(
    ...     '/package-sets', 'getByName', {}, name=u'umbrella')
    >>> print response.jsonBody()['self_link']
    http://api.launchpad.dev/beta/package-sets/umbrella

When a `PackageSet` cannot be found, an error is returned.

    >>> response = webservice.named_get(
    ...     '/package-sets', 'getByName', {}, name=u'not-found')
    >>> print response.getOutput()
    HTTP/1.1 400 Bad Request
    ...
    NoSuchPackageSet: No such packageset: 'not-found'.
    <BLANKLINE>

Populate the 'umbrella' package set with source packages.

    >>> from canonical.launchpad.webapp.interfaces import (
    ...     IStoreSelector, MAIN_STORE, DEFAULT_FLAVOR, MASTER_FLAVOR)
    >>> from lp.registry.model.sourcepackagename import SourcePackageName
    >>> store = getUtility(IStoreSelector).get(MAIN_STORE, DEFAULT_FLAVOR)
    >>> all_spns = store.find(SourcePackageName)
    >>> response = webservice.named_post(
    ...     '/package-sets/umbrella', 'addSources', {},
    ...     names=[spn.name for spn in all_spns])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...

Note that attempts to add or remove source package names that do not
exist will not fail. Non-existing source package names are *ignored*.

    >>> response = webservice.named_post(
    ...     '/package-sets/umbrella', 'addSources', {},
    ...     names=[u'does-not-exist'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...
    null

    >>> response = webservice.named_post(
    ...     '/package-sets/umbrella', 'removeSources', {},
    ...     names=[u'does-not-exist'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...
    null

Let's see what we got.

    >>> response = webservice.named_get(
    ...     '/package-sets/umbrella', 'getSourcesIncluded', {})
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...
    ["a52dec",
     "alsa-utils",
     "at",
     "cdrkit",
     "cnews",
     "commercialpackage",
     "evolution",
     "foobar",
     "iceweasel",
     "language-pack-de",
     "libstdc++",
     "linux-source-2.6.15",
     "mozilla",
     "mozilla-firefox",
     "netapplet",
     "pmount",
     "thunderbird"]

Source package associations can be severed as well. In the example below
the 'foobar' and 'iceweasel' source package associations will be removed
from the 'umbrella' package set.

    >>> response = webservice.named_post(
    ...     '/package-sets/umbrella', 'removeSources', {},
    ...     names=["foobar", "iceweasel"])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...

Please note that the 'foobar' and 'iceweasel' source packages are absent
from the list below.

    >>> response = webservice.named_get(
    ...     '/package-sets/umbrella', 'getSourcesIncluded', {})
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...
    ["a52dec",
     "alsa-utils",
     "at",
     "cdrkit",
     "cnews",
     "commercialpackage",
     "evolution",
     "language-pack-de",
     "libstdc++",
     "linux-source-2.6.15",
     "mozilla",
     "mozilla-firefox",
     "netapplet",
     "pmount",
     "thunderbird"]

Accessing the top-level package set URL will return the first 50 package sets
sorted by name.

    >>> def print_payload(response):
    ...     body = response.jsonBody()
    ...     for entry in body['entries']:
    ...         print entry['self_link']

    >>> response = webservice.get("/package-sets/")
    >>> print_payload(response)
    http://api.launchpad.dev/beta/package-sets/umbrella

Package sets may include other package sets (as subsets). At this point,
however, we only have the 'umbrella' package set. It hence has no subsets.

    >>> response = webservice.named_get(
    ...     '/package-sets/umbrella', 'setsIncluded', {})
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...
    {"total_size": 0, "start": null, "entries": []}

Let's create a few more package sets and set up a package set hierarchy.

    >>> response = webservice.named_post(
    ...     '/package-sets', 'new', {},
    ...     name=u'gnome', description=u'Contains all gnome packages',
    ...     owner=name12['self_link'])
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

    >>> response = webservice.named_post(
    ...     '/package-sets', 'new', {},
    ...     name=u'mozilla', description=u'Contains all mozilla packages',
    ...     owner=name12['self_link'])
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

    >>> response = webservice.named_post(
    ...     '/package-sets', 'new', {},
    ...     name=u'firefox', description=u'Contains all firefox packages',
    ...     owner=name12['self_link'])
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

    >>> response = webservice.named_post(
    ...     '/package-sets', 'new', {},
    ...     name=u'thunderbird',
    ...     description=u'Contains all thunderbird packages',
    ...     owner=name12['self_link'])
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

    >>> response = webservice.named_post(
    ...     '/package-sets', 'new', {},
    ...     name=u'languagepack',
    ...     description=u'Contains all languagepack packages',
    ...     owner=name12['self_link'])
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

In order to test whether methods relating to package set hierarchies were
exposed on the Launchpad API correctly we will define the following package
set hierarchy:

    * umbrella
      * gnome
        * languagepack
      * mozilla
        * firefox
        * thunderbird
          * languagepack

    >>> response = webservice.named_post(
    ...     '/package-sets/umbrella', 'addSubsets', {},
    ...     names=[u'gnome', u'mozilla'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...

    >>> response = webservice.named_post(
    ...     '/package-sets/gnome', 'addSubsets', {}, names=[u'languagepack'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...

    >>> response = webservice.named_post(
    ...     '/package-sets/thunderbird', 'addSubsets', {},
    ...     names=[u'languagepack'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...

    >>> response = webservice.named_post(
    ...     '/package-sets/mozilla', 'addSubsets', {},
    ...     names=[u'firefox', u'thunderbird'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...

Similarly to 'addSources' and 'removeSources', adding or removing
non-existing package sets will not fail.

    >>> response = webservice.named_post(
    ...     '/package-sets/thunderbird', 'addSubsets', {},
    ...     names=[u'does-not-exist'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...
    null

    >>> response = webservice.named_post(
    ...     '/package-sets/thunderbird', 'removeSubsets', {},
    ...     names=[u'does-not-exist'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...
    null

The 'umbrella' package set should have plenty of subsets now.

    >>> response = webservice.named_get(
    ...     '/package-sets/umbrella', 'setsIncluded', {})
    >>> print_payload(response)
    http://api.launchpad.dev/beta/package-sets/firefox
    http://api.launchpad.dev/beta/package-sets/gnome
    http://api.launchpad.dev/beta/package-sets/languagepack
    http://api.launchpad.dev/beta/package-sets/mozilla
    http://api.launchpad.dev/beta/package-sets/thunderbird

However only two of the above are direct subsets.

    >>> response = webservice.named_get(
    ...     '/package-sets/umbrella', 'setsIncluded', {},
    ...     direct_inclusion=True)
    >>> print_payload(response)
    http://api.launchpad.dev/beta/package-sets/gnome
    http://api.launchpad.dev/beta/package-sets/mozilla

Let's ask the question the other way around what package sets are including
a particular subset?

    >>> response = webservice.named_get(
    ...     '/package-sets/languagepack', 'setsIncludedBy', {})
    >>> print_payload(response)
    http://api.launchpad.dev/beta/package-sets/gnome
    http://api.launchpad.dev/beta/package-sets/mozilla
    http://api.launchpad.dev/beta/package-sets/thunderbird
    http://api.launchpad.dev/beta/package-sets/umbrella

The list of package sets that *directly* include 'languagepack' will be
shorter because the transitive closure is ignored.

    >>> response = webservice.named_get(
    ...     '/package-sets/languagepack', 'setsIncludedBy', {},
    ...     direct_inclusion=True)
    >>> print_payload(response)
    http://api.launchpad.dev/beta/package-sets/gnome
    http://api.launchpad.dev/beta/package-sets/thunderbird

We can remove subsets as well. In the example below 'thunderbird' will
stop including 'languagepack'.

    >>> response = webservice.named_post(
    ...     '/package-sets/thunderbird', 'removeSubsets', {},
    ...     names=[u'languagepack'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...

And, here we go, now 'languagepack' has only one direct predecessor: 'gnome'.

    >>> response = webservice.named_get(
    ...     '/package-sets/languagepack', 'setsIncludedBy', {},
    ...     direct_inclusion=True)
    >>> print_payload(response)
    http://api.launchpad.dev/beta/package-sets/gnome

Let's add a few source packages to the 'firefox' and the 'thunderbird'
package sets.

    >>> response = webservice.named_post(
    ...     '/package-sets/firefox', 'addSources', {},
    ...     names=['at', 'mozilla-firefox', 'language-pack-de'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...

    >>> response = webservice.named_get(
    ...     '/package-sets/firefox', 'getSourcesIncluded', {})
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...
    ["at", "language-pack-de", "mozilla-firefox"]

    >>> response = webservice.named_post(
    ...     '/package-sets/thunderbird', 'addSources', {},
    ...     names=['at', 'cnews', 'thunderbird', 'language-pack-de'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...

    >>> response = webservice.named_get(
    ...     '/package-sets/thunderbird', 'getSourcesIncluded', {})
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...
    ["at", "cnews", "language-pack-de", "thunderbird"]

Which package sets include 'mozilla-firefox'?

    >>> response = webservice.named_get(
    ...     '/package-sets/', 'setsIncludingSource', {},
    ...     sourcepackagename=u'mozilla-firefox')
    >>> print_payload(response)
    http://api.launchpad.dev/beta/package-sets/firefox
    http://api.launchpad.dev/beta/package-sets/mozilla
    http://api.launchpad.dev/beta/package-sets/umbrella

Which package sets include the 'mozilla-firefox' source package *directly*?

    >>> response = webservice.named_get(
    ...     '/package-sets/', 'setsIncludingSource', {},
    ...     sourcepackagename=u'mozilla-firefox',
    ...     direct_inclusion=True)
    >>> print_payload(response)
    http://api.launchpad.dev/beta/package-sets/firefox
    http://api.launchpad.dev/beta/package-sets/umbrella

If a non-existing source package name is passed it returns an error.

    >>> response = webservice.named_get(
    ...     '/package-sets/', 'setsIncludingSource', {},
    ...     sourcepackagename=u'does-not-exist')
    >>> print response.getOutput()
    HTTP/1.1 400 Bad Request
    ...
    No such source package: 'does-not-exist'.
    ...

What source packages are shared by the 'firefox' and the 'thunderbird'
package sets?

    >>> thunderbird = webservice.get("/package-sets/thunderbird").jsonBody()
    >>> response = webservice.named_get(
    ...     '/package-sets/firefox', 'getSourcesSharedBy', {},
    ...     other_package_set=thunderbird['self_link'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...
    ["at", "language-pack-de"]

How about the complement set i.e. the packages not shared?

    >>> response = webservice.named_get(
    ...     '/package-sets/firefox', 'getSourcesNotSharedBy', {},
    ...     other_package_set=thunderbird['self_link'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...
    ["mozilla-firefox"]

    >>> firefox = webservice.get("/package-sets/firefox").jsonBody()
    >>> response = webservice.named_get(
    ...     '/package-sets/thunderbird', 'getSourcesNotSharedBy', {},
    ...     other_package_set=firefox['self_link'])
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...
    ["cnews", "thunderbird"]


== Archive permissions and package sets ==

Operating on package set based archive permissions is possible via
the Launchpad API as well.

The newPackagesetUploader() method is a factory function that adds a new
permission for a person to upload source packages included in a given
package set.

    >>> distros = webservice.get("/distros").jsonBody()
    >>> ubuntu = distros['entries'][0]

Grant upload privileges to 'name12' for package set 'firefox' in the Ubuntu
main archive.

    >>> response = webservice.named_post(
    ...     ubuntu['main_archive_link'], 'newPackagesetUploader', {},
    ...     person=name12['self_link'],
    ...     packageset='firefox')
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

Let's see what we've got:

    >>> from lazr.restful.testing.webservice import pprint_entry
    >>> new_permission = webservice.get(
    ...     response.getHeader('Location')).jsonBody()
    >>> pprint_entry(new_permission)
    archive_link: u'http://.../+archive/primary'
    component_name: None
    date_created: ...
    explicit: False
    package_set_name: u'firefox'
    permission: u'Archive Upload Rights'
    person_link: u'http://.../~name12'
    resource_type_link: ...
    self_link: u'http://.../+archive/primary/+upload/name12?type=packageset&item=firefox'
    source_package_name: None

Grant upload privileges to 'name12' for package set 'mozilla' in the Ubuntu
main archive.

    >>> response = webservice.named_post(
    ...     ubuntu['main_archive_link'], 'newPackagesetUploader', {},
    ...     person=name12['self_link'],
    ...     packageset='mozilla')
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

The following query should only find the permission for the 'firefox'
package set since we're disallowing the use of the package set hierarchy.

    >>> response = webservice.named_get(
    ...     ubuntu['main_archive_link'], 'getUploadersForPackageset', {},
    ...     packageset='firefox')
    >>> print_payload(response)
    http://.../+archive/primary/+upload/name12?type=packageset&item=firefox

Same query, this time allowing the use of the package set hierarchy, finds
the permission for the 'mozilla' package set as well.

    >>> response = webservice.named_get(
    ...     ubuntu['main_archive_link'], 'getUploadersForPackageset', {},
    ...     packageset='firefox', direct_permissions=False)
    >>> print_payload(response)
    http://.../+archive/primary/+upload/name12?type=packageset&item=firefox
    http://.../+archive/primary/+upload/name12?type=packageset&item=mozilla

Let's delete the upload privilege for the 'mozilla' package set.

    >>> response = webservice.named_post(
    ...     ubuntu['main_archive_link'], 'deletePackagesetUploader', {},
    ...     person=name12['self_link'],
    ...     packageset='mozilla')
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    ...

Since the privilege for the 'mozilla' package set was deleted the listing
shows only the remaining permission for the 'firefox' package set.

    >>> response = webservice.named_get(
    ...     ubuntu['main_archive_link'], 'getUploadersForPackageset', {},
    ...     packageset='firefox', direct_permissions=False)
    >>> print_payload(response)
    http://.../+archive/primary/+upload/name12?type=packageset&item=firefox

Let's grant 'cprov' an upload permission to 'mozilla' and 'thunderbird'.

    >>> cprov = webservice.get("/~cprov").jsonBody()
    >>> response = webservice.named_post(
    ...     ubuntu['main_archive_link'], 'newPackagesetUploader', {},
    ...     person=cprov['self_link'],
    ...     packageset='mozilla')
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

    >>> response = webservice.named_post(
    ...     ubuntu['main_archive_link'], 'newPackagesetUploader', {},
    ...     person=cprov['self_link'],
    ...     packageset='thunderbird')
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

We can view the package set based permissions granted to 'cprov' as follows:

    >>> response = webservice.named_get(
    ...     ubuntu['main_archive_link'], 'getPackagesetsForUploader', {},
    ...     person=cprov['self_link'])
    >>> print_payload(response)
    http://.../+archive/primary/+upload/cprov?type=packageset&item=mozilla
    http://.../+archive/primary/+upload/cprov?type=packageset&item=thunderbird

Let's check what package set based upload permissions 'cprov' has for the
'mozilla-firefox' package.

    >>> response = webservice.named_get(
    ...     ubuntu['main_archive_link'], 'getPackagesetsForSourceUploader',
    ...     {}, sourcepackagename='thunderbird',
    ...     person=cprov['self_link'])
    >>> print_payload(response)
    http://.../+archive/primary/+upload/cprov?type=packageset&item=mozilla
    http://.../+archive/primary/+upload/cprov?type=packageset&item=thunderbird

As we expected 'cprov' may upload either via the 'thunderbird' package set
that directly contains the source package in question or via the 'mozilla'
package set that includes the 'thunderbird' set.

How about the 'mozilla-firefox' source package? Is 'cprov' allowed uploads
to it?

    >>> response = webservice.named_get(
    ...     ubuntu['main_archive_link'], 'getPackagesetsForSourceUploader',
    ...     {}, sourcepackagename='mozilla-firefox',
    ...     person=cprov['self_link'])
    >>> print_payload(response)
    http://.../+archive/primary/+upload/cprov?type=packageset&item=mozilla

Yes, and, again via the 'mozilla' package set.

Sometimes we don't care about the details. We just want a yes/no answer to
the question: "is person X allowed to upload package P?".

    >>> response = webservice.named_get(
    ...     ubuntu['main_archive_link'], 'isSourceUploadAllowed',
    ...     {}, sourcepackagename='mozilla-firefox',
    ...     person=cprov['self_link'])
    >>> print(response)
    HTTP/1.1 200 Ok
    ...
    true

'name12' should not be allowed to upload the 'thunderbird' source package.

    >>> response = webservice.named_get(
    ...     ubuntu['main_archive_link'], 'isSourceUploadAllowed',
    ...     {}, sourcepackagename='thunderbird',
    ...     person=name12['self_link'])
    >>> print(response)
    HTTP/1.1 200 Ok
    ...
    false

Sometimes it's also interesting to see what package set based upload
permissions apply to a source package irrespective of the principal.

    >>> response = webservice.named_get(
    ...     ubuntu['main_archive_link'], 'getPackagesetsForSource',
    ...     {}, sourcepackagename='mozilla-firefox')
    >>> print_payload(response)
    http://.../+archive/primary/+upload/name12?type=packageset&item=firefox

The listing above only shows the *direct* upload permission granted to
'name12' via the 'firefox' package set.

We can ask the same question but this time include the indirect upload
permissions arising from the package set hierarchy as well.

    >>> response = webservice.named_get(
    ...     ubuntu['main_archive_link'], 'getPackagesetsForSource',
    ...     {}, sourcepackagename='mozilla-firefox', direct_permissions=False)
    >>> print_payload(response)
    http://.../+archive/primary/+upload/name12?type=packageset&item=firefox
    http://.../+archive/primary/+upload/cprov?type=packageset&item=mozilla

Now we see the upload permission granted to 'cprov' via the 'mozilla' package
set listed as well.
