= Build Pages =

For the subsequent tests we will use a specific 'pmount' build record
from the sampledata which happens to be in FAILEDTOBUILD status.

    >>> from zope.component import getUtility
    >>> from lp.buildmaster.enums import BuildStatus
    >>> from lp.registry.interfaces.distribution import IDistributionSet

    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> hoary = ubuntu.getSeries('hoary')
    >>> hoary_pmount = hoary.getSourcePackage('pmount')

    >>> hoary_failed_build = hoary_pmount.getBuildRecords(
    ...      build_state=BuildStatus.FAILEDTOBUILD)[0]


== Build Menu ==

The menu presented in the build page depends on the targeted archive.
For instance the 'PPA' action-menu link is not enabled for builds
targeted to the PRIMARY archive.

    >>> from lp.soyuz.browser.build import BuildContextMenu
    >>> build_menu = BuildContextMenu(hoary_failed_build)

    >>> print build_menu.links
    ['ppa', 'records', 'retry', 'rescore']

    >>> build_menu.is_ppa_build
    False

    >>> build_menu.ppa().enabled
    False

The 'PPA' action-menu item will be enabled if we target the build to
Celso's PPA.

    >>> from lp.registry.interfaces.person import IPersonSet

    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> cprov_failed_build = cprov.archive.getBuildRecords(
    ...      build_state=BuildStatus.FAILEDTOBUILD)[0]

    >>> build_menu = BuildContextMenu(cprov_failed_build)

    >>> print build_menu.links
    ['ppa', 'records', 'retry', 'rescore']

    >>> build_menu.is_ppa_build
    True

    >>> build_menu.ppa().enabled
    True


== Build +index page ==

Setup an 'empty' request:

    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest
    >>> empty_request = LaunchpadTestRequest(form={})

Let's instantiate the view for +index:

    >>> from zope.component import getMultiAdapter
    >>> hoary_failed_build_view = getMultiAdapter(
    ...     (hoary_failed_build, empty_request), name="+index")

`BuildView` has some cached properties that are used multiple times in
the related templates.

    >>> print hoary_failed_build_view.is_ppa
    False

    >>> print hoary_failed_build_view.buildqueue
    None

    >>> print hoary_failed_build_view.component.name
    main

'BuildView.user_can_retry_build' property checks not only the
user's permissions to retry but also if a build is in a status that it
can be retried.

The build cannot be retried (see IBuild) because it's targeted to a
stable distroseries.

    >>> hoary_failed_build.can_be_retried
    False

    >>> hoary_failed_build_view.user_can_retry_build
    False

The Celso's PPA failed-to-build build record can be retried, since PPA
distroseries never freeze.

    >>> cprov_failed_build.can_be_retried
    True

While the build is now in a state to be rebuilt, the view property
still checks to ensure the user has the proper permission. Anonymous
users, obviously, don't have 'launchpad.Edit' permission on this
build.

    >>> cprov_failed_build_view = getMultiAdapter(
    ...     (cprov_failed_build, empty_request), name="+index")

    >>> cprov_failed_build_view.user_can_retry_build
    False

If accessed by an user with the required permission, Foo Bar in this
case, the 'user_can_retry_build' property finally returns True.

    >>> login("foo.bar@canonical.com")

    >>> cprov_failed_build_view = getMultiAdapter(
    ...     (cprov_failed_build, empty_request), name="+index")

    >>> cprov_failed_build_view.user_can_retry_build
    True

Buildd admins can retry any build as long is it's in a state that
permits it to be re-tried.  FAILEDTOBUILD is one of those states:

    >>> from lp.soyuz.tests.test_publishing import (
    ...      SoyuzTestPublisher)
    >>> from lp.soyuz.enums import (
    ...     PackagePublishingStatus)
    >>> test_publisher = SoyuzTestPublisher()
    >>> test_publisher.prepareBreezyAutotest()
    >>> test_source = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='sourceone')
    >>> [failed_build] = test_source.createMissingBuilds()
    >>> failed_build.status = BuildStatus.FAILEDTOBUILD

    >>> failed_build.can_be_retried
    True

Mr "no privileges" has no rights to retry the build:

    >>> login("no-priv@canonical.com")
    >>> failed_build_view = getMultiAdapter(
    ...     (failed_build, empty_request), name="+index")
    >>> failed_build_view.user_can_retry_build
    False

If he is put in the buildd-admins group, however, he is now able to
retry it.

    >>> buildd_admins = getUtility(IPersonSet).getByName(
    ...     "launchpad-buildd-admins")
    >>> nopriv = getUtility(IPersonSet).getByName("no-priv")
    >>> login("foo.bar@canonical.com")
    >>> ignored = buildd_admins.addMember(nopriv, nopriv)

    >>> login("no-priv@canonical.com")
    >>> failed_build_view = getMultiAdapter(
    ...     (failed_build, empty_request), name="+index")
    >>> failed_build_view.user_can_retry_build
    True

A person in a team that has rights to upload to a packageset can also retry it.

So, create a user, a team, and the packageset:

    >>> login('admin@canonical.com')
    >>> from lp.soyuz.interfaces.archivepermission import IArchivePermissionSet
    >>> from lp.soyuz.interfaces.packageset import IPackagesetSet
    >>> joe = factory.makePerson(email='joe@example.com', password='test')
    >>> desktop = factory.makeTeam(name='desktop', owner=joe)
    >>> main_archive = test_publisher.distroseries.main_archive
    >>> rebuild_ps = getUtility(IPackagesetSet).new(
    ...     u'rebuild', u'Test package set', desktop,
    ...     distroseries=test_publisher.distroseries)
    >>> rebuild_spn = (failed_build.source_package_release.sourcepackagename,)
    >>> rebuild_ps.add(rebuild_spn)

Joe will not have permission to retry the build until we grant it:

    >>> login('joe@example.com')
    >>> failed_build_view = getMultiAdapter(
    ...     (failed_build, empty_request), name="+index")
    >>> failed_build_view.user_can_retry_build
    False
    >>> login('admin@canonical.com')
    >>> perms = getUtility(IArchivePermissionSet).newPackagesetUploader(
    ...     main_archive, desktop, rebuild_ps)
    >>> login('joe@example.com')
    >>> failed_build_view = getMultiAdapter(
    ...     (failed_build, empty_request), name="+index")
    >>> failed_build_view.user_can_retry_build
    True

See pagetests/soyuz/xx-build-record.txt for further information about
the build-retry permission system.

`BuildView.package_upload` returns the cached `PackageUpload` record
corresponding to this build. It's None if the binaries for a build were
not yet collected.

    >>> print cprov_failed_build_view.package_upload
    None

Automatically, 'BuildView.has_published_binaries' reflects this condition.

    >>> print cprov_failed_build_view.has_published_binaries
    False

First let's create a package upload for this build:
XXX: noodles 2009-01-16 bug 317863: move this into the STP.

    >>> from lp.registry.interfaces.pocket import (
    ...     PackagePublishingPocket)
    >>> from lp.soyuz.model.queue import PackageUploadBuild
    >>> build = cprov_failed_build_view.context
    >>> package_upload = build.distro_series.createQueueEntry(
    ...     PackagePublishingPocket.UPDATES, 'changes.txt', 'my changes',
    ...     build.archive)
    >>> package_upload_build = PackageUploadBuild(
    ...     packageupload =package_upload,
    ...     build=cprov_failed_build_view.context)
    >>> print package_upload.status.name
    NEW

Now, our build has a package upload and its status is
NEW. 'has_published_binaries' remains False.

    >>> cprov_failed_build_view = create_initialized_view(
    ...     cprov_failed_build, '+index')

    >>> print cprov_failed_build_view.package_upload.status.name
    NEW

    >>> print cprov_failed_build_view.has_published_binaries
    False

The view 'package_upload' is still available after it has been
accepted and processed. Afterwards 'has_published_binaries' becomes
True.

    >>> login('foo.bar@canonical.com')
    >>> package_upload.setDone()
    >>> login("no-priv@canonical.com")

    >>> cprov_failed_build_view = create_initialized_view(
    ...     cprov_failed_build, '+index')

    >>> print cprov_failed_build_view.package_upload.status.name
    DONE

    >>> print cprov_failed_build_view.has_published_binaries
    True

The BuildIndex view also has a files helper which returns
all the files from the related binary package releases.

    >>> hoary_pmount_build = hoary.getBuildRecords(
    ...     build_state=BuildStatus.FULLYBUILT, name='pmount',
    ...     arch_tag='hppa')[0]
    >>> hoary_pmount_build_view = create_initialized_view(
    ...     hoary_pmount_build, '+index')
    >>> len(hoary_pmount_build_view.files)
    1
    >>> deb_file = hoary_pmount_build_view.files[0]
    >>> print deb_file.filename
    pmount_1.9-1_all.deb

Files that are still referenced by binary package releases but have
been deleted will not be included in the view's files.

    >>> deb_file.deleted
    False
    >>> from zope.security.proxy import removeSecurityProxy
    >>> removeSecurityProxy(deb_file.context).content = None
    >>> deb_file.deleted
    True

    >>> hoary_pmount_build_view = create_initialized_view(
    ...     hoary_pmount_build, '+index')
    >>> len(hoary_pmount_build_view.files)
    0


== BuildRescoringView ==

`BuildRescoringView` is used for setting new values to the
corresponding `BuildQueue.lastscore` record for a `Build`.

It redirects users to the `Build` page when the build cannot be
rescored.

    >>> print cprov_failed_build.can_be_rescored
    False

    >>> view = create_initialized_view(
    ...    cprov_failed_build, name="+rescore")

    >>> view.request.response.getStatus()
    302
    >>> print view.request.response.getHeader('Location')
    http://launchpad.dev/~cprov/+archive/ppa/+buildjob/26

Canceled 'Rescore' form redirects users back to the Build page.

    # Fetch an PENDING build from the sampledata.
    >>> pending_build = ubuntu.getBuildRecords(
    ...      build_state=BuildStatus.NEEDSBUILD)[0]

    >>> view = create_initialized_view(
    ...    pending_build, name="+rescore")

    >>> print view.cancel_url
    http://launchpad.dev/ubuntu/+source/alsa-utils/1.0.9a-4ubuntu1/+buildjob/11

The 'priority' field only accepts long integer values.

    >>> view = create_initialized_view(
    ...    pending_build, name="+rescore", form={
    ...    'field.priority': str(2 ** 31 + 1),
    ...    'field.actions.rescore': 'Rescore',
    ...    })

    >>> for error in view.errors:
    ...     print '%s -> %s' % (error.widget_title, error.doc())
    Priority -> Value is too big

    >>> view = create_initialized_view(
    ...    pending_build, name="+rescore", form={
    ...    'field.priority': '-' + str(2 ** 31 + 1),
    ...    'field.actions.rescore': 'Rescore',
    ...    })

    >>> for error in view.errors:
    ...     print '%s -> %s' % (error.widget_title, error.doc())
    Priority -> Value is too small

Submitting valid values will update the build 'score' and redirect
users to the build page with an appropriate notification.

    >>> print pending_build.buildqueue_record.lastscore
    10

    >>> view = create_initialized_view(
    ...    pending_build, name="+rescore", form={
    ...    'field.priority': '0',
    ...    'field.actions.rescore': 'Rescore',
    ...    })

    >>> view.request.response.getStatus()
    302
    >>> print view.request.response.getHeader('Location')
    http://launchpad.dev/ubuntu/+source/alsa-utils/1.0.9a-4ubuntu1/+buildjob/11

    >>> for notification in view.request.response.notifications:
    ...     print notification.message
    Build rescored to 0.

    >>> print pending_build.buildqueue_record.lastscore
    0


== BuildRecordsView ==

The BuildRecordsView can also be used to filter by architecture tag.

    >>> view = create_initialized_view(
    ...     hoary, name="+builds", form={'build_state': 'all'})
    >>> view.setupBuildList()
    >>> for build in view.complete_builds:
    ...     print build.arch_tag
    i386
    ...
    hppa
    ...

    >>> view = create_initialized_view(
    ...     hoary, name="+builds", form={
    ...         'build_state': 'all',
    ...         'arch_tag': 'hppa',
    ...         })
    >>> view.setupBuildList()
    >>> for build in view.complete_builds:
    ...     print build.arch_tag
    hppa

The architecture_options property iterates through the available
architectures of the context constructing a distinct, sorted list
of options for the template.

    >>> view = create_initialized_view(
    ...     ubuntu, name="+builds", form={
    ...         'build_state': 'all',
    ...         'arch_tag': 'hppa',
    ...         })
    >>> for option in view.architecture_options:
    ...     option_str = option['name']
    ...     if option['selected'] is not None:
    ...         option_str += " (selected)"
    ...     print option_str
    All architectures
    hppa (selected)
    i386


== Dispatch time estimates ==

A dispatch time estimate is available for pending binary builds that have not
been suspended.

    >>> from lp.services.job.interfaces.job import JobStatus
    >>> pending_build = ubuntu.getBuildRecords(
    ...      build_state=BuildStatus.NEEDSBUILD)[0]

    >>> view = create_initialized_view(pending_build, name="+index")
    >>> view.dispatch_time_estimate_available
    True
    >>> view.context.status == BuildStatus.NEEDSBUILD
    True
    >>> view.context.buildqueue_record.job.status == JobStatus.WAITING
    True

If we suspend the binary build job, however, no estimate is available.

    >>> view.context.buildqueue_record.job.suspend()
    >>> view.context.buildqueue_record.job.status == JobStatus.SUSPENDED
    True
    >>> view.dispatch_time_estimate_available
    False
