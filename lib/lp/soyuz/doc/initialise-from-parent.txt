Check the behaviour of the initialise_from_parent script. It basically
calls IDistroSeries.initialiseFromParent method with experimental extra
checks and tasks.

We need to create an initialisable DistroSeries as a child of Ubuntu
Hoary (we do it inside the ubuntutest distribution to avoid conflicts
with other tests)

  >>> from canonical.launchpad.interfaces import IDistributionSet
  >>> from canonical.launchpad.ftests import login

  >>> login("foo.bar@canonical.com")
  >>> distribution_set = getUtility(IDistributionSet)
  >>> ubuntutest = distribution_set['ubuntutest']
  >>> ubuntu = distribution_set['ubuntu']
  >>> hoary = ubuntu['hoary']

  # XXX cprov 2006-05-29 bug=49133:
  # New distroseries should be provided by IDistribution.
  # This maybe affected by derivation design and is documented in bug.

  >>> foobuntu = ubuntutest.newSeries('foobuntu', 'FooBuntu',
  ...                                 'The Foobuntu', 'yeck', 'doom',
  ...                                 '888', hoary, hoary.owner)


The script will check that there are no NEEDSBUILD builds in the parent
distroseries' release pocket, so we need to tweak the status of the NEEDSBUILD
builds that exist in Ubuntu Hoary in the sampledata:

  >>> from lp.buildmaster.interfaces.buildbase import BuildStatus
  >>> from lp.registry.interfaces.pocket import PackagePublishingPocket

  >>> pending_builds = hoary.getBuildRecords(BuildStatus.NEEDSBUILD,
  ...     pocket=PackagePublishingPocket.RELEASE)
  >>> for build in pending_builds:
  ...     build.status = BuildStatus.FAILEDTOBUILD

  >>> import transaction
  >>> transaction.commit()


  >>> import subprocess
  >>> import os
  >>> import sys
  >>> from canonical.config import config


Check if it fails for an already released distroseries:

  >>> script = os.path.join(config.root, "scripts", "ftpmaster-tools",
  ...                       "initialise-from-parent.py")
  >>> process = subprocess.Popen([sys.executable, script, "-vv",
  ...                             "breezy-autotest"],
  ...                            stdout=subprocess.PIPE,
  ...                            stderr=subprocess.PIPE,)
  >>> stdout, stderr = process.communicate()
  >>> process.returncode
  1
  >>> print stderr
  DEBUG   Acquiring lock
  DEBUG   Initialising connection.
  DEBUG   Check empty mutable queues in parentseries
  DEBUG   Check for no pending builds in parentseries
  DEBUG   Copying distroarchseries from parent and setting nominatedarchindep.
  ERROR   Series is already in use.
  <BLANKLINE>


Let's initialise the just created distroseries:

  >>> process = subprocess.Popen([sys.executable, script, "-vv",
  ...                             "-d", "ubuntutest", "foobuntu"],
  ...                            stdout=subprocess.PIPE,
  ...                            stderr=subprocess.PIPE,)
  >>> stdout, stderr = process.communicate()
  >>> process.returncode
  0
  >>> print stderr
  DEBUG   Acquiring lock
  DEBUG   Initialising connection.
  DEBUG   Check empty mutable queues in parentseries
  DEBUG   Check for no pending builds in parentseries
  DEBUG   Copying distroarchseries from parent and setting nominatedarchindep.
  DEBUG   initialising from parent, copying publishing records.
  DEBUG   Committing transaction.
  DEBUG   Releasing lock
  <BLANKLINE>


Checking the published sources and binaries of ubuntutest/foobuntu
against its parent, ubuntu/hoary:

  >>> hoary_pmount_pubs = hoary.getPublishedReleases('pmount')
  >>> foobuntu_pmount_pubs = foobuntu.getPublishedReleases('pmount')
  >>> print foobuntu_pmount_pubs
  ...
  >>> len(foobuntu_pmount_pubs) == len(hoary_pmount_pubs)
  True

  >>> hoary_i386_pmount_pubs = hoary['i386'].getReleasedPackages('pmount')
  >>> foobuntu_i386_pmount_pubs = (
  ...     foobuntu['i386'].getReleasedPackages('pmount'))
  >>> len(foobuntu_i386_pmount_pubs) == len(hoary_i386_pmount_pubs)
  True

Check how the publication records behave in a just-initialise distroseries.
First we get a binarypackagerelease published in foobuntu:

  >>> pmount_binrel = (
  ...     foobuntu['i386'].getReleasedPackages(
  ...     'pmount')[0].binarypackagerelease)
  >>> pmount_binrel.title
  u'pmount-0.1-1'

Follow BPR.build and discover it was built in the parent series:

  >>> pmount_binrel.build.id
  7
  >>> pmount_binrel.build.title
  u'i386 build of pmount 0.1-1 in ubuntu hoary RELEASE'

Now we obtain the sourcepackagerelease from the build:

  >>> pmount_srcrel = pmount_binrel.build.source_package_release
  >>> pmount_srcrel.title
  u'pmount - 0.1-1'

and check it the ISPR.getBuildByArch() would find out the same build
record for foobuntu and it's parent series (hoary):

  >>> foobuntu_pmount = pmount_srcrel.getBuildByArch(
  ...     foobuntu['i386'], foobuntu.main_archive)
  >>> hoary_pmount = pmount_srcrel.getBuildByArch(
  ...     hoary['i386'], hoary.main_archive)

  >>> foobuntu_pmount.id == hoary_pmount.id
  True

It means that queuebuilder doesn't need to create a new build record
in for pmount_0.1-1 in foobuntu.

In the other hand there is a newer source for pmount published in
hoary and consequently in foobuntu:

Note: This is a very unlikely situation, since ubuntu/hoary was marked
as RELEASED before build pmount_0.1-2 in the sampledata. So when we
try initialise a distroseries in another distribution based on hoary,
since they have independent archives (pool), pmount_0.1-1 binary
becomes a NBS (not build from source) since the pmount_0.1-1 source
was superseded in hoary and won't be inherited by the initialised
distroseries.

  >>> pmount_source = hoary.getSourcePackage('pmount').currentrelease
  >>> print pmount_source.title
  "pmount" 0.1-2 source package in The Hoary Hedgehog Release

  >>> pmount_source = foobuntu.getSourcePackage('pmount').currentrelease
  >>> print pmount_source.title
  "pmount" 0.1-2 source package in The Foobuntu


Since pmount_0.1-2 source is published we can safely look up for the
respective build record:

  >>> pmount_source.sourcepackagerelease.getBuildByArch(
  ...    foobuntu['i386'], ubuntu.main_archive) is None
  True

It's not present, Let's create it to check if getBuildByArch responds
appropriately (we won't care about the source architecturehintlist in
this test, see more details in buildd-queuebuilder)

  >>> from lp.registry.interfaces.pocket import PackagePublishingPocket
  >>> created_build = pmount_source.sourcepackagerelease.createBuild(
  ...     foobuntu['i386'], PackagePublishingPocket.RELEASE,
  ...     ubuntu.main_archive)

  >>> retrieved_build = pmount_source.sourcepackagerelease.getBuildByArch(
  ...    foobuntu['i386'], ubuntu.main_archive)

  >>> retrieved_build.id == created_build.id
  True

  >>> pmount_source.sourcepackagerelease.getBuildByArch(
  ...    foobuntu['hppa'], ubuntu.main_archive) is None
  True

initialiseFromParent also copies the permitted source formats from the
parent series.

  >>> from lp.soyuz.interfaces.sourcepackageformat import SourcePackageFormat
  >>> foobuntu.isSourcePackageFormatPermitted(SourcePackageFormat.FORMAT_1_0)
  True
