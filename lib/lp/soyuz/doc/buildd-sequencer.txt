The launchpad buildd task sequencer / serialiser
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The task sequencer is a simple twisted daemon which looks after making
sure that the buildd tasks (E.g. slave scanner, queue builder etc) are
only run one at a time, and potentially more often than once per
minute.

The following is some mock classwork to help us test the system...

  >>> class MockSequencer:
  ...     def __init__(self):
  ...         self.time = 0
  ...     def scheduleCallback(self):
  ...         print "MockSequencer.scheduleCallback()"
  ...     def getCurrentTime(self):
  ...         print "MockSequencer.getCurrentTime()"
  ...         return self.time
  ...     def mailOutFailure(self, code, job):
  ...         print "MockSequencer.mailOutFailure(%d,%s)" % (code, job.name)

  >>> class MockConfigSegment:
  ...    def __init__(self, name, command, mindelay, alwayslog):
  ...        self.name = name
  ...        self.command = command
  ...        self.mindelay = mindelay
  ...        self.alwayslog = alwayslog
  ...   
  ...    @property
  ...    def category_and_section_names(self):
  ...        return ('buildsequencer_job', self.name)

  >>> class MockExitValue:
  ...     def __init__(self, value):
  ...         self.exitCode = value

  >>> class MockStatus:
  ...     def __init__(self, value):
  ...         self.value = MockExitValue(value)

  >>> class MockLogger:
  ...     def debug(self, str):
  ...         print "DEBUG: " + str
  ...         print "WARNING, DEBUG IS DEPRECATED IN NEWER TWISTED"
  ...         assert False
  ...     def msg(self, str):
  ...         print "MSG: " + str
  ...     def err(self, str):
  ...         print "ERR: " + str

  >>> mseq = MockSequencer()
  >>> conf1 = MockConfigSegment('job-name1', 'job-command1', 5, True)
  >>> conf2 = MockConfigSegment('job-name2', 'job-command2', 10, False)
  >>> ok = MockStatus(0)
  >>> fail = MockStatus(1)

Check we can import the sequencer

  >>> from canonical.buildd import sequencer

Sub in the logger so we see log output...

  >>> sequencer.log = MockLogger()

A BuildSequencerJob encapsulates a single job to be run over and over
again.  It configures itself based on its sequencer and job
information from the config file.

  >>> job1 = sequencer.BuildSequencerJob(mseq, conf1)
  MockSequencer.getCurrentTime()
  >>> job1.due
  5
  >>> job2 = sequencer.BuildSequencerJob(mseq, conf2)
  MockSequencer.getCurrentTime()
  >>> job2.due
  10

Because we're not testing the 'run()' method (needs twisted currently)
we just mock up the log and errlog values...

  >>> job1.log = ""
  >>> job1.errlog = ""
  >>> job2.log = ""
  >>> job2.errlog = ""

Check that stdout goes to log and stderr to errlog

  >>> job1.outReceived("FOO")
  >>> job1.log
  'FOO'
  >>> job1.errlog
  ''
  >>> job2.errReceived("BAR")
  >>> job2.errlog
  'BAR'
  >>> job2.log
  ''

When a job has finished, we log information about it. If it succeeded,
we say a simple log entry, if the jobs log is forced, we write the
output and error output too. Then we schedule the next job to run.

  >>> mseq.time = 10

  >>> job1.processEnded(ok)
  MSG: Job job-name1 completed with exit code 0
  MSG: Job output was:
  FOO
  <BLANKLINE>
  MSG: Job error output was:
  <BLANKLINE>
  <BLANKLINE>
  MockSequencer.getCurrentTime()
  MockSequencer.scheduleCallback()
  >>> job1.due
  15

  >>> job2.processEnded(fail)
  MSG: Job job-name2 completed with exit code 1
  MockSequencer.mailOutFailure(1,job-name2)
  MockSequencer.getCurrentTime()
  MockSequencer.scheduleCallback()
  >>> job2.due
  20

Now we consider the sequencer itself...

Since the sequencer itself loads all of its config from the config
system we can check it against the config specified in the
launchpad.conf test section.

  >>> seq = sequencer.BuildSequencer()
  MSG: Loading jobs...
  MSG:    ...loaded slave_scanner
  MSG: Mailer targets set to:
  MSG:    ... -

In order to account for potential timing inconsistencies, we stub out
the time methods for the rest of the tests.

  >>> seq.getCurrentTime = lambda: 0
  >>> seq.jobs[0].getCurrentTime = lambda: 0
  >>> seq.jobs[0].updateDue()

Now let's check that the jobs it loaded are correct...

  >>> seq.jobs[0].name
  'slave_scanner'

Ensure it believes the slave_scanner to be next.

  >>> job, due = seq.findEarliestJob()
  >>> job.name
  'slave_scanner'
  >>> due
  5

Jemmy in a replacement callAfter and see what happens if we schedule a callback

  >>> def jemmy_call_after(due, callback):
  ...     print callback == seq.jobs[0].run
  >>> seq.callAfter = jemmy_call_after
  >>> seq.scheduleCallback()
  MSG: Scheduling slave_scanner for      5 seconds time
  True

We can now check the interpolation of the failure messages...

  >>> sequencer.failure_message = """FROM: %(from)s
  ... TO: %(to)s
  ... JOB: %(job)s
  ... EXITCODE: %(exitcode)d
  ... CMD: %(cmd)s
  ... LOG: %(log)s
  ... ERRLOG: %(errlog)s
  ... """
  >>> print seq.interpolateFailureFor("-",0,job1)
  FROM: launchpad@lists.canonical.com
  TO: -
  JOB: job-name1
  EXITCODE: 0
  CMD: job-command1
  LOG: FOO
  ERRLOG:
  <BLANKLINE>

And finally, check that mailOutFailure reports correctly...

  >>> seq.mailOutFailure(1, job2)
  ERR: FROM: launchpad@lists.canonical.com
  TO: -
  JOB: job-name2
  EXITCODE: 1
  CMD: job-command2
  LOG:
  ERRLOG: BAR
  <BLANKLINE>

We need to prepare a false sendmail method for the next test...

  >>> def jemmy_send_mail(host, fromaddr, to, msg):
  ...     print "HOST: " + host
  ...     print "FROM: " + fromaddr
  ...     print "TO: " + to
  ...     print "MSGTXT: " + msg
  ...     class MockDeferred:
  ...         def addErrback(self, err):
  ...             print err == sequencer.log.err
  ...     return MockDeferred()

  >>> sequencer.sendmail = jemmy_send_mail

Check that we call the sendmail path of the mailOutFailure method
properly when there is a real email address in the list of intended
recipients.

  >>> seq.mailertargets.append("dsilvers@digital-scurf.org")
  >>> seq.mailOutFailure(1, job1)
  ERR: FROM: launchpad@lists.canonical.com
  TO: -
  JOB: job-name1
  EXITCODE: 1
  CMD: job-command1
  LOG: FOO
  ERRLOG:
  <BLANKLINE>
  MSG: Mailing report to: dsilvers@digital-scurf.org
  HOST: localhost
  FROM: launchpad@lists.canonical.com
  TO: dsilvers@digital-scurf.org
  MSGTXT: FROM: launchpad@lists.canonical.com
  TO: dsilvers@digital-scurf.org
  JOB: job-name1
  EXITCODE: 1
  CMD: job-command1
  LOG: FOO
  ERRLOG:
  <BLANKLINE>
  True


That's all there is to it really. There is a .tac file, but it's very
short and can be seen in daemons/buildd-sequencer.tac
