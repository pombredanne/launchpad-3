= Person and Account =

The Person object is responsible for updating the status of its
Account object.


== Activating user accounts ==

A user may activate their account that was created by an automated
process. Matsubara's account was created during a code import.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet, IEmailAddressSet)

    >>> emailset = getUtility(IEmailAddressSet)
    >>> emailaddress = emailset.getByEmail('matsubara@async.com.br')
    >>> matsubara = emailaddress.person
    >>> matsubara.is_valid_person
    False
    >>> matsubara.account_status
    <DBItem AccountStatus.NOACCOUNT, ...>
    >>> print matsubara.password
    None
    >>> print matsubara.preferredemail
    None

The account can only be activated by the user who is claiming
the profile. Mark cannot claim it.

    >>> login('mark@hbd.com')
    >>> matsubara.account.activate(
    ...     comment="test", password='ok', preferred_email=emailaddress)
    Traceback (most recent call last):
    ...
    Unauthorized: ...'launchpad.Special')

Matsubara can. A password and a preferred email address must be passed
as arguments.

    >>> from zope.security.proxy import removeSecurityProxy
    >>> login('matsubara@async.com.br')
    >>> matsubara.account.activate(
    ...     comment="test", password='ok', preferred_email=emailaddress)
    >>> import transaction
    >>> transaction.commit()
    >>> matsubara.is_valid_person
    True
    >>> matsubara.account.status
    <DBItem AccountStatus.ACTIVE, ...>
    >>> matsubara.account.status_comment
    u'test'
    >>> removeSecurityProxy(matsubara.account.preferredemail).email
    u'matsubara@async.com.br'


== Deactivating user accounts ==

Any user can deactivate his own account, in case they don't want it
anymore or they don't want to be shown as Launchpad users.

As seen below, Foo Bar has a bunch of stuff assigned/owned to/by him in
Launchpad which we'll want to be reassigned/unassigned if his account is
deactivated.  Unfortunately, Foo Bar has no specifications assigned to
him, so we'll assign one just to prove that deactivating his account
will cause this spec to be reassigned.


    >>> personset = getUtility(IPersonSet)
    >>> foobar_preferredemail = emailset.getByEmail('foo.bar@canonical.com')
    >>> foobar = personset.get(foobar_preferredemail.personID)
    >>> foobar.specifications().count() > 0
    True

    >>> from canonical.launchpad.database import Person, Specification
    >>> spec = Specification.selectFirst("assignee IS NULL", orderBy='id')
    >>> spec.assignee = foobar

    >>> [membership.team.name for membership in foobar.myactivememberships]
    [u'canonical-partner-dev', u'guadamen', u'admins',
     u'launchpad-buildd-admins', u'launchpad', u'testing-spanish-team',
     u'name18', u'ubuntu-team', u'vcs-imports']

    >>> [email.email for email in foobar.validatedemails]
    [u'admin@canonical.com']

    >>> foobar.name
    u'name16'

    >>> foobar.preferredemail.email
    u'foo.bar@canonical.com'

    >>> [coc.active for coc in foobar.signedcocs]
    [True]

    >>> from canonical.launchpad.interfaces import BugTaskSearchParams
    >>> params = BugTaskSearchParams(foobar, assignee=foobar)
    >>> foobar.searchTasks(params).count() > 0
    True

    >>> len(foobar.assigned_specs) > 0
    True

    >>> foobar_pillars = []
    >>> for pillar_name in foobar.getOwnedOrDrivenPillars():
    ...     pillar = pillar_name.pillar
    ...     if pillar.owner == foobar or pillar.driver == foobar:
    ...         foobar_pillars.append(pillar_name)
    >>> len(foobar_pillars) > 0
    True

    >>> foobar_teams = list(Person.selectBy(teamowner=foobar))
    >>> len(foobar_teams) > 0
    True

    >>> foobar.is_valid_person
    True

    >>> comment = ("I'm a person who doesn't want to be listed "
    ...            "as a Launchpad user.")

The deactivateAccount method is restricted to the user himself --not
even launchpad admins can use it.

    >>> login('mark@hbd.com')
    >>> foobar.deactivateAccount(comment)
    Traceback (most recent call last):
    ...
    Unauthorized: ...'launchpad.Special')

    >>> login('foo.bar@canonical.com')
    >>> foobar.deactivateAccount(comment)

Deactivating an account changes many of the person's attributes.  It
adds a '-deactivatedaccount' suffix to the person's name...

    >>> foobar.name
    u'name16-deactivatedaccount'

...an account status of DEACTIVATED...

    >>> foobar.account_status
    <DBItem AccountStatus.DEACTIVATED...

    >>> foobar.account_status_comment
    u"I'm a person who doesn't want to be listed as a Launchpad user."

...to have no team memberships...

    >>> [membership.team.name for membership in foobar.myactivememberships]
    []

...and no validated/preferred email addresses...

    >>> [email.email for email in foobar.validatedemails]
    []

    >>> print getattr(foobar.preferredemail, 'email', None)
    None

...no signed codes of conduct...

    >>> [coc.active for coc in foobar.signedcocs]
    [False]

...no assigned bug tasks...

    >>> foobar.searchTasks(params).count()
    0

...no assigned specs...

    >>> len(foobar.assigned_specs)
    0

...no owned teams...

    >>> Person.selectBy(teamowner=foobar).count()
    0

...no owned or driven pillars...

    >>> foobar.getOwnedOrDrivenPillars().count()
    0

...and, finally, to not be considered a valid person in Launchpad.

    >>> transaction.commit()
    >>> foobar.is_valid_person
    False

It's also important to note that the teams/pillars owned/driven by Foo
Bar are now owned/driven by the registry admins team.

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> registry_experts = getUtility(ILaunchpadCelebrities).registry_experts

    >>> registry_pillars = set(registry_experts.getOwnedOrDrivenPillars())
    >>> registry_pillars.issuperset(foobar_pillars)
    True

    >>> registry_teams = set(Person.selectBy(teamowner=registry_experts))
    >>> registry_teams.issuperset(foobar_teams)
    True


== Reactivating user accounts ==

Accounts can be reactivated. A comment is required to log why this was
done, and a password is required too. There are two preconditions before
this method can be called on an Account: The password and the preferred
email address cannot not be None.

    >>> foobar.account.reactivate(
    ...     'This will raise an error.', password=None, preferred_email=None)
    Traceback (most recent call last):
     ...
    AssertionError: Account ... cannot be reactivated without a password.

    >>> foobar.account.reactivate(
    ...     'This will raise an error.', password='ok', preferred_email=None)
    Traceback (most recent call last):
     ...
    AssertionError: Account ... cannot be activated without a preferred
                    email address.

The account can be reactivated after the password and preferred email
address are set.

    >>> foobar.reactivate(
    ...     'User reactivated the account using reset password.',
    ...     password="ok",
    ...     preferred_email=foobar_preferredemail)
    >>> transaction.commit()  # To see the changes on other stores.
    >>> foobar.account.status
    <DBItem AccountStatus.ACTIVE...

    >>> foobar.account.status_comment
    u'User reactivated the account using reset password.'

The person name is fixed if it was altered when it was deactivated.

    >>> foobar.name
    u'name16'
